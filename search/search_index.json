{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Software module for DNA structure generation and analysis","text":"<p>This site contains the project documentation for the <code>mdna</code> project that is python toolkit for the structure generation and analysis of DNA simulations.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Quick Start</li> <li>Tutorials</li> <li>Explanation</li> <li>Jupyter Notebooks</li> <li>Modules</li> <li>API reference</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#citation","title":"Citation","text":"<p>Link to the publication</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I want to thank my house plants for providing me with a negligible amount of oxygen each day. Also, I want to thank the sun for providing more than half of their nourishment free of charge.</p>"},{"location":"index-api/","title":"API reference","text":"<p>This section of the documentation provides detailed, information-oriented references for the technical implementation of the <code>mdna</code> project code. It is intended as a comprehensive guide for developers and users who wish to understand the inner workings of the MDNA tool, its modules, and functions.</p> <ol> <li>Nucleic</li> <li>Shapes</li> <li>Geometry</li> </ol>"},{"location":"index-modules/","title":"Modules API reference","text":"<p>This section of the documentation provides detailed, information-oriented references for the technical implementation of the <code>mdna</code> project code. It is intended as a comprehensive guide for developers and users who wish to understand the inner workings of the MDNA tool, its modules, and functions.</p> <ol> <li>Core</li> <li>Build</li> <li>Modify</li> <li>Analyse</li> </ol>"},{"location":"index-notebooks/","title":"Juypter Notebooks","text":"<p>Basic Notebooks:</p> <ul> <li>Structure Generation</li> <li>Draw DNA Structures</li> <li>Modify DNA Structures</li> <li>Analyse DNA Structures</li> </ul> <p>Advanced Notebooks:</p> <ul> <li>DNA Along H-NS Filament</li> <li>Add Linker DNA to Nucleosome</li> <li>Add DNA Loop to bridging protein</li> <li>How to add base to Sequence Library</li> </ul>"},{"location":"index-tutorials/","title":"Tutorials: Generating and Analyzing DNA Structures with mdna","text":"<p>These tutorials will guide you through the process of generating DNA structures, analyzing them, and performing various modifications using the mdna module. We'll cover the following key aspects:</p> <ul> <li>Quickstart</li> <li>Build: Generating DNA structures</li> <li>Modify: Mutate, methylate and flip sequences</li> <li>Analyse: Load trajectories and compute rigid base parameters</li> </ul>"},{"location":"api/geometry-reference/","title":"Geometry classes","text":""},{"location":"api/geometry-reference/#rigid-nucleobase-class","title":"Rigid Nucleobase class","text":""},{"location":"api/geometry-reference/#pymdna.geometry.ReferenceBase","title":"<code>pymdna.geometry.ReferenceBase</code>","text":"<p>summary</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>class ReferenceBase:\n    \"\"\"_summary_\n    \"\"\"\n    def __init__(self, traj):\n        \"\"\"_summary_\n\n        Args:\n            traj (_type_): _description_\n        \"\"\"\n        self.traj = traj\n        # Determine base type (purine/pyrimidine/other)\n        self.base_type = self.get_base_type()\n        # Define the Tsukuba convention parameters\n        self.tau_1, self.tau_2, self.d = np.radians(141.478), -np.radians(54.418), 0.4702     \n        # Get coordinates of key atoms based on base type\n        self.C1_coords, self.N_coords, self.C_coords = self.get_coordinates()\n        # Calculate base reference point and base vectors\n        self.b_R, self.b_L, self.b_D, self.b_N = self.calculate_base_frame()\n        # self.basis = np.array([self.b_D.T, self.b_L.T, self.b_N])\n\n    def _select_atom_by_name(self, name):\n        \"\"\"_summary_\n\n        Args:\n            name (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # Select an atom by name returns shape (n_frames, 1, [x,y,z])\n        return np.squeeze(self.traj.xyz[:,[self.traj.topology.select(f'name {name}')[0]],:],axis=1)\n\n    def get_base_type(self):\n        \"\"\"_summary_\n\n        Raises:\n            ValueError: _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # Extracts all non-hydrogen atoms from the trajectory topology\n        atoms = {atom.name for atom in self.traj.topology.atoms if atom.element.symbol != 'H'}\n\n        # Check each base in the dictionary to see if all its atoms are present in the extracted atoms set\n        for base, base_atoms in NUCLEOBASE_DICT.items():\n            if all(atom in atoms for atom in base_atoms):\n                return base\n        # If no base matches, raise an error\n        raise ValueError(\"Cannot determine the base type from the PDB file.\")\n\n    def get_coordinates(self):\n        \"\"\"_summary_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # Get the coordinates of key atoms based on the base type\n        C1_coords = self._select_atom_by_name('\"C1\\'\"')\n        if self.base_type in ['C','T','U','D']:# \"pyrimidine\"\n            N_coords = self._select_atom_by_name(\"N1\")\n            C_coords = self._select_atom_by_name(\"C2\")\n        elif self.base_type in ['A','G','E','B','P']:# \"purine\":\n            N_coords = self._select_atom_by_name(\"N9\")\n            C_coords = self._select_atom_by_name(\"C4\") \n        elif self.base_type in ['S','Z']: # Hachi pyrimidine analogues\n            N_coords = self._select_atom_by_name(\"C1\")\n            C_coords = self._select_atom_by_name(\"C2\")\n        elif self.base_type in ['L']: # UBPs hydrophobic\n            N_coords = self._select_atom_by_name(\"N1\")\n            C_coords = self._select_atom_by_name(\"C5\")\n        elif self.base_type in ['M']: # UBPs hydrophilic\n            N_coords = self._select_atom_by_name(\"C1\")\n            C_coords = self._select_atom_by_name(\"C6\")\n        return C1_coords, N_coords, C_coords\n\n\n    def calculate_base_frame(self):\n        \"\"\"_summary_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n\n        # Calculate normal vector using cross product of vectors formed by key atoms\n        #  The coords have the shape (n,1,3)\n        b_N = np.cross((self.N_coords - self.C1_coords), (self.N_coords-self.C_coords), axis=1)\n        b_N /= np.linalg.norm(b_N, axis=1, keepdims=True)  # Normalize b_N to have unit length\n\n        # Compute displacement vector N-C1' \n        N_C1_vector = self.C1_coords - self.N_coords  # Pointing from N to C1'\n        N_C1_vector /= np.linalg.norm(N_C1_vector, axis=1, keepdims=True)\n\n        # Rotate N-C1' vector by angle tau_1 around b_N to get the direction for displacement\n        R_b_R = RigidBody.get_rotation_matrix(self.tau_1 * b_N)\n\n        # Displace N along this direction by a distance d to get b_R\n        b_R = self.N_coords + np.einsum('ijk,ik-&gt;ij', R_b_R, N_C1_vector * self.d)\n\n        # Take a unit vector in the N-C1' direction, rotate it around b_N by angle tau_2 to get b_L\n        R_b_L = RigidBody.get_rotation_matrix(self.tau_2 * b_N)\n        b_L = np.einsum('ijk,ik-&gt;ij', R_b_L, N_C1_vector) \n\n        # Calculate b_D using cross product of b_L and b_N\n        b_D = np.cross(b_L, b_N, axis=1)\n\n        return np.array([b_R, b_D, b_L, b_N])\n        #return np.array([b_R, -b_D, -b_L, -b_N])\n\n    def plot_baseframe(self,atoms=True, frame=True, ax=None,length=1):\n        \"\"\"_summary_\n\n        Args:\n            atoms (bool, optional): _description_. Defaults to True.\n            frame (bool, optional): _description_. Defaults to True.\n            ax (_type_, optional): _description_. Defaults to None.\n            length (int, optional): _description_. Defaults to 1.\n        \"\"\"\n        if ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n        else:\n            fig = False\n\n        # Plot the DNA atoms\n        if atoms:\n            atoms_coords = self.traj.xyz[0]\n            ax.scatter(atoms_coords[:,0], atoms_coords[:,1], atoms_coords[:,2], alpha=0.6)\n\n        # Plot the reference frame vectors\n        if frame:\n            origin = self.b_R[0]\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_L[0][0], self.b_L[0][1], self.b_L[0][2], \n                    color='r', length=length, normalize=True)\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_D[0][0], self.b_D[0][1], self.b_D[0][2], \n                    color='g', length=length, normalize=True)\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_N[0][0], self.b_N[0][1], self.b_N[0][2], \n                    color='b', length=length, normalize=True)\n\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n\n        if fig: \n            # Make axes of equal length\n            max_range = np.array([\n                atoms_coords[:,0].max()-atoms_coords[:,0].min(), \n                atoms_coords[:,1].max()-atoms_coords[:,1].min(), \n                atoms_coords[:,2].max()-atoms_coords[:,2].min()\n            ]).max() / 2.0\n\n            mid_x = (atoms_coords[:,0].max()+atoms_coords[:,0].min()) * 0.5\n            mid_y = (atoms_coords[:,1].max()+atoms_coords[:,1].min()) * 0.5\n            mid_z = (atoms_coords[:,2].max()+atoms_coords[:,2].min()) * 0.5\n            ax.set_xlim(mid_x - max_range, mid_x + max_range)\n            ax.set_ylim(mid_y - max_range, mid_y + max_range)\n            ax.set_zlim(mid_z - max_range, mid_z + max_range)\n\n        ax.axis('equal')\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.ReferenceBase.__init__","title":"<code>__init__(traj)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>_type_</code> <p>description</p> required Source code in <code>src/pymdna/geometry.py</code> <pre><code>def __init__(self, traj):\n    \"\"\"_summary_\n\n    Args:\n        traj (_type_): _description_\n    \"\"\"\n    self.traj = traj\n    # Determine base type (purine/pyrimidine/other)\n    self.base_type = self.get_base_type()\n    # Define the Tsukuba convention parameters\n    self.tau_1, self.tau_2, self.d = np.radians(141.478), -np.radians(54.418), 0.4702     \n    # Get coordinates of key atoms based on base type\n    self.C1_coords, self.N_coords, self.C_coords = self.get_coordinates()\n    # Calculate base reference point and base vectors\n    self.b_R, self.b_L, self.b_D, self.b_N = self.calculate_base_frame()\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.ReferenceBase.calculate_base_frame","title":"<code>calculate_base_frame()</code>","text":"<p>summary</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def calculate_base_frame(self):\n    \"\"\"_summary_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n\n    # Calculate normal vector using cross product of vectors formed by key atoms\n    #  The coords have the shape (n,1,3)\n    b_N = np.cross((self.N_coords - self.C1_coords), (self.N_coords-self.C_coords), axis=1)\n    b_N /= np.linalg.norm(b_N, axis=1, keepdims=True)  # Normalize b_N to have unit length\n\n    # Compute displacement vector N-C1' \n    N_C1_vector = self.C1_coords - self.N_coords  # Pointing from N to C1'\n    N_C1_vector /= np.linalg.norm(N_C1_vector, axis=1, keepdims=True)\n\n    # Rotate N-C1' vector by angle tau_1 around b_N to get the direction for displacement\n    R_b_R = RigidBody.get_rotation_matrix(self.tau_1 * b_N)\n\n    # Displace N along this direction by a distance d to get b_R\n    b_R = self.N_coords + np.einsum('ijk,ik-&gt;ij', R_b_R, N_C1_vector * self.d)\n\n    # Take a unit vector in the N-C1' direction, rotate it around b_N by angle tau_2 to get b_L\n    R_b_L = RigidBody.get_rotation_matrix(self.tau_2 * b_N)\n    b_L = np.einsum('ijk,ik-&gt;ij', R_b_L, N_C1_vector) \n\n    # Calculate b_D using cross product of b_L and b_N\n    b_D = np.cross(b_L, b_N, axis=1)\n\n    return np.array([b_R, b_D, b_L, b_N])\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.ReferenceBase.get_base_type","title":"<code>get_base_type()</code>","text":"<p>summary</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def get_base_type(self):\n    \"\"\"_summary_\n\n    Raises:\n        ValueError: _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Extracts all non-hydrogen atoms from the trajectory topology\n    atoms = {atom.name for atom in self.traj.topology.atoms if atom.element.symbol != 'H'}\n\n    # Check each base in the dictionary to see if all its atoms are present in the extracted atoms set\n    for base, base_atoms in NUCLEOBASE_DICT.items():\n        if all(atom in atoms for atom in base_atoms):\n            return base\n    # If no base matches, raise an error\n    raise ValueError(\"Cannot determine the base type from the PDB file.\")\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.ReferenceBase.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>summary</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"_summary_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Get the coordinates of key atoms based on the base type\n    C1_coords = self._select_atom_by_name('\"C1\\'\"')\n    if self.base_type in ['C','T','U','D']:# \"pyrimidine\"\n        N_coords = self._select_atom_by_name(\"N1\")\n        C_coords = self._select_atom_by_name(\"C2\")\n    elif self.base_type in ['A','G','E','B','P']:# \"purine\":\n        N_coords = self._select_atom_by_name(\"N9\")\n        C_coords = self._select_atom_by_name(\"C4\") \n    elif self.base_type in ['S','Z']: # Hachi pyrimidine analogues\n        N_coords = self._select_atom_by_name(\"C1\")\n        C_coords = self._select_atom_by_name(\"C2\")\n    elif self.base_type in ['L']: # UBPs hydrophobic\n        N_coords = self._select_atom_by_name(\"N1\")\n        C_coords = self._select_atom_by_name(\"C5\")\n    elif self.base_type in ['M']: # UBPs hydrophilic\n        N_coords = self._select_atom_by_name(\"C1\")\n        C_coords = self._select_atom_by_name(\"C6\")\n    return C1_coords, N_coords, C_coords\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.ReferenceBase.plot_baseframe","title":"<code>plot_baseframe(atoms=True, frame=True, ax=None, length=1)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>frame</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>ax</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>length</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def plot_baseframe(self,atoms=True, frame=True, ax=None,length=1):\n    \"\"\"_summary_\n\n    Args:\n        atoms (bool, optional): _description_. Defaults to True.\n        frame (bool, optional): _description_. Defaults to True.\n        ax (_type_, optional): _description_. Defaults to None.\n        length (int, optional): _description_. Defaults to 1.\n    \"\"\"\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n    else:\n        fig = False\n\n    # Plot the DNA atoms\n    if atoms:\n        atoms_coords = self.traj.xyz[0]\n        ax.scatter(atoms_coords[:,0], atoms_coords[:,1], atoms_coords[:,2], alpha=0.6)\n\n    # Plot the reference frame vectors\n    if frame:\n        origin = self.b_R[0]\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_L[0][0], self.b_L[0][1], self.b_L[0][2], \n                color='r', length=length, normalize=True)\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_D[0][0], self.b_D[0][1], self.b_D[0][2], \n                color='g', length=length, normalize=True)\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_N[0][0], self.b_N[0][1], self.b_N[0][2], \n                color='b', length=length, normalize=True)\n\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n\n    if fig: \n        # Make axes of equal length\n        max_range = np.array([\n            atoms_coords[:,0].max()-atoms_coords[:,0].min(), \n            atoms_coords[:,1].max()-atoms_coords[:,1].min(), \n            atoms_coords[:,2].max()-atoms_coords[:,2].min()\n        ]).max() / 2.0\n\n        mid_x = (atoms_coords[:,0].max()+atoms_coords[:,0].min()) * 0.5\n        mid_y = (atoms_coords[:,1].max()+atoms_coords[:,1].min()) * 0.5\n        mid_z = (atoms_coords[:,2].max()+atoms_coords[:,2].min()) * 0.5\n        ax.set_xlim(mid_x - max_range, mid_x + max_range)\n        ax.set_ylim(mid_y - max_range, mid_y + max_range)\n        ax.set_zlim(mid_z - max_range, mid_z + max_range)\n\n    ax.axis('equal')\n</code></pre>"},{"location":"api/geometry-reference/#rigid-base-parameter-class","title":"Rigid Base Parameter class","text":""},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames","title":"<code>pymdna.geometry.NucleicFrames</code>","text":"<p>Class to compute the rigid base parameters of a DNA structure.</p> <p>loc = '/Users/thor/surfdrive/Scripts/notebooks/HNS-sequence/WorkingDir/nolinker/data/md/0_highaff/FI/drytrajs/' traj = md.load(loc+'dry_10.xtc',top=loc+'dry_10.pdb')</p> <p>dna = NucleicFrames(traj) params, names = dna.get_paramters() params.shape, names</p>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames--confidence-intervals","title":"Confidence intervals","text":"<p>from scipy.stats import t</p> <p>fig, ax = plt.subplots(2,6,figsize=(12,4)) fig.tight_layout() ax = ax.flatten() M = np.mean(params, axis=0) S = np.std(params, axis=0) n = params.shape[0] ci = t.ppf(0.975, df=n-1) * S / np.sqrt(n) x = np.arange(0, params.shape[1]) for , i in enumerate(M.T):     if _ &gt;= 6:         c1, c2 = 'red','coral'     else:         c1, c2 = 'blue','cornflowerblue'     ax[].plot(i[::-1], '-o',color=c1)     ax[].fill_between(x, (i-ci[])[::-1], (i+ci[])[::-1], color=c2, alpha=0.2)     ax[].set_title(names[_])</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>class NucleicFrames:\n    \"\"\"Class to compute the rigid base parameters of a DNA structure.\n\n    loc = '/Users/thor/surfdrive/Scripts/notebooks/HNS-sequence/WorkingDir/nolinker/data/md/0_highaff/FI/drytrajs/'\n    traj = md.load(loc+'dry_10.xtc',top=loc+'dry_10.pdb')\n\n    dna = NucleicFrames(traj)\n    params, names = dna.get_paramters()\n    params.shape, names\n\n    # Confidence intervals \n    from scipy.stats import t\n\n    fig, ax = plt.subplots(2,6,figsize=(12,4))\n    fig.tight_layout()\n    ax = ax.flatten()\n    M = np.mean(params, axis=0)\n    S = np.std(params, axis=0)\n    n = params.shape[0]\n    ci = t.ppf(0.975, df=n-1) * S / np.sqrt(n)\n    x = np.arange(0, params.shape[1])\n    for _, i in enumerate(M.T):\n        if _ &gt;= 6:\n            c1, c2 = 'red','coral'\n        else:\n            c1, c2 = 'blue','cornflowerblue'\n        ax[_].plot(i[::-1], '-o',color=c1)\n        ax[_].fill_between(x, (i-ci[_])[::-1], (i+ci[_])[::-1], color=c2, alpha=0.2)\n        ax[_].set_title(names[_])\n    \"\"\"\n\n    def __init__(self, traj, chainids=[0,1]):\n        \"\"\"Initialize the NucleicFrames object.\n\n        Args:\n            traj (object): MDtraj trajectory object.\n            chainids (list, optional): Chainids of sense- and anti-sense strands. Defaults to [0,1].\n        \"\"\"\n        self.traj = traj\n        self.top = traj.topology\n        self.res_A = self.get_residues(chain_index=chainids[0], reverse=False)\n        self.res_B = self.get_residues(chain_index=chainids[1], reverse=True)\n        self.mean_reference_frames = np.empty((len(self.res_A), 1, 4, 3))\n        self.base_frames = self.get_base_reference_frames()\n        self.analyse_frames()\n\n    def get_residues(self, chain_index, reverse=False):\n        \"\"\"Get residues from specified chain.\"\"\"\n        if chain_index &gt;= len(self.top._chains):\n            raise IndexError(\"Chain index out of range.\")\n        chain = self.top._chains[chain_index]\n        residues = chain._residues\n        return list(reversed(residues)) if reverse else residues\n\n    def load_reference_bases(self):\n        \"\"\"Load reference bases from local files.\"\"\"\n        # Not used at the moment??\n        bases = ['C', 'G', 'T', 'A']\n        #return {f'D{base}': md.load_pdb(get_data_file_path(f'./atomic/NDB96_{base}.pdb')) for base in bases}\n        return {f'D{base}': md.load_hdf5(get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in bases}\n\n    def get_base_vectors(self, res):\n        \"\"\"Compute base vectors from reference base.\"\"\"\n        ref_base = ReferenceBase(res)\n        return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n\n    def get_base_reference_frames(self):\n        \"\"\"Get reference frames for each residue.\"\"\"\n        reference_frames = {} # Dictionary to store the base vectors for each residue\n        for res in self.res_A + self.res_B:\n            res_traj = self.traj.atom_slice([at.index for at in res.atoms])\n            base_vectors = self.get_base_vectors(res_traj)\n            reference_frames[res] = base_vectors # Store the base vectors for the residue index (with shape (4, n_frames, 3))\n        return reference_frames\n\n    def reshape_input(self,input_A,input_B,is_step=False):\n\n        \"\"\"Reshape the input to the correct format for the calculations.\n\n        Args:\n        input_A (ndarray): Input array for the first triad.\n        input_B (ndarray): Input array for the second triad.\n        is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n        Returns:\n        rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n        rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n        origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n        origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n        original_shape (tuple): The original shape of the input.\n        \"\"\"\n\n        # Store original shape\n        original_shape = input_A.shape\n\n        # Flatten frames to compute rotation matrices for each time step simultaneously\n        input_A_ = input_A.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n        input_B_ = input_B.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n\n        # Extract the triads without origin (rotation matrices)\n        rotation_A = input_A_[:,1:]  # shape (n, 3, 3)\n        rotation_B = input_B_[:,1:]  # shape (n, 3, 3)\n\n        if not is_step:\n            # flip (connecting the backbones) and the (baseplane normals).\n            # so the second and third vector b_L, b_N\n            rotation_B[:,[1,2]] *= -1\n\n        # Extract origins of triads\n        origin_A = input_A_[:,0]  # shape (n, 3)\n        origin_B = input_B_[:,0]  # shape (n, 3)\n\n        return rotation_A, rotation_B, origin_A, origin_B, original_shape\n\n\n    def compute_parameters(self, rotation_A, rotation_B, origin_A, origin_B):\n        \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n        Args:\n            rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n            rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n            origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n            origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n\n        Returns:\n            rigid_parameters (ndarray): The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.\n            trans_mid (ndarray): The mean translational vector of shape (n, 3) between the triads.\n            rotation_mid (ndarray): The mean rotation matrix of shape (n, 3, 3) between the triads.\n        \"\"\"\n\n        # Linear interpolation of translations\n        trans_mid = 0.5 * (origin_A + origin_B)\n\n        # Relative translation\n        trans_AB = origin_A - origin_B\n\n        # Get relative rotation matrix of base pair\n        rotation_BA = rotation_B.transpose(0,2,1) @ rotation_A  # returns shape (n, 3, 3)\n\n        # Get rotation angles based on  rotation matrices\n        rotation_angle_BA = RigidBody.extract_omega_values(rotation_BA)\n\n        # Compute halfway rotation matrix and triad (mid frame)\n        rotation_halfway = RigidBody.get_rotation_matrix(rotation_angle_BA * 0.5)\n\n        # Get rotation matrix of base pair (aka mean rotation frame)\n        rotation_mid = rotation_B @ rotation_halfway \n\n        # Get transaltional coordinate vector and convert to angstroms\n        translational_parameters = np.einsum('ijk,ik-&gt;ij',rotation_mid.transpose(0,2,1), trans_AB) * 10\n\n        # Get rotational parameters and convert to degrees\n        rotational_parameters = np.rad2deg(np.einsum('ijk,ik-&gt;ij', rotation_BA.transpose(0,2,1), rotation_angle_BA))\n\n        # Merge translational and rotational parameters\n        rigid_parameters = np.hstack((translational_parameters, rotational_parameters))\n\n        # Return the parameters and the mean reference frame\n        return rigid_parameters, trans_mid, rotation_mid\n\n\n    def calculate_parameters(self,frames_A, frames_B, is_step=False):\n        \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n        Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads.\n        The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame.\n        With the order of the vectors being: b_R, b_L, b_D, b_N.\n\n        Args:\n            frames_A (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain A.\n            frames_B (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain B.\n            is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n        Notes:\n            Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.\n\n        Returns:\n            params (ndarray): The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.\n            mean_reference_frames (ndarray): The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.\n        \"\"\"\n\n        # Reshape frames\n        rotation_A, rotation_B, origin_A, origin_B, original_shape = self.reshape_input(frames_A,frames_B, is_step=is_step)\n\n        # Compute parameters\n        if not is_step:\n            # Flip from row to column representation of the rotation matrices\n            rotation_A = rotation_A.transpose(0,2,1)\n            rotation_B = rotation_B.transpose(0,2,1)\n            params, mean_origin, mean_rotation = self.compute_parameters(rotation_A, rotation_B, origin_A, origin_B)\n        else:\n            # Switch the input of the B and A triads to get the correct parameters\n            params, mean_origin, mean_rotation = self.compute_parameters(rotation_B, rotation_A, origin_B, origin_A)\n\n        # Reshape the parameters to the original shape\n        params = params.reshape(original_shape[0], original_shape[1], 6).swapaxes(0, 1)\n\n        # Collect mean reference frames from mid frames of each base pair\n        mean_reference_frames = np.hstack((mean_origin[:, np.newaxis, :],mean_rotation)).reshape(original_shape)\n\n        if is_step:\n            # Creating an array of zeros with shape (10000, 1, 6)\n            extra_column = np.zeros((params.shape[0], 1, 6))\n\n            # Concatenating the existing array and the extra column along the second axis\n            params = np.concatenate((extra_column,params), axis=1)\n\n        # Return the parameters and the mean reference frames\n        return  params, mean_reference_frames if not is_step else params\n\n\n    def analyse_frames(self):\n        \"\"\"Analyze the trajectory and compute parameters.\"\"\"\n\n        # Get base reference frames for each residue\n        frames_A = np.array([self.base_frames[res] for res in self.res_A])\n        frames_B = np.array([self.base_frames[res] for res in self.res_B])\n\n        # Compute parameters between each base pair and mean reference frames\n        self.bp_params, self.mean_reference_frames = self.calculate_parameters(frames_A, frames_B)\n\n        # Extract mean reference frames for each neighboring base pair\n        B1_triads = self.mean_reference_frames[:-1] # select all but the last frame\n        B2_triads = self.mean_reference_frames[1:] # select all but the first frame\n\n        # Compute parameters between each base pair and mean reference frames\n        self.step_params = self.calculate_parameters(B1_triads, B2_triads, is_step=True)[0]\n\n        # Store mean reference frame / aka base pair triads as frames and transpose rotation matrices back to row wise\n        self.frames = self.mean_reference_frames\n        self.frames[:, :, 1:, :] = np.transpose(self.frames[:, :, 1:, :], axes=(0, 1, 3, 2))\n        self._clean_parameters()\n\n    def _clean_parameters(self):\n        \"\"\"Clean the parameters by removing the first and last frame.\"\"\"\n        self.step_parameter_names = ['shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n        self.base_parameter_names = ['shear', 'stretch', 'stagger', 'buckle', 'propeller', 'opening']\n        self.names = self.base_parameter_names + self.step_parameter_names\n        self.parameters = np.dstack((self.bp_params, self.step_params))\n\n    def get_parameters(self,step=False,base=False):\n        \"\"\"Return the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n        if step and not base:\n            return self.step_params, self.step_parameter_names\n        elif base and not step:\n            return self.bp_params, self.base_parameter_names\n        elif not step and not base:\n            return self.parameters, self.names\n\n    def get_parameter(self,name='twist'):\n        \"\"\"Get the parameter of the DNA structure, choose frome the following:\n        - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n        Args:\n            name (str): parameter name\n\n        Returns:\n            parameter(ndarray) : parameter in shape (n_frames, n_base_pairs)\"\"\"\n\n        if name not in self.names:\n            raise ValueError(f\"Parameter {name} not found.\")\n        return self.parameters[:,:,self.names.index(name)]\n\n\n    def plot_parameters(self, fig=None, ax=None, mean=True, std=True,figsize=[10,3.5], save=False,step=True,base=True,base_color='cornflowerblue',step_color='coral'):\n        \"\"\"Plot the rigid base parameters of the DNA structure\n        Args:\n            fig: figure\n            ax: axis\n            mean: plot mean\n            std: plot standard deviation\n            figsize: figure size\n            save: save figure\n        Returns:\n            figure, axis\"\"\"\n\n        import matplotlib.pyplot as plt\n\n        cols = step + base\n\n        if fig is None and ax is None:\n            fig,ax = plt.subplots(cols,6, figsize=[12,2*cols])\n            ax = ax.flatten()\n        if step and not base:\n            names = self.step_parameter_names\n        elif base and not step:\n            names = self.base_parameter_names\n        elif base and step:\n            names = self.names\n\n        for _,name in enumerate(names):\n            if name in self.step_parameter_names:\n                color = step_color\n            else:\n                color = base_color\n            para = self.get_parameter(name)\n            mean = np.mean(para, axis=0)\n            std = np.std(para, axis=0)\n            x = range(len(mean))\n            #ax[_].errorbar(x,mean, yerr=std, fmt='-', color=color)\n            ax[_].fill_between(x, mean-std, mean+std, color=color, alpha=0.2)\n            ax[_].plot(mean, color=color,lw=1)    \n            ax[_].scatter(x=x,y=mean,color=color,s=10)\n            ax[_].set_title(name)\n\n        fig.tight_layout()\n        if save:\n            fig.savefig('parameters.png')\n        return fig, ax \n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.__init__","title":"<code>__init__(traj, chainids=[0, 1])</code>","text":"<p>Initialize the NucleicFrames object.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory object.</p> required <code>chainids</code> <code>list</code> <p>Chainids of sense- and anti-sense strands. Defaults to [0,1].</p> <code>[0, 1]</code> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def __init__(self, traj, chainids=[0,1]):\n    \"\"\"Initialize the NucleicFrames object.\n\n    Args:\n        traj (object): MDtraj trajectory object.\n        chainids (list, optional): Chainids of sense- and anti-sense strands. Defaults to [0,1].\n    \"\"\"\n    self.traj = traj\n    self.top = traj.topology\n    self.res_A = self.get_residues(chain_index=chainids[0], reverse=False)\n    self.res_B = self.get_residues(chain_index=chainids[1], reverse=True)\n    self.mean_reference_frames = np.empty((len(self.res_A), 1, 4, 3))\n    self.base_frames = self.get_base_reference_frames()\n    self.analyse_frames()\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.analyse_frames","title":"<code>analyse_frames()</code>","text":"<p>Analyze the trajectory and compute parameters.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def analyse_frames(self):\n    \"\"\"Analyze the trajectory and compute parameters.\"\"\"\n\n    # Get base reference frames for each residue\n    frames_A = np.array([self.base_frames[res] for res in self.res_A])\n    frames_B = np.array([self.base_frames[res] for res in self.res_B])\n\n    # Compute parameters between each base pair and mean reference frames\n    self.bp_params, self.mean_reference_frames = self.calculate_parameters(frames_A, frames_B)\n\n    # Extract mean reference frames for each neighboring base pair\n    B1_triads = self.mean_reference_frames[:-1] # select all but the last frame\n    B2_triads = self.mean_reference_frames[1:] # select all but the first frame\n\n    # Compute parameters between each base pair and mean reference frames\n    self.step_params = self.calculate_parameters(B1_triads, B2_triads, is_step=True)[0]\n\n    # Store mean reference frame / aka base pair triads as frames and transpose rotation matrices back to row wise\n    self.frames = self.mean_reference_frames\n    self.frames[:, :, 1:, :] = np.transpose(self.frames[:, :, 1:, :], axes=(0, 1, 3, 2))\n    self._clean_parameters()\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.calculate_parameters","title":"<code>calculate_parameters(frames_A, frames_B, is_step=False)</code>","text":"<p>Calculate the parameters between each base pair and mean reference frames.</p> <p>Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads. The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame. With the order of the vectors being: b_R, b_L, b_D, b_N.</p> <p>Parameters:</p> Name Type Description Default <code>frames_A</code> <code>ndarray</code> <p>Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain A.</p> required <code>frames_B</code> <code>ndarray</code> <p>Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain B.</p> required <code>is_step</code> <code>bool</code> <p>Flag indicating if the input is a single step or a trajectory. Defaults to False.</p> <code>False</code> Notes <p>Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.</p> <p>Returns:</p> Name Type Description <code>params</code> <code>ndarray</code> <p>The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.</p> <code>mean_reference_frames</code> <code>ndarray</code> <p>The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def calculate_parameters(self,frames_A, frames_B, is_step=False):\n    \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n    Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads.\n    The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame.\n    With the order of the vectors being: b_R, b_L, b_D, b_N.\n\n    Args:\n        frames_A (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain A.\n        frames_B (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain B.\n        is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n    Notes:\n        Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.\n\n    Returns:\n        params (ndarray): The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.\n        mean_reference_frames (ndarray): The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.\n    \"\"\"\n\n    # Reshape frames\n    rotation_A, rotation_B, origin_A, origin_B, original_shape = self.reshape_input(frames_A,frames_B, is_step=is_step)\n\n    # Compute parameters\n    if not is_step:\n        # Flip from row to column representation of the rotation matrices\n        rotation_A = rotation_A.transpose(0,2,1)\n        rotation_B = rotation_B.transpose(0,2,1)\n        params, mean_origin, mean_rotation = self.compute_parameters(rotation_A, rotation_B, origin_A, origin_B)\n    else:\n        # Switch the input of the B and A triads to get the correct parameters\n        params, mean_origin, mean_rotation = self.compute_parameters(rotation_B, rotation_A, origin_B, origin_A)\n\n    # Reshape the parameters to the original shape\n    params = params.reshape(original_shape[0], original_shape[1], 6).swapaxes(0, 1)\n\n    # Collect mean reference frames from mid frames of each base pair\n    mean_reference_frames = np.hstack((mean_origin[:, np.newaxis, :],mean_rotation)).reshape(original_shape)\n\n    if is_step:\n        # Creating an array of zeros with shape (10000, 1, 6)\n        extra_column = np.zeros((params.shape[0], 1, 6))\n\n        # Concatenating the existing array and the extra column along the second axis\n        params = np.concatenate((extra_column,params), axis=1)\n\n    # Return the parameters and the mean reference frames\n    return  params, mean_reference_frames if not is_step else params\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.compute_parameters","title":"<code>compute_parameters(rotation_A, rotation_B, origin_A, origin_B)</code>","text":"<p>Calculate the parameters between each base pair and mean reference frames.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_A</code> <code>ndarray</code> <p>Rotation matrices of shape (n, 3, 3) for the first triad.</p> required <code>rotation_B</code> <code>ndarray</code> <p>Rotation matrices of shape (n, 3, 3) for the second triad.</p> required <code>origin_A</code> <code>ndarray</code> <p>Origins of shape (n, 3) for the first triad.</p> required <code>origin_B</code> <code>ndarray</code> <p>Origins of shape (n, 3) for the second triad.</p> required <p>Returns:</p> Name Type Description <code>rigid_parameters</code> <code>ndarray</code> <p>The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.</p> <code>trans_mid</code> <code>ndarray</code> <p>The mean translational vector of shape (n, 3) between the triads.</p> <code>rotation_mid</code> <code>ndarray</code> <p>The mean rotation matrix of shape (n, 3, 3) between the triads.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def compute_parameters(self, rotation_A, rotation_B, origin_A, origin_B):\n    \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n    Args:\n        rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n        rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n        origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n        origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n\n    Returns:\n        rigid_parameters (ndarray): The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.\n        trans_mid (ndarray): The mean translational vector of shape (n, 3) between the triads.\n        rotation_mid (ndarray): The mean rotation matrix of shape (n, 3, 3) between the triads.\n    \"\"\"\n\n    # Linear interpolation of translations\n    trans_mid = 0.5 * (origin_A + origin_B)\n\n    # Relative translation\n    trans_AB = origin_A - origin_B\n\n    # Get relative rotation matrix of base pair\n    rotation_BA = rotation_B.transpose(0,2,1) @ rotation_A  # returns shape (n, 3, 3)\n\n    # Get rotation angles based on  rotation matrices\n    rotation_angle_BA = RigidBody.extract_omega_values(rotation_BA)\n\n    # Compute halfway rotation matrix and triad (mid frame)\n    rotation_halfway = RigidBody.get_rotation_matrix(rotation_angle_BA * 0.5)\n\n    # Get rotation matrix of base pair (aka mean rotation frame)\n    rotation_mid = rotation_B @ rotation_halfway \n\n    # Get transaltional coordinate vector and convert to angstroms\n    translational_parameters = np.einsum('ijk,ik-&gt;ij',rotation_mid.transpose(0,2,1), trans_AB) * 10\n\n    # Get rotational parameters and convert to degrees\n    rotational_parameters = np.rad2deg(np.einsum('ijk,ik-&gt;ij', rotation_BA.transpose(0,2,1), rotation_angle_BA))\n\n    # Merge translational and rotational parameters\n    rigid_parameters = np.hstack((translational_parameters, rotational_parameters))\n\n    # Return the parameters and the mean reference frame\n    return rigid_parameters, trans_mid, rotation_mid\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.get_base_reference_frames","title":"<code>get_base_reference_frames()</code>","text":"<p>Get reference frames for each residue.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def get_base_reference_frames(self):\n    \"\"\"Get reference frames for each residue.\"\"\"\n    reference_frames = {} # Dictionary to store the base vectors for each residue\n    for res in self.res_A + self.res_B:\n        res_traj = self.traj.atom_slice([at.index for at in res.atoms])\n        base_vectors = self.get_base_vectors(res_traj)\n        reference_frames[res] = base_vectors # Store the base vectors for the residue index (with shape (4, n_frames, 3))\n    return reference_frames\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.get_base_vectors","title":"<code>get_base_vectors(res)</code>","text":"<p>Compute base vectors from reference base.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def get_base_vectors(self, res):\n    \"\"\"Compute base vectors from reference base.\"\"\"\n    ref_base = ReferenceBase(res)\n    return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.get_parameter","title":"<code>get_parameter(name='twist')</code>","text":"<p>Get the parameter of the DNA structure, choose frome the following: - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>parameter name</p> <code>'twist'</code> <p>Returns:</p> Type Description <p>parameter(ndarray) : parameter in shape (n_frames, n_base_pairs)</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def get_parameter(self,name='twist'):\n    \"\"\"Get the parameter of the DNA structure, choose frome the following:\n    - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n    Args:\n        name (str): parameter name\n\n    Returns:\n        parameter(ndarray) : parameter in shape (n_frames, n_base_pairs)\"\"\"\n\n    if name not in self.names:\n        raise ValueError(f\"Parameter {name} not found.\")\n    return self.parameters[:,:,self.names.index(name)]\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.get_parameters","title":"<code>get_parameters(step=False, base=False)</code>","text":"<p>Return the computed parameters of shape (n_frames, n_base_pairs, n_parameters)</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def get_parameters(self,step=False,base=False):\n    \"\"\"Return the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n    if step and not base:\n        return self.step_params, self.step_parameter_names\n    elif base and not step:\n        return self.bp_params, self.base_parameter_names\n    elif not step and not base:\n        return self.parameters, self.names\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.get_residues","title":"<code>get_residues(chain_index, reverse=False)</code>","text":"<p>Get residues from specified chain.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def get_residues(self, chain_index, reverse=False):\n    \"\"\"Get residues from specified chain.\"\"\"\n    if chain_index &gt;= len(self.top._chains):\n        raise IndexError(\"Chain index out of range.\")\n    chain = self.top._chains[chain_index]\n    residues = chain._residues\n    return list(reversed(residues)) if reverse else residues\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.load_reference_bases","title":"<code>load_reference_bases()</code>","text":"<p>Load reference bases from local files.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def load_reference_bases(self):\n    \"\"\"Load reference bases from local files.\"\"\"\n    # Not used at the moment??\n    bases = ['C', 'G', 'T', 'A']\n    #return {f'D{base}': md.load_pdb(get_data_file_path(f'./atomic/NDB96_{base}.pdb')) for base in bases}\n    return {f'D{base}': md.load_hdf5(get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in bases}\n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.plot_parameters","title":"<code>plot_parameters(fig=None, ax=None, mean=True, std=True, figsize=[10, 3.5], save=False, step=True, base=True, base_color='cornflowerblue', step_color='coral')</code>","text":"<p>Plot the rigid base parameters of the DNA structure Args:     fig: figure     ax: axis     mean: plot mean     std: plot standard deviation     figsize: figure size     save: save figure Returns:     figure, axis</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def plot_parameters(self, fig=None, ax=None, mean=True, std=True,figsize=[10,3.5], save=False,step=True,base=True,base_color='cornflowerblue',step_color='coral'):\n    \"\"\"Plot the rigid base parameters of the DNA structure\n    Args:\n        fig: figure\n        ax: axis\n        mean: plot mean\n        std: plot standard deviation\n        figsize: figure size\n        save: save figure\n    Returns:\n        figure, axis\"\"\"\n\n    import matplotlib.pyplot as plt\n\n    cols = step + base\n\n    if fig is None and ax is None:\n        fig,ax = plt.subplots(cols,6, figsize=[12,2*cols])\n        ax = ax.flatten()\n    if step and not base:\n        names = self.step_parameter_names\n    elif base and not step:\n        names = self.base_parameter_names\n    elif base and step:\n        names = self.names\n\n    for _,name in enumerate(names):\n        if name in self.step_parameter_names:\n            color = step_color\n        else:\n            color = base_color\n        para = self.get_parameter(name)\n        mean = np.mean(para, axis=0)\n        std = np.std(para, axis=0)\n        x = range(len(mean))\n        #ax[_].errorbar(x,mean, yerr=std, fmt='-', color=color)\n        ax[_].fill_between(x, mean-std, mean+std, color=color, alpha=0.2)\n        ax[_].plot(mean, color=color,lw=1)    \n        ax[_].scatter(x=x,y=mean,color=color,s=10)\n        ax[_].set_title(name)\n\n    fig.tight_layout()\n    if save:\n        fig.savefig('parameters.png')\n    return fig, ax \n</code></pre>"},{"location":"api/geometry-reference/#pymdna.geometry.NucleicFrames.reshape_input","title":"<code>reshape_input(input_A, input_B, is_step=False)</code>","text":"<p>Reshape the input to the correct format for the calculations.</p> <p>Args: input_A (ndarray): Input array for the first triad. input_B (ndarray): Input array for the second triad. is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.</p> <p>Returns: rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad. rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad. origin_A (ndarray): Origins of shape (n, 3) for the first triad. origin_B (ndarray): Origins of shape (n, 3) for the second triad. original_shape (tuple): The original shape of the input.</p> Source code in <code>src/pymdna/geometry.py</code> <pre><code>def reshape_input(self,input_A,input_B,is_step=False):\n\n    \"\"\"Reshape the input to the correct format for the calculations.\n\n    Args:\n    input_A (ndarray): Input array for the first triad.\n    input_B (ndarray): Input array for the second triad.\n    is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n    Returns:\n    rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n    rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n    origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n    origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n    original_shape (tuple): The original shape of the input.\n    \"\"\"\n\n    # Store original shape\n    original_shape = input_A.shape\n\n    # Flatten frames to compute rotation matrices for each time step simultaneously\n    input_A_ = input_A.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n    input_B_ = input_B.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n\n    # Extract the triads without origin (rotation matrices)\n    rotation_A = input_A_[:,1:]  # shape (n, 3, 3)\n    rotation_B = input_B_[:,1:]  # shape (n, 3, 3)\n\n    if not is_step:\n        # flip (connecting the backbones) and the (baseplane normals).\n        # so the second and third vector b_L, b_N\n        rotation_B[:,[1,2]] *= -1\n\n    # Extract origins of triads\n    origin_A = input_A_[:,0]  # shape (n, 3)\n    origin_B = input_B_[:,0]  # shape (n, 3)\n\n    return rotation_A, rotation_B, origin_A, origin_B, original_shape\n</code></pre>"},{"location":"api/nucleic-reference/","title":"Nucleic","text":""},{"location":"api/nucleic-reference/#nucleic-class","title":"Nucleic class","text":"<p>The <code>pymdna.nucleic</code> module is the core of the MDNA toolkit, encompassing a variety of classes and functions essential for DNA structure generation, manipulation, and analysis. Below, each key component of the module is outlined with explanations of its purpose and usage. The <code>Nucleic</code> class serves as the primary interface for interacting with DNA structures in the MDNA toolkit. It encapsulates both the structural properties of DNA and the trajectory information needed for molecular dynamics simulations. Key methods include:</p>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic","title":"<code>pymdna.nucleic.Nucleic</code>","text":"<p>Contains mdna DNA structure with reference frames and trajectory</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>class Nucleic:\n\n    \"\"\"Contains mdna DNA structure with reference frames and trajectory\"\"\"\n\n    def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=[0,1], circular=None):\n            \"\"\"Initializes the DNA structure.\n\n            Args:\n                sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n                n_bp (int): The number of base pairs. Default is None.\n                traj (object): The MDTraj trajectory. Default is None.\n                frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n                chainids (list): The chain IDs. Default is [0,1].\n                circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n            Raises:\n                ValueError: If both traj and frames are provided.\n                ValueError: If frames have an invalid shape.\n                ValueError: If the number of base pairs in the sequence and frames do not match.\n                ValueError: If neither traj nor frames are provided.\n\n            Notes:\n                - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n                - If frames is provided, n_bp will be determined from the shape of frames.\n                - If sequence is provided, it will be checked against the number of base pairs.\n\n            Attributes:\n                sequence (str): The DNA sequence.\n                n_bp (int): The number of base pairs.\n                traj (object): The MDTraj trajectory.\n                frames (np.ndarray): The reference frames of the DNA structure.\n                chainids (list): The chain IDs.\n                circular (bool): A flag that indicates if the structure is circular/closed.\n                rigid (None): A container for rigid base parameters class output.\n                minimizer (None): A container for minimizer class output.\n            \"\"\"\n            # Check for trajectory\n            if traj is not None:\n                if frames is not None:\n                    raise ValueError('Provide either a trajectory or reference frames, not both')\n                # Extract sequence from the trajectory\n                sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n                n_bp = len(sequence)\n                sequence = ''.join(sequence)\n                frames = None  # Nucleic class will handle extraction from traj\n\n            # Check for reference frames\n            elif frames is not None:\n                if frames.ndim == 3:\n                    # Case (n_bp, 4, 3)\n                    frames = np.expand_dims(frames, axis=1)\n                if frames.ndim != 4:\n                    raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n                n_bp = frames.shape[0]\n                if sequence is not None:\n                    if len(sequence) != n_bp:\n                        raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                    else:\n                        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n            else:\n                raise ValueError('Provide either a trajectory or reference frames')\n\n            self.sequence, self.n_bp = sequence, n_bp\n            self.traj = traj\n            self.frames = frames\n            self.chainids = chainids\n            self.circular = self._is_circular() if circular is None else circular \n            self.rigid = None # Container for rigid base parameters class output\n            self.minimizer = None # Container for minimizer class output\n            self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n\n    def describe(self):\n        \"\"\"Print the DNA structure information\"\"\"\n        print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n        print('Sequence:', ''.join(self.sequence))\n\n        if self.traj is not None:\n            print('Trajectory:',self.traj)\n        else:\n            print('Trajectory not loaded')\n\n        if self.frames is not None:\n            print('Frames: ', self.frames.shape)\n        else:\n            print('Frames not loaded')\n\n    def _frames_to_traj(self, frame=-1):\n        \"\"\"Convert reference frames to trajectory\"\"\"\n        if self.frames is None:\n            raise ValueError('Load reference frames first')\n        self.traj = None\n        generator = StructureGenerator(frames=self.frames[:,frame,:,:], sequence=self.sequence, circular=self.circular)\n        self.traj = generator.get_traj()\n\n    def _traj_to_frames(self):\n        \"\"\"Convert trajectory to reference frames\"\"\"\n        if self.traj is None:\n            raise ValueError('Load trajectory first')\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        self.frames =self.rigid.frames\n\n    def get_frames(self):\n        \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n        Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n        where n_frames is the number of frames, n_bp is the number of base pairs, \n        and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n        Returns:\n            frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n        if self.frames is None:\n            self._traj_to_frames()\n        return self.frames\n\n    def get_traj(self):\n        \"\"\"Get the trajectory of the current state of the DNA structure\n        Returns:\n            MDtraj object\"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n\n        if self.traj.n_atoms &gt; 99999:\n            print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n        return self.traj\n\n    def get_rigid_object(self):\n        \"\"\"Get the rigid base class object of the DNA structure\n\n        Returns:\n            NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n        if self.rigid is None and self.traj is not None:\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        elif self.rigid is None and self.traj is None:\n            self._frames_to_traj()\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        else:\n            return self.rigid\n\n    def get_parameters(self, step : bool = False, base : bool = False):\n        \"\"\"By default retuns all the parameters of the DNA structure.\n        Use arguments to get a specific parameter group of the DNA structure.\n\n        Args:\n            step (bool, optional): Returns only the step parameters of consequative bases. Defaults to False.\n            base (bool, optional): Returns onlt the base pair parameters of opposing bases. Defaults to False.\n\n        Returns:\n            (parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameters(step=step, base=base)\n\n    def get_parameter(self, parameter_name : str):\n        \"\"\"Get a specific parameter from the rigid base parameters class object of the DNA structure\n\n        Args:\n            parameter_name (str): The name of the parameter to retrieve.\n\n        Notes:\n            The following parameters can be retrieved:\n            - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n        Returns:\n            np.ndarray: The parameter values of the DNA structure.\"\"\"\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameter(parameter_name)\n\n    def get_base_frames(self):\n        \"\"\"Get the base reference frames of the DNA structure\n\n        Returns:\n            dict: A dictionary containing the base reference frames of the DNA structure. \n              The keys are residue topologies of the MDTraj object (traj.top.residues) and the values are the reference frames in shape (n_frames, 4, 3), \n              where the rows represent the origin, b_D, b_L, and b_N vectors.\"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_base_reference_frames()\n\n\n    def _is_circular(self, frame=0):\n        \"\"\"Detects if the DNA structure is circular for a given chain and frame.\n\n        Args:\n            frame (int, optional): Frame index to check. Default is 0.\n\n        Returns:\n            bool: True if the DNA is circular, False otherwise.\n        \"\"\"\n        if self.frames is None:\n            self._traj_to_frames()\n\n        start = self.frames[0, frame, 0]\n        end = self.frames[-1, frame, 0]\n        distance = np.linalg.norm(start - end)\n\n        # 0.34 nm is roughly the distance between base pairs and 20 is the minimum number of base pairs for circular DNA\n        return distance &lt; 1 and self.frames.shape[0] &gt; 20\n\n    def _plot_chain(self, ax, traj, chainid, frame, lw=1, markersize=2, color='k'):\n        \"\"\"Plot the DNA structure of a chain\"\"\"\n        phosphor = traj.top.select(f'name P and chainid {chainid}')\n        x = traj.xyz[frame, phosphor, 0]\n        y = traj.xyz[frame, phosphor, 1]\n        z = traj.xyz[frame, phosphor, 2]\n\n        ax.plot(x, y, z, '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n        if self.circular:\n            # Connect the last point to the first point\n            ax.plot([x[-1], x[0]], [y[-1], y[0]], [z[-1], z[0]], '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n    def _plot_helical_axis(self, ax, frame, lw=1, color='k'):\n        helical_axis = self.frames[:,frame,0]\n        ax.plot(helical_axis[:,0],helical_axis[:,1],helical_axis[:,2],':',c=color,lw=lw*0.7)\n        if self.circular:\n            ax.plot([helical_axis[-1,0],helical_axis[0,0]],[helical_axis[-1,1],helical_axis[0,1]],[helical_axis[-1,2],helical_axis[0,2]],':',c='k',lw=lw*0.7)\n\n    def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey',color_axis='k'):\n        \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n        Args:\n            ax (object, optional): Matplotlib axis. Default is None.\n            fig (object, optional): Figure axis. Default is None.\n            save (bool, optional): Save image as png. Default is False.\n            frame (int, optional): Index of trajectory to visualize. Default is -1.\n            markersize (int, optional): Width of backbone plot. Default is 2.\n            lw (int, optional): Line width of plots. Default is 1.\n            helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n            backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n            lead (bool, optional): Plot leading strand. Default is False.\n            anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n            triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n            length (float, optional): Length of triad vectors. Default is 0.23.\n            color_lead (str, optional): Color of the leading strand. Default is 'k'.\n            color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n            color_axis (str, optional): Color of the helical axis. Default is 'k'.\n\n        Notes:\n            - The function draws a 3D representation of the DNA structure using matplotlib.\n            - The function requires either the trajectory or reference frames to be loaded before calling.\n\n        Example:\n            Make a DNA structure and draw the 3D representation\n            ```python\n            dna = nuc.make(sequence='CGCGAATTCGCG')\n            dna.draw()\n            ```\n        \"\"\"\n\n        # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n        # in shape (time/n_frames, n_bp, 4, 3)\n\n        if self.traj is None:\n            self._frames_to_traj()\n        elif self.frames is None:\n            self._traj_to_frames()\n\n        if fig is None and ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n\n        if backbone:\n            lead = True\n            anti = True\n        if lead:\n            self._plot_chain(ax, self.traj, self.chainids[0], frame=frame, markersize=markersize, lw=lw, color=color_lead)\n        if anti:\n            self._plot_chain(ax, self.traj, self.chainids[1], frame=frame, markersize=markersize, lw=lw, color=color_anti)\n        if helical_axis:\n            self._plot_helical_axis(ax, frame=frame, lw=lw, color=color_axis)\n        if triads:\n            for triad in self.frames:\n                triad = triad[frame]\n                ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n        ax.axis('equal')\n        ax.axis('off')\n        if save:\n            fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n\n    def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 5, plot : bool = False):\n        \"\"\"\n        Minimize the DNA structure. This method updates the  of the DNA structure.\n\n        Args:\n            frame (int): The trajectory frame to minimize. Defaults to -1.\n            simple (bool): Whether to use simple equilibration. Defaults to False.\n            equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n            endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n            fixed (list): List of fixed base pairs. Defaults to an empty list.\n            exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n            temperature (int): Temperature for equilibration. Defaults to 300.\n            dump_every (int): Frequency of dumping frames. Defaults to 5.\n            plot (bool): Whether to plot the energy. Defaults to False.\n\n        Additional keyword arguments can be provided and will be passed to the minimizer.\n\n        Notes:\n\n            For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n            This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n            The other option is to use the full equilibration, which is based on the actual energy of the system.\n            We assume the energy to converge exponentially to the equilibrated value.\n            This works fairly well for most examples I checked but is not entirely robust. \n            Considering autocorrelation has some issues when there are relaxations at different timescales.\n            Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n            It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n        Example:\n            Load a DNA structure and minimize it\n            ```python\n            nuc = mdna.load(traj)\n            nuc.minimize(temperature=310, exvol_rad=2.0)\n            ```\n        \"\"\"\n        self.minimizer = Minimizer(self)\n        self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n        # Update the reference frames\n        self._frames_to_traj()\n\n    def get_MC_traj(self):\n        \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n        if self.minimizer is None:\n            raise ValueError('Run minimization first')\n        return self.minimizer.get_MC_traj()\n\n    def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n        \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n        The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n        Args:\n            mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n            complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n            frame (int, optional): The frame to mutate. Defaults to -1.\n            verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n        Raises:\n            ValueError: If no mutation dictionary is provided.\n\n        Notes:\n            - Valid nucleobases for mutations include:\n                - Canonical bases: A, T, G, C, U\n                - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n                - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n                - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n        Example:\n            Create a DNA object \n            ```python\n            dna = DNA()\n            mutations = {0: 'A', 1: 'T', 2: 'G'}\n            dna.mutate(mutations=mutations, complementary=True, frame=-1)\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if mutations is None:\n            raise ValueError('Provide a mutation dictionary')\n\n        # TODO: Check if valid letters in mutations dictionary\n\n        mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n        self.traj = mutant.get_traj()\n        # Update sequence\n        self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n\n\n    def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n            \"\"\"Flips the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n                deg (int): The degrees to flip. Defaults to 180.\n                frame (int): The frame to flip. Defaults to -1.\n\n            Raises:\n                ValueError: If no fliplist is provided.\n\n            Notes:\n                - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n\n            Example:\n                Flip DNA\n                ```python\n                dna = mdna.make('GCAAAGC)\n                dna.flip(fliplist=[3,4], deg=180)\n                ```\n\n            \"\"\"\n\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(fliplist) == 0:\n                raise ValueError('Provide a fliplist')\n\n            flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n            self.traj = flipper.get_traj()\n\n    def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n            \"\"\"Methylate the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                methylations (list): List of base pairs to methylate. Defaults to [].\n                CpG (bool): Whether to methylate CpG sites. Defaults to False.\n                leading_strand (int): The leading strand to methylate. Defaults to 0.\n                frame (int): The frame to methylate. Defaults to -1.\n\n            Raises:\n                ValueError: If the DNA structure is not loaded.\n                ValueError: If the methylations list is empty.\n\n            Notes:\n                Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n\n            Example:\n                Methylate DNA\n                ```python\n                dna = mdna.make('GCGCGCGAGCGA)\n                dna.metyhlate(fliplist=[3,4])\n                ```\n            \"\"\"\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(methylations) == 0 and not CpG:\n                raise ValueError('Provide a non-empty methylations list')\n\n            methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n            self.traj = methylator.get_traj()\n\n    def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n        \"\"\"Extend the DNA structure in the specified direction.\n            The method updates the attributes of the DNA object.\n\n\n        Args:\n            n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n            sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n            fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n            forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n            frame (int, optional): The time frame to extend. Defaults to -1.\n            shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n            margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n            minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n            plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n            exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n            temperature (int, optional): Temperature for equilibration. Defaults\n\n        Raises:\n            ValueError: If the DNA structure is circular and cannot be extended.\n            ValueError: If neither a fixed endpoint nor a length is specified for extension.\n            ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n        Notes:\n            - If the DNA structure is circular, it cannot be extended.\n\n        Example:\n            Extend DNA structure\n            ```python\n            nuc = mdna.make(n_bp=100)\n            nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n            ```\n        \"\"\"\n        if self.circular:\n            raise ValueError('Cannot extend circular DNA structure')  \n        if self.traj is None:\n            self._frames_to_traj()\n        if shape is None:\n            shape = Shapes.line(length=1)\n        if self.frames is None:\n            self._traj_to_frames()\n\n        # Check the input sequence and number of base pairs\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n        extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n        # Also update, n_bp, sequence, frames etc\n        self.nuc = extender.nuc\n\n        if minimize:\n            self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n        # Update attributes\n        self.sequence = self.nuc.sequence\n        self.traj = self.nuc.get_traj()\n        self.frames = self.nuc.get_frames()\n        self.n_bp = self.nuc.n_bp\n\n    def invert(self):\n        \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n         The method updates attributes of the DNA object.\n\n         Raises:\n            NotImplementedError.\"\"\"\n        raise NotImplementedError('Not implemented yet')\n\n    def get_linking_number(self, frame : int = -1):\n        \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n        Args:\n            frame (int, optional): Time frame of trajectory, by default -1\n\n        Returns:\n            linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n        \"\"\"\n        try:\n            from pmcpy import pmcpy\n        except ImportError:\n            pmcpy_available = False\n            print(\"pmcpy is not installed. You shall not pass.\")\n\n        if self.frames is None:\n                self._traj_to_frames()\n        frames = self.frames[:,frame,:,:]\n        positions = frames[:,0]\n        triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n        writhe = pylk.writhe(positions)\n        lk = pylk.triads2link(positions, triads)\n        return np.array([lk, writhe, lk - writhe])\n\n    def save_pdb(self, filename : str = None, frame : int = -1):\n        \"\"\"Save the DNA structure as a pdb file.\n\n        Args:\n            filename (str, optional): Filename to save the pdb file. Defaults to None.\n            frame (int, optional): If the trajectory has multiple frames, specify the frame to save. Defaults to -1.\n        \"\"\"\n\n        # check if traj\n        if self.traj is None:\n            self._frames_to_traj()\n        if filename is None:\n            filename = 'my_mdna'\n        self.traj[frame].save(f'{filename}.pdb')\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.__init__","title":"<code>__init__(sequence=None, n_bp=None, traj=None, frames=None, chainids=[0, 1], circular=None)</code>","text":"<p>Initializes the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence, e.g. 'CGCGAATTCGCG'.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>The number of base pairs. Default is None.</p> <code>None</code> <code>traj</code> <code>object</code> <p>The MDTraj trajectory. Default is None.</p> <code>None</code> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure. Default is None.</p> <code>None</code> <code>chainids</code> <code>list</code> <p>The chain IDs. Default is [0,1].</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both traj and frames are provided.</p> <code>ValueError</code> <p>If frames have an invalid shape.</p> <code>ValueError</code> <p>If the number of base pairs in the sequence and frames do not match.</p> <code>ValueError</code> <p>If neither traj nor frames are provided.</p> Notes <ul> <li>If traj is provided, sequence and n_bp will be extracted from the trajectory.</li> <li>If frames is provided, n_bp will be determined from the shape of frames.</li> <li>If sequence is provided, it will be checked against the number of base pairs.</li> </ul> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>str</code> <p>The DNA sequence.</p> <code>n_bp</code> <code>int</code> <p>The number of base pairs.</p> <code>traj</code> <code>object</code> <p>The MDTraj trajectory.</p> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure.</p> <code>chainids</code> <code>list</code> <p>The chain IDs.</p> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed.</p> <code>rigid</code> <code>None</code> <p>A container for rigid base parameters class output.</p> <code>minimizer</code> <code>None</code> <p>A container for minimizer class output.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=[0,1], circular=None):\n        \"\"\"Initializes the DNA structure.\n\n        Args:\n            sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n            n_bp (int): The number of base pairs. Default is None.\n            traj (object): The MDTraj trajectory. Default is None.\n            frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n            chainids (list): The chain IDs. Default is [0,1].\n            circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n        Raises:\n            ValueError: If both traj and frames are provided.\n            ValueError: If frames have an invalid shape.\n            ValueError: If the number of base pairs in the sequence and frames do not match.\n            ValueError: If neither traj nor frames are provided.\n\n        Notes:\n            - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n            - If frames is provided, n_bp will be determined from the shape of frames.\n            - If sequence is provided, it will be checked against the number of base pairs.\n\n        Attributes:\n            sequence (str): The DNA sequence.\n            n_bp (int): The number of base pairs.\n            traj (object): The MDTraj trajectory.\n            frames (np.ndarray): The reference frames of the DNA structure.\n            chainids (list): The chain IDs.\n            circular (bool): A flag that indicates if the structure is circular/closed.\n            rigid (None): A container for rigid base parameters class output.\n            minimizer (None): A container for minimizer class output.\n        \"\"\"\n        # Check for trajectory\n        if traj is not None:\n            if frames is not None:\n                raise ValueError('Provide either a trajectory or reference frames, not both')\n            # Extract sequence from the trajectory\n            sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n            n_bp = len(sequence)\n            sequence = ''.join(sequence)\n            frames = None  # Nucleic class will handle extraction from traj\n\n        # Check for reference frames\n        elif frames is not None:\n            if frames.ndim == 3:\n                # Case (n_bp, 4, 3)\n                frames = np.expand_dims(frames, axis=1)\n            if frames.ndim != 4:\n                raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n            n_bp = frames.shape[0]\n            if sequence is not None:\n                if len(sequence) != n_bp:\n                    raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                else:\n                    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n        else:\n            raise ValueError('Provide either a trajectory or reference frames')\n\n        self.sequence, self.n_bp = sequence, n_bp\n        self.traj = traj\n        self.frames = frames\n        self.chainids = chainids\n        self.circular = self._is_circular() if circular is None else circular \n        self.rigid = None # Container for rigid base parameters class output\n        self.minimizer = None # Container for minimizer class output\n        self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.describe","title":"<code>describe()</code>","text":"<p>Print the DNA structure information</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def describe(self):\n    \"\"\"Print the DNA structure information\"\"\"\n    print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n    print('Sequence:', ''.join(self.sequence))\n\n    if self.traj is not None:\n        print('Trajectory:',self.traj)\n    else:\n        print('Trajectory not loaded')\n\n    if self.frames is not None:\n        print('Frames: ', self.frames.shape)\n    else:\n        print('Frames not loaded')\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.draw","title":"<code>draw(ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23, color_lead='k', color_anti='darkgrey', color_axis='k')</code>","text":"<p>Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>object</code> <p>Matplotlib axis. Default is None.</p> <code>None</code> <code>fig</code> <code>object</code> <p>Figure axis. Default is None.</p> <code>None</code> <code>save</code> <code>bool</code> <p>Save image as png. Default is False.</p> <code>False</code> <code>frame</code> <code>int</code> <p>Index of trajectory to visualize. Default is -1.</p> <code>-1</code> <code>markersize</code> <code>int</code> <p>Width of backbone plot. Default is 2.</p> <code>2</code> <code>lw</code> <code>int</code> <p>Line width of plots. Default is 1.</p> <code>1</code> <code>helical_axis</code> <code>bool</code> <p>Plot central axis passing through frame origins. Default is True.</p> <code>True</code> <code>backbone</code> <code>bool</code> <p>Plot backbone as 'o-' line plot through phosphor atoms. Default is True.</p> <code>True</code> <code>lead</code> <code>bool</code> <p>Plot leading strand. Default is False.</p> <code>False</code> <code>anti</code> <code>bool</code> <p>Plot anti-sense opposing leading strand. Default is False.</p> <code>False</code> <code>triads</code> <code>bool</code> <p>Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.</p> <code>False</code> <code>length</code> <code>float</code> <p>Length of triad vectors. Default is 0.23.</p> <code>0.23</code> <code>color_lead</code> <code>str</code> <p>Color of the leading strand. Default is 'k'.</p> <code>'k'</code> <code>color_anti</code> <code>str</code> <p>Color of the anti strand. Default is 'darkgrey'.</p> <code>'darkgrey'</code> <code>color_axis</code> <code>str</code> <p>Color of the helical axis. Default is 'k'.</p> <code>'k'</code> Notes <ul> <li>The function draws a 3D representation of the DNA structure using matplotlib.</li> <li>The function requires either the trajectory or reference frames to be loaded before calling.</li> </ul> Example <p>Make a DNA structure and draw the 3D representation <pre><code>dna = nuc.make(sequence='CGCGAATTCGCG')\ndna.draw()\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey',color_axis='k'):\n    \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n    Args:\n        ax (object, optional): Matplotlib axis. Default is None.\n        fig (object, optional): Figure axis. Default is None.\n        save (bool, optional): Save image as png. Default is False.\n        frame (int, optional): Index of trajectory to visualize. Default is -1.\n        markersize (int, optional): Width of backbone plot. Default is 2.\n        lw (int, optional): Line width of plots. Default is 1.\n        helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n        backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n        lead (bool, optional): Plot leading strand. Default is False.\n        anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n        triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n        length (float, optional): Length of triad vectors. Default is 0.23.\n        color_lead (str, optional): Color of the leading strand. Default is 'k'.\n        color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n        color_axis (str, optional): Color of the helical axis. Default is 'k'.\n\n    Notes:\n        - The function draws a 3D representation of the DNA structure using matplotlib.\n        - The function requires either the trajectory or reference frames to be loaded before calling.\n\n    Example:\n        Make a DNA structure and draw the 3D representation\n        ```python\n        dna = nuc.make(sequence='CGCGAATTCGCG')\n        dna.draw()\n        ```\n    \"\"\"\n\n    # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n    # in shape (time/n_frames, n_bp, 4, 3)\n\n    if self.traj is None:\n        self._frames_to_traj()\n    elif self.frames is None:\n        self._traj_to_frames()\n\n    if fig is None and ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n\n    if backbone:\n        lead = True\n        anti = True\n    if lead:\n        self._plot_chain(ax, self.traj, self.chainids[0], frame=frame, markersize=markersize, lw=lw, color=color_lead)\n    if anti:\n        self._plot_chain(ax, self.traj, self.chainids[1], frame=frame, markersize=markersize, lw=lw, color=color_anti)\n    if helical_axis:\n        self._plot_helical_axis(ax, frame=frame, lw=lw, color=color_axis)\n    if triads:\n        for triad in self.frames:\n            triad = triad[frame]\n            ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n    ax.axis('equal')\n    ax.axis('off')\n    if save:\n        fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.extend","title":"<code>extend(n_bp=None, sequence=None, fixed_endpoints=False, forward=True, frame=-1, shape=None, margin=1, minimize=True, plot=False, exvol_rad=2.0, temperature=300)</code>","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure. Defaults to None.</p> <code>None</code> <code>sequence</code> <code>str or List</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <code>plot</code> <code>bool</code> <p>Whether to plot the Energy during minmization. Defaults to False.</p> <code>False</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults</p> <code>300</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> </ul> Example <p>Extend DNA structure <pre><code>nuc = mdna.make(n_bp=100)\nnuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n        sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n        plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n        exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n        temperature (int, optional): Temperature for equilibration. Defaults\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n\n    Example:\n        Extend DNA structure\n        ```python\n        nuc = mdna.make(n_bp=100)\n        nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n        ```\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')  \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.flip","title":"<code>flip(fliplist=[], deg=180, frame=-1)</code>","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <ul> <li>Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.</li> </ul> Example <p>Flip DNA <pre><code>dna = mdna.make('GCAAAGC)\ndna.flip(fliplist=[3,4], deg=180)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n\n        Example:\n            Flip DNA\n            ```python\n            dna = mdna.make('GCAAAGC)\n            dna.flip(fliplist=[3,4], deg=180)\n            ```\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_MC_traj","title":"<code>get_MC_traj()</code>","text":"<p>Get the MC sampling energy minimization trajectory of the new spline.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_MC_traj(self):\n    \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n    if self.minimizer is None:\n        raise ValueError('Run minimization first')\n    return self.minimizer.get_MC_traj()\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_base_frames","title":"<code>get_base_frames()</code>","text":"<p>Get the base reference frames of the DNA structure</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the base reference frames of the DNA structure.  The keys are residue topologies of the MDTraj object (traj.top.residues) and the values are the reference frames in shape (n_frames, 4, 3),  where the rows represent the origin, b_D, b_L, and b_N vectors.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_base_frames(self):\n    \"\"\"Get the base reference frames of the DNA structure\n\n    Returns:\n        dict: A dictionary containing the base reference frames of the DNA structure. \n          The keys are residue topologies of the MDTraj object (traj.top.residues) and the values are the reference frames in shape (n_frames, 4, 3), \n          where the rows represent the origin, b_D, b_L, and b_N vectors.\"\"\"\n\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_base_reference_frames()\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_frames","title":"<code>get_frames()</code>","text":"<p>Get the reference frames of the DNA structure belonging to the base steps: Returns: array of reference frames of shape (n_frames, n_bp, 4, 3) where n_frames is the number of frames, n_bp is the number of base pairs,  and 4 corresponds to the origin and the 3 vectors of the reference frame</p> <p>Returns:</p> Name Type Description <code>frames</code> <code>ndarray</code> <p>reference frames of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_frames(self):\n    \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n    Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n    where n_frames is the number of frames, n_bp is the number of base pairs, \n    and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n    Returns:\n        frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n    if self.frames is None:\n        self._traj_to_frames()\n    return self.frames\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_linking_number","title":"<code>get_linking_number(frame=-1)</code>","text":"<p>Get the linking number of the DNA structure based on Gauss's linking number theorem.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>Time frame of trajectory, by default -1</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>linking_number</code> <code>ndarray</code> <p>Numpy array containing the linking number, writhe, and twist corresponding to the time frame</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_linking_number(self, frame : int = -1):\n    \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n    Args:\n        frame (int, optional): Time frame of trajectory, by default -1\n\n    Returns:\n        linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n    \"\"\"\n    try:\n        from pmcpy import pmcpy\n    except ImportError:\n        pmcpy_available = False\n        print(\"pmcpy is not installed. You shall not pass.\")\n\n    if self.frames is None:\n            self._traj_to_frames()\n    frames = self.frames[:,frame,:,:]\n    positions = frames[:,0]\n    triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n    writhe = pylk.writhe(positions)\n    lk = pylk.triads2link(positions, triads)\n    return np.array([lk, writhe, lk - writhe])\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_parameter","title":"<code>get_parameter(parameter_name)</code>","text":"<p>Get a specific parameter from the rigid base parameters class object of the DNA structure</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>The name of the parameter to retrieve.</p> required Notes <p>The following parameters can be retrieved: - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening</p> <p>Returns:</p> Type Description <p>np.ndarray: The parameter values of the DNA structure.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_parameter(self, parameter_name : str):\n    \"\"\"Get a specific parameter from the rigid base parameters class object of the DNA structure\n\n    Args:\n        parameter_name (str): The name of the parameter to retrieve.\n\n    Notes:\n        The following parameters can be retrieved:\n        - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n    Returns:\n        np.ndarray: The parameter values of the DNA structure.\"\"\"\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_parameter(parameter_name)\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_parameters","title":"<code>get_parameters(step=False, base=False)</code>","text":"<p>By default retuns all the parameters of the DNA structure. Use arguments to get a specific parameter group of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>bool</code> <p>Returns only the step parameters of consequative bases. Defaults to False.</p> <code>False</code> <code>base</code> <code>bool</code> <p>Returns onlt the base pair parameters of opposing bases. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>(parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_parameters(self, step : bool = False, base : bool = False):\n    \"\"\"By default retuns all the parameters of the DNA structure.\n    Use arguments to get a specific parameter group of the DNA structure.\n\n    Args:\n        step (bool, optional): Returns only the step parameters of consequative bases. Defaults to False.\n        base (bool, optional): Returns onlt the base pair parameters of opposing bases. Defaults to False.\n\n    Returns:\n        (parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_parameters(step=step, base=base)\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_rigid_object","title":"<code>get_rigid_object()</code>","text":"<p>Get the rigid base class object of the DNA structure</p> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_rigid_object(self):\n    \"\"\"Get the rigid base class object of the DNA structure\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n    if self.rigid is None and self.traj is not None:\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    elif self.rigid is None and self.traj is None:\n        self._frames_to_traj()\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    else:\n        return self.rigid\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.get_traj","title":"<code>get_traj()</code>","text":"<p>Get the trajectory of the current state of the DNA structure Returns:     MDtraj object</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_traj(self):\n    \"\"\"Get the trajectory of the current state of the DNA structure\n    Returns:\n        MDtraj object\"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n\n    if self.traj.n_atoms &gt; 99999:\n        print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n    return self.traj\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.invert","title":"<code>invert()</code>","text":"<p>Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5 The method updates attributes of the DNA object.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def invert(self):\n    \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n     The method updates attributes of the DNA object.\n\n     Raises:\n        NotImplementedError.\"\"\"\n    raise NotImplementedError('Not implemented yet')\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.methylate","title":"<code>methylate(methylations=[], CpG=False, leading_strand=0, frame=-1)</code>","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <p>Using the <code>CpG</code> flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.</p> Example <p>Methylate DNA <pre><code>dna = mdna.make('GCGCGCGAGCGA)\ndna.metyhlate(fliplist=[3,4])\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n\n        Example:\n            Methylate DNA\n            ```python\n            dna = mdna.make('GCGCGCGAGCGA)\n            dna.metyhlate(fliplist=[3,4])\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(methylations) == 0 and not CpG:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.minimize","title":"<code>minimize(frame=-1, exvol_rad=2.0, temperature=300, simple=False, equilibrate_writhe=False, endpoints_fixed=False, fixed=[], dump_every=5, plot=False)</code>","text":"<p>Minimize the DNA structure. This method updates the  of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The trajectory frame to minimize. Defaults to -1.</p> <code>-1</code> <code>simple</code> <code>bool</code> <p>Whether to use simple equilibration. Defaults to False.</p> <code>False</code> <code>equilibrate_writhe</code> <code>bool</code> <p>Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.</p> <code>False</code> <code>endpoints_fixed</code> <code>bool</code> <p>Whether the endpoints are fixed. Defaults to False.</p> <code>False</code> <code>fixed</code> <code>list</code> <p>List of fixed base pairs. Defaults to an empty list.</p> <code>[]</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults to 300.</p> <code>300</code> <code>dump_every</code> <code>int</code> <p>Frequency of dumping frames. Defaults to 5.</p> <code>5</code> <code>plot</code> <code>bool</code> <p>Whether to plot the energy. Defaults to False.</p> <code>False</code> <p>Additional keyword arguments can be provided and will be passed to the minimizer.</p> <p>Notes:</p> <pre><code>For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \nThis options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration.\n\nThe other option is to use the full equilibration, which is based on the actual energy of the system.\nWe assume the energy to converge exponentially to the equilibrated value.\nThis works fairly well for most examples I checked but is not entirely robust. \nConsidering autocorrelation has some issues when there are relaxations at different timescales.\nAlso, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \nIt is really non-trivial to set a criterion for whether or not a globally stable value is reached.\n</code></pre> Example <p>Load a DNA structure and minimize it <pre><code>nuc = mdna.load(traj)\nnuc.minimize(temperature=310, exvol_rad=2.0)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 5, plot : bool = False):\n    \"\"\"\n    Minimize the DNA structure. This method updates the  of the DNA structure.\n\n    Args:\n        frame (int): The trajectory frame to minimize. Defaults to -1.\n        simple (bool): Whether to use simple equilibration. Defaults to False.\n        equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n        endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n        fixed (list): List of fixed base pairs. Defaults to an empty list.\n        exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n        temperature (int): Temperature for equilibration. Defaults to 300.\n        dump_every (int): Frequency of dumping frames. Defaults to 5.\n        plot (bool): Whether to plot the energy. Defaults to False.\n\n    Additional keyword arguments can be provided and will be passed to the minimizer.\n\n    Notes:\n\n        For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n        This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n        The other option is to use the full equilibration, which is based on the actual energy of the system.\n        We assume the energy to converge exponentially to the equilibrated value.\n        This works fairly well for most examples I checked but is not entirely robust. \n        Considering autocorrelation has some issues when there are relaxations at different timescales.\n        Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n        It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n    Example:\n        Load a DNA structure and minimize it\n        ```python\n        nuc = mdna.load(traj)\n        nuc.minimize(temperature=310, exvol_rad=2.0)\n        ```\n    \"\"\"\n    self.minimizer = Minimizer(self)\n    self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n    # Update the reference frames\n    self._frames_to_traj()\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.mutate","title":"<code>mutate(mutations=None, complementary=True, frame=-1, verbose=False)</code>","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the mutated sequence. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> Example <p>Create a DNA object  <pre><code>dna = DNA()\nmutations = {0: 'A', 1: 'T', 2: 'G'}\ndna.mutate(mutations=mutations, complementary=True, frame=-1)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n        verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Example:\n        Create a DNA object \n        ```python\n        dna = DNA()\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n        ```\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"api/nucleic-reference/#pymdna.nucleic.Nucleic.save_pdb","title":"<code>save_pdb(filename=None, frame=-1)</code>","text":"<p>Save the DNA structure as a pdb file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename to save the pdb file. Defaults to None.</p> <code>None</code> <code>frame</code> <code>int</code> <p>If the trajectory has multiple frames, specify the frame to save. Defaults to -1.</p> <code>-1</code> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def save_pdb(self, filename : str = None, frame : int = -1):\n    \"\"\"Save the DNA structure as a pdb file.\n\n    Args:\n        filename (str, optional): Filename to save the pdb file. Defaults to None.\n        frame (int, optional): If the trajectory has multiple frames, specify the frame to save. Defaults to -1.\n    \"\"\"\n\n    # check if traj\n    if self.traj is None:\n        self._frames_to_traj()\n    if filename is None:\n        filename = 'my_mdna'\n    self.traj[frame].save(f'{filename}.pdb')\n</code></pre>"},{"location":"api/reference/","title":"Reference","text":"<p>This section of the documentation provides detailed, information-oriented references for the technical implementation of the <code>mdna</code> project code. It is intended as a comprehensive guide for developers and users who wish to understand the inner workings of the MDNA tool, its modules, and functions.</p>"},{"location":"api/reference/#nucleic-class","title":"Nucleic class","text":"<p>The <code>pymdna.nucleic</code> module is the core of the MDNA toolkit, encompassing a variety of classes and functions essential for DNA structure generation, manipulation, and analysis. Below, each key component of the module is outlined with explanations of its purpose and usage. The <code>Nucleic</code> class serves as the primary interface for interacting with DNA structures in the MDNA toolkit. It encapsulates both the structural properties of DNA and the trajectory information needed for molecular dynamics simulations. Key methods include:</p>"},{"location":"api/reference/#pymdna.nucleic","title":"<code>pymdna.nucleic</code>","text":""},{"location":"api/reference/#pymdna.nucleic.Connector","title":"<code>Connector</code>","text":"Source code in <code>src/pymdna/nucleic.py</code> <pre><code>class Connector:\n    def __init__(self, Nucleic0, Nucleic1, sequence : Union[str | List] = None, n_bp : int =  None, leader: int = 0, frame : int = -1, margin : int = 1, control_points : np.ndarray = None, index : int = 0):   \n\n        # Store the two Nucleic objects\n        self.Nucleic0 = Nucleic0\n        self.Nucleic1 = Nucleic1\n\n        # Might be possible sequence and n_bp are not falid\n        self.sequence = sequence\n        self.n_bp = n_bp\n        self.frame = frame\n        self.leader = leader\n        self.margin = margin\n        self.twist_tolerance = np.abs((360 / 10.4) - (360 / 10.6))\n\n        # Get the frames of the two nucleic acids\n        self.frames0 = Nucleic0.frames[:,self.frame,:,:]\n        self.frames1 = Nucleic1.frames[:,self.frame,:,:]\n\n        # Connect the two nucleic acids and store the new nucleic acid\n        self.connected_nuc = self.connect(index=index, control_points=control_points)\n\n    def connect(self, index=0, control_points=None):\n        \"\"\"Connect two nucleic acids by creating a new nucleic acid with a connecting DNA strand.\"\"\"\n        # Get the start and end points of the two nucleic acids (assuming the leader is 0 and we connect the end of A to start of B)\n        self.start, self.end = self._get_start_and_end()\n        rotation_difference = self._get_twist_difference()\n\n        # Find optimal number of base pairs to match rotational difference between start and end\n        if self.n_bp is None and self.sequence is None:\n            optimal_bps = self._find_optimal_bps(np.array([self.start[0], self.end[0]]), \n                                                bp_per_turn=10.5, \n                                                rise=0.34, \n                                                bp_range=1000, \n                                                rotation_difference=rotation_difference, \n                                                tolerance=self.twist_tolerance, \n                                                plot=False\n                                                )\n\n            # get the optimal number of base pairs (smallest amount of base pairs that satisfies the tolerance)\n            self.n_bp = optimal_bps[index]['optimal_bp']\n            print(f'Optimal number of base pairs: {self.n_bp}')\n\n\n                # interpolate control points for spline C\n        if control_points is None:\n            # Guess the shape of the spline C by interpolating the start and end points\n            # Note, we add to extra base pairs to account for the double count of the start and end points of the original strands\n            control_points_C = self._interplotate_points(self.start[0], self.end[0], self.n_bp+2)# if opti else self.n_bp)\n            distance = np.linalg.norm(self.start-self.end)\n            # Create frames object with the sequence and shape of spline C while squishing the correct number of BPs in the spline\n            spline_C = SplineFrames(control_points=control_points_C, frame_spacing=distance/len(control_points_C),n_bp=self.n_bp+2)\n        else:\n            spline_C = SplineFrames(control_points=control_points,frame_spacing=0.34, initial_frame=self.start)\n\n        # exclude first and last frame of C because they are already in spline A and B\n        frames_C = np.concatenate([self.frames0,spline_C.frames[1:-1],self.frames1])\n\n        # remember the fixed nodes/frames of A and B\n        fixed_0 = list(range(self.frames0.shape[0]-self.margin))\n        fixed_1 = list(range(frames_C.shape[0]-self.frames1.shape[0]+self.margin,frames_C.shape[0]))\n        self.fixed = fixed_0 + fixed_1\n\n        # Check if the sequence and number of base pairs are valid of the new connecting DNA\n        self.sequence, self.n_bp = _check_input(sequence=self.sequence, n_bp=spline_C.frames.shape[0]-2)\n\n        new_sequence = self.Nucleic0.sequence + self.sequence + self.Nucleic1.sequence\n        self.n_bp = len(self.sequence)\n\n        # Create a new Nucleic object with the new sequence and frames\n        return Nucleic(sequence=new_sequence, frames=frames_C)\n\n\n    def _get_start_and_end(self):\n        \"\"\"Get the start and end points of the two nucleic acids.\"\"\"\n        if self.leader == 0:\n            start = self.Nucleic0.frames[-1, self.frame,:,:]\n            end = self.Nucleic1.frames[0, self.frame,:,:]\n        else:\n            start = self.Nucleic1.frames[0, self.frame,:,:]\n            end = self.Nucleic0.frames[-1, self.frame,:,:]\n\n        return start, end\n\n    def _compute_euler_angles(self, frame_A, frame_B):\n        \"\"\"Compute the Euler angles between two frames.\"\"\"\n        # Compute the rotation matrix R that transforms frame A to frame B\n        rotation_matrix = np.dot(frame_B.T, frame_A)\n\n        # Create a rotation object from the rotation matrix\n        rotation = R.from_matrix(rotation_matrix)\n\n        # Convert the rotation to Euler angles (ZYX convention)\n        euler_angles = rotation.as_euler('zyx', degrees=True)\n\n        # Return the Euler angles: yaw (Z), pitch (Y), and roll (X)\n        return euler_angles\n\n    def _get_twist_difference(self):\n        \"\"\"Calculates the twist difference between two frames.\"\"\"\n        b1 = self.start[1:]/np.linalg.norm(self.start[1:])\n        b2 = self.end[1:]/np.linalg.norm(self.end[1:])\n\n        euler_angles = self._compute_euler_angles(b1, b2)\n        return euler_angles[-1]\n\n    def _interplotate_points(self,start, end, n):\n        \"\"\"Interpolates n points between start and end.\"\"\"\n        return np.array([start + (end-start)*i/n for i in range(n+1)])\n\n    def _find_minima(self, lst):\n        \"\"\"Finds the indices of local minima in a list.\"\"\"\n        return [i for i in range(1, len(lst) - 1) if lst[i - 1] &gt; lst[i] and lst[i + 1] &gt; lst[i]]\n\n    def _compute_left_over(self, bp_range, min_bp, bp_per_turn, rotation_difference):\n        \"\"\"Computes the left-over rotational difference for a range of base pairs.\"\"\"\n        cumul_twist = np.arange(min_bp, min_bp + bp_range) * 360 / bp_per_turn\n        return cumul_twist % 360 - rotation_difference\n\n    def _compute_twist_diff_per_bp(self, optimal_bp, left_over, min_bp):\n        \"\"\"Calculates the twist difference per base pair for an optimal base pair number.\"\"\"\n        total_twist_diff = left_over[optimal_bp - min_bp]\n        return total_twist_diff / optimal_bp\n\n    def _check_within_tolerance(self, twist_diff_per_bp, tolerance):\n        \"\"\"Checks if the twist difference per base pair is within the specified tolerance.\"\"\"\n        return np.abs(twist_diff_per_bp) &lt; tolerance\n\n    def _plot_leftover(self, min_bp,left_over):\n        \"\"\"Plotting the left-over rotational differences\"\"\"\n        plt.plot(np.arange(min_bp, min_bp + len(left_over)), np.abs(left_over))\n        plt.xlabel('Number of Base Pairs')\n        plt.ylabel('Absolute Left Over')\n        plt.show()\n\n    def _find_optimal_bps(self, positions, bp_per_turn, rise, bp_range, rotation_difference, tolerance, plot=False):\n        \"\"\"Finds optimal base pairs that satisfy the given tolerance.\n\n        Args:\n        positions: The positions of base pairs.\n        bp_per_turn: Base pairs per turn.\n        rise: Component of arc length.\n        bp_range: Range of base pairs to consider.\n        rotation_difference: The target rotation difference.\n        tolerance: The tolerance for accepting an optimal base pair number.\n        plot: If True, plots the left-over rotational differences.\n\n        Returns:\n        A list of dictionaries containing optimal base pair numbers and their twist differences per base pair.\n        \"\"\"\n        min_arc = np.linalg.norm(positions[0] - positions[-1])\n        min_bp = int(np.ceil(min_arc / rise))\n        left_over = self._compute_left_over(bp_range, min_bp, bp_per_turn, rotation_difference)\n\n        if plot:\n            self._plot_leftover(min_bp,left_over)\n\n        minima = self._find_minima(np.abs(left_over))\n        results = []\n\n        for min_val in minima:\n            optimal_bp = min_bp + min_val\n            twist_diff_per_bp = self._compute_twist_diff_per_bp(optimal_bp, left_over, min_bp)\n            if self._check_within_tolerance(twist_diff_per_bp, tolerance):\n                results.append({\n                    'optimal_bp': optimal_bp ,\n                    'twist_diff_per_bp': np.round(twist_diff_per_bp, 3)\n                })\n        if len(results) &gt; 0:\n            for result in results[:1]:\n                print(f'Optimal BP: {result[\"optimal_bp\"]}, Twist Difference per BP: {result[\"twist_diff_per_bp\"]} degrees')\n        else:\n            print(\"No optimal number of base pairs found within the specified tolerance.\")\n        return results\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Connector.connect","title":"<code>connect(index=0, control_points=None)</code>","text":"<p>Connect two nucleic acids by creating a new nucleic acid with a connecting DNA strand.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def connect(self, index=0, control_points=None):\n    \"\"\"Connect two nucleic acids by creating a new nucleic acid with a connecting DNA strand.\"\"\"\n    # Get the start and end points of the two nucleic acids (assuming the leader is 0 and we connect the end of A to start of B)\n    self.start, self.end = self._get_start_and_end()\n    rotation_difference = self._get_twist_difference()\n\n    # Find optimal number of base pairs to match rotational difference between start and end\n    if self.n_bp is None and self.sequence is None:\n        optimal_bps = self._find_optimal_bps(np.array([self.start[0], self.end[0]]), \n                                            bp_per_turn=10.5, \n                                            rise=0.34, \n                                            bp_range=1000, \n                                            rotation_difference=rotation_difference, \n                                            tolerance=self.twist_tolerance, \n                                            plot=False\n                                            )\n\n        # get the optimal number of base pairs (smallest amount of base pairs that satisfies the tolerance)\n        self.n_bp = optimal_bps[index]['optimal_bp']\n        print(f'Optimal number of base pairs: {self.n_bp}')\n\n\n            # interpolate control points for spline C\n    if control_points is None:\n        # Guess the shape of the spline C by interpolating the start and end points\n        # Note, we add to extra base pairs to account for the double count of the start and end points of the original strands\n        control_points_C = self._interplotate_points(self.start[0], self.end[0], self.n_bp+2)# if opti else self.n_bp)\n        distance = np.linalg.norm(self.start-self.end)\n        # Create frames object with the sequence and shape of spline C while squishing the correct number of BPs in the spline\n        spline_C = SplineFrames(control_points=control_points_C, frame_spacing=distance/len(control_points_C),n_bp=self.n_bp+2)\n    else:\n        spline_C = SplineFrames(control_points=control_points,frame_spacing=0.34, initial_frame=self.start)\n\n    # exclude first and last frame of C because they are already in spline A and B\n    frames_C = np.concatenate([self.frames0,spline_C.frames[1:-1],self.frames1])\n\n    # remember the fixed nodes/frames of A and B\n    fixed_0 = list(range(self.frames0.shape[0]-self.margin))\n    fixed_1 = list(range(frames_C.shape[0]-self.frames1.shape[0]+self.margin,frames_C.shape[0]))\n    self.fixed = fixed_0 + fixed_1\n\n    # Check if the sequence and number of base pairs are valid of the new connecting DNA\n    self.sequence, self.n_bp = _check_input(sequence=self.sequence, n_bp=spline_C.frames.shape[0]-2)\n\n    new_sequence = self.Nucleic0.sequence + self.sequence + self.Nucleic1.sequence\n    self.n_bp = len(self.sequence)\n\n    # Create a new Nucleic object with the new sequence and frames\n    return Nucleic(sequence=new_sequence, frames=frames_C)\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Extender","title":"<code>Extender</code>","text":"<p>Extend the DNA sequence in the specified direction using the five_end or three_end as reference.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>class Extender:\n    \"\"\"Extend the DNA sequence in the specified direction using the five_end or three_end as reference.\"\"\"\n\n    def __init__(self, nucleic, n_bp: int, sequence: Union[str | List] = None, fixed_endpoints: bool = False, frame : int = -1, forward: bool = True, shape: np.ndarray = None, margin : int = 1):\n        \"\"\"Initialize the DNA sequence extender\"\"\"\n        self.__dict__.update(nucleic.__dict__)\n\n        # Check the input sequence and number of base pairs\n        self._n_bp = n_bp # Number of base pairs to extend the DNA sequence\n        self._sequence = sequence # DNA sequence to extend the DNA structure\n        self._frames = self.frames[:,frame,:,:] # Reference frames of the DNA structure\n        # Add other parameters to the instance\n        self.fixed_endpoints = fixed_endpoints\n        self.forward = forward\n        self.shape = shape\n        self.frame = frame\n        self.margin = margin\n\n        # Get direction of extension\n        self.start, self.direction = self.get_start()\n\n        # Compute lengtht of the extension and target position\n        length = self._n_bp * 0.34 # Length of a base pair in nm\n        target_position = self.start + length * self.direction\n\n         # Interpolate control points for the new spline\n        if self.forward:\n            control_points = self.interplotate_points(self.start, target_position, self._n_bp)\n        else:\n            control_points = self.interplotate_points(target_position, self.start, self._n_bp)\n\n        # Create a new spline with the interpolated control points\n        spline = SplineFrames(control_points, frame_spacing=0.34)\n\n        if self.forward:\n            # fix the strand A except the margin at the end\n            fixed = list(range(self._frames.shape[0]-self.margin))\n        else:\n            # fix the strand A but shift the fixed indices to the end\n            fixed = list(range(self.frames.shape[0]))\n            fixed = [i + self._n_bp for i in fixed][self.margin:]\n        self.fixed = fixed\n\n        # Update the sequence\n        if self.forward:\n            new_sequence = self.sequence + self._sequence\n        else:\n            new_sequence = self._sequence + self.sequence\n\n        # Combine splines A and the new extension spline \n        if forward:\n            spline.frames = np.concatenate([self._frames[:-1],spline.frames])\n        else:\n            spline.frames = np.concatenate([spline.frames,self._frames[1:]])\n\n        self.nuc = Nucleic(sequence=new_sequence, frames=spline.frames)\n\n\n    def get_start(self):           \n        if self.forward:\n            return self._frames[-1][0], self._frames[-1][-1]\n        else:\n            # Reverse the direction of the normal base plane vector of the start last frame\n            return self._frames[0][0], -self._frames[0][-1]\n\n    def interplotate_points(self,start, end, n):\n        return np.array([start + (end-start)*i/n for i in range(n+1)])\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Extender.__init__","title":"<code>__init__(nucleic, n_bp, sequence=None, fixed_endpoints=False, frame=-1, forward=True, shape=None, margin=1)</code>","text":"<p>Initialize the DNA sequence extender</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def __init__(self, nucleic, n_bp: int, sequence: Union[str | List] = None, fixed_endpoints: bool = False, frame : int = -1, forward: bool = True, shape: np.ndarray = None, margin : int = 1):\n    \"\"\"Initialize the DNA sequence extender\"\"\"\n    self.__dict__.update(nucleic.__dict__)\n\n    # Check the input sequence and number of base pairs\n    self._n_bp = n_bp # Number of base pairs to extend the DNA sequence\n    self._sequence = sequence # DNA sequence to extend the DNA structure\n    self._frames = self.frames[:,frame,:,:] # Reference frames of the DNA structure\n    # Add other parameters to the instance\n    self.fixed_endpoints = fixed_endpoints\n    self.forward = forward\n    self.shape = shape\n    self.frame = frame\n    self.margin = margin\n\n    # Get direction of extension\n    self.start, self.direction = self.get_start()\n\n    # Compute lengtht of the extension and target position\n    length = self._n_bp * 0.34 # Length of a base pair in nm\n    target_position = self.start + length * self.direction\n\n     # Interpolate control points for the new spline\n    if self.forward:\n        control_points = self.interplotate_points(self.start, target_position, self._n_bp)\n    else:\n        control_points = self.interplotate_points(target_position, self.start, self._n_bp)\n\n    # Create a new spline with the interpolated control points\n    spline = SplineFrames(control_points, frame_spacing=0.34)\n\n    if self.forward:\n        # fix the strand A except the margin at the end\n        fixed = list(range(self._frames.shape[0]-self.margin))\n    else:\n        # fix the strand A but shift the fixed indices to the end\n        fixed = list(range(self.frames.shape[0]))\n        fixed = [i + self._n_bp for i in fixed][self.margin:]\n    self.fixed = fixed\n\n    # Update the sequence\n    if self.forward:\n        new_sequence = self.sequence + self._sequence\n    else:\n        new_sequence = self._sequence + self.sequence\n\n    # Combine splines A and the new extension spline \n    if forward:\n        spline.frames = np.concatenate([self._frames[:-1],spline.frames])\n    else:\n        spline.frames = np.concatenate([spline.frames,self._frames[1:]])\n\n    self.nuc = Nucleic(sequence=new_sequence, frames=spline.frames)\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic","title":"<code>Nucleic</code>","text":"<p>Contains mdna DNA structure with reference frames and trajectory</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>class Nucleic:\n\n    \"\"\"Contains mdna DNA structure with reference frames and trajectory\"\"\"\n\n    def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=[0,1], circular=None):\n            \"\"\"Initializes the DNA structure.\n\n            Args:\n                sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n                n_bp (int): The number of base pairs. Default is None.\n                traj (object): The MDTraj trajectory. Default is None.\n                frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n                chainids (list): The chain IDs. Default is [0,1].\n                circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n            Raises:\n                ValueError: If both traj and frames are provided.\n                ValueError: If frames have an invalid shape.\n                ValueError: If the number of base pairs in the sequence and frames do not match.\n                ValueError: If neither traj nor frames are provided.\n\n            Notes:\n                - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n                - If frames is provided, n_bp will be determined from the shape of frames.\n                - If sequence is provided, it will be checked against the number of base pairs.\n\n            Attributes:\n                sequence (str): The DNA sequence.\n                n_bp (int): The number of base pairs.\n                traj (object): The MDTraj trajectory.\n                frames (np.ndarray): The reference frames of the DNA structure.\n                chainids (list): The chain IDs.\n                circular (bool): A flag that indicates if the structure is circular/closed.\n                rigid (None): A container for rigid base parameters class output.\n                minimizer (None): A container for minimizer class output.\n            \"\"\"\n            # Check for trajectory\n            if traj is not None:\n                if frames is not None:\n                    raise ValueError('Provide either a trajectory or reference frames, not both')\n                # Extract sequence from the trajectory\n                sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n                n_bp = len(sequence)\n                sequence = ''.join(sequence)\n                frames = None  # Nucleic class will handle extraction from traj\n\n            # Check for reference frames\n            elif frames is not None:\n                if frames.ndim == 3:\n                    # Case (n_bp, 4, 3)\n                    frames = np.expand_dims(frames, axis=1)\n                if frames.ndim != 4:\n                    raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n                n_bp = frames.shape[0]\n                if sequence is not None:\n                    if len(sequence) != n_bp:\n                        raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                    else:\n                        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n            else:\n                raise ValueError('Provide either a trajectory or reference frames')\n\n            self.sequence, self.n_bp = sequence, n_bp\n            self.traj = traj\n            self.frames = frames\n            self.chainids = chainids\n            self.circular = self._is_circular() if circular is None else circular \n            self.rigid = None # Container for rigid base parameters class output\n            self.minimizer = None # Container for minimizer class output\n            self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n\n    def describe(self):\n        \"\"\"Print the DNA structure information\"\"\"\n        print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n        print('Sequence:', ''.join(self.sequence))\n\n        if self.traj is not None:\n            print('Trajectory:',self.traj)\n        else:\n            print('Trajectory not loaded')\n\n        if self.frames is not None:\n            print('Frames: ', self.frames.shape)\n        else:\n            print('Frames not loaded')\n\n    def _frames_to_traj(self, frame=-1):\n        \"\"\"Convert reference frames to trajectory\"\"\"\n        if self.frames is None:\n            raise ValueError('Load reference frames first')\n        self.traj = None\n        generator = StructureGenerator(frames=self.frames[:,frame,:,:], sequence=self.sequence, circular=self.circular)\n        self.traj = generator.get_traj()\n\n    def _traj_to_frames(self):\n        \"\"\"Convert trajectory to reference frames\"\"\"\n        if self.traj is None:\n            raise ValueError('Load trajectory first')\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        self.frames =self.rigid.frames\n\n    def get_frames(self):\n        \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n        Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n        where n_frames is the number of frames, n_bp is the number of base pairs, \n        and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n        Returns:\n            frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n        if self.frames is None:\n            self._traj_to_frames()\n        return self.frames\n\n    def get_traj(self):\n        \"\"\"Get the trajectory of the current state of the DNA structure\n        Returns:\n            MDtraj object\"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n\n        if self.traj.n_atoms &gt; 99999:\n            print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n        return self.traj\n\n    def get_rigid_object(self):\n        \"\"\"Get the rigid base class object of the DNA structure\n\n        Returns:\n            NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n        if self.rigid is None and self.traj is not None:\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        elif self.rigid is None and self.traj is None:\n            self._frames_to_traj()\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        else:\n            return self.rigid\n\n    def get_parameters(self, step : bool = False, base : bool = False):\n        \"\"\"By default retuns all the parameters of the DNA structure.\n        Use arguments to get a specific parameter group of the DNA structure.\n\n        Args:\n            step (bool, optional): Returns only the step parameters of consequative bases. Defaults to False.\n            base (bool, optional): Returns onlt the base pair parameters of opposing bases. Defaults to False.\n\n        Returns:\n            (parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameters(step=step, base=base)\n\n    def get_parameter(self, parameter_name : str):\n        \"\"\"Get a specific parameter from the rigid base parameters class object of the DNA structure\n\n        Args:\n            parameter_name (str): The name of the parameter to retrieve.\n\n        Notes:\n            The following parameters can be retrieved:\n            - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n        Returns:\n            np.ndarray: The parameter values of the DNA structure.\"\"\"\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameter(parameter_name)\n\n    def get_base_frames(self):\n        \"\"\"Get the base reference frames of the DNA structure\n\n        Returns:\n            dict: A dictionary containing the base reference frames of the DNA structure. \n              The keys are residue topologies of the MDTraj object (traj.top.residues) and the values are the reference frames in shape (n_frames, 4, 3), \n              where the rows represent the origin, b_D, b_L, and b_N vectors.\"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_base_reference_frames()\n\n\n    def _is_circular(self, frame=0):\n        \"\"\"Detects if the DNA structure is circular for a given chain and frame.\n\n        Args:\n            frame (int, optional): Frame index to check. Default is 0.\n\n        Returns:\n            bool: True if the DNA is circular, False otherwise.\n        \"\"\"\n        if self.frames is None:\n            self._traj_to_frames()\n\n        start = self.frames[0, frame, 0]\n        end = self.frames[-1, frame, 0]\n        distance = np.linalg.norm(start - end)\n\n        # 0.34 nm is roughly the distance between base pairs and 20 is the minimum number of base pairs for circular DNA\n        return distance &lt; 1 and self.frames.shape[0] &gt; 20\n\n    def _plot_chain(self, ax, traj, chainid, frame, lw=1, markersize=2, color='k'):\n        \"\"\"Plot the DNA structure of a chain\"\"\"\n        phosphor = traj.top.select(f'name P and chainid {chainid}')\n        x = traj.xyz[frame, phosphor, 0]\n        y = traj.xyz[frame, phosphor, 1]\n        z = traj.xyz[frame, phosphor, 2]\n\n        ax.plot(x, y, z, '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n        if self.circular:\n            # Connect the last point to the first point\n            ax.plot([x[-1], x[0]], [y[-1], y[0]], [z[-1], z[0]], '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n    def _plot_helical_axis(self, ax, frame, lw=1, color='k'):\n        helical_axis = self.frames[:,frame,0]\n        ax.plot(helical_axis[:,0],helical_axis[:,1],helical_axis[:,2],':',c=color,lw=lw*0.7)\n        if self.circular:\n            ax.plot([helical_axis[-1,0],helical_axis[0,0]],[helical_axis[-1,1],helical_axis[0,1]],[helical_axis[-1,2],helical_axis[0,2]],':',c='k',lw=lw*0.7)\n\n    def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey',color_axis='k'):\n        \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n        Args:\n            ax (object, optional): Matplotlib axis. Default is None.\n            fig (object, optional): Figure axis. Default is None.\n            save (bool, optional): Save image as png. Default is False.\n            frame (int, optional): Index of trajectory to visualize. Default is -1.\n            markersize (int, optional): Width of backbone plot. Default is 2.\n            lw (int, optional): Line width of plots. Default is 1.\n            helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n            backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n            lead (bool, optional): Plot leading strand. Default is False.\n            anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n            triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n            length (float, optional): Length of triad vectors. Default is 0.23.\n            color_lead (str, optional): Color of the leading strand. Default is 'k'.\n            color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n            color_axis (str, optional): Color of the helical axis. Default is 'k'.\n\n        Notes:\n            - The function draws a 3D representation of the DNA structure using matplotlib.\n            - The function requires either the trajectory or reference frames to be loaded before calling.\n\n        Example:\n            Make a DNA structure and draw the 3D representation\n            ```python\n            dna = nuc.make(sequence='CGCGAATTCGCG')\n            dna.draw()\n            ```\n        \"\"\"\n\n        # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n        # in shape (time/n_frames, n_bp, 4, 3)\n\n        if self.traj is None:\n            self._frames_to_traj()\n        elif self.frames is None:\n            self._traj_to_frames()\n\n        if fig is None and ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n\n        if backbone:\n            lead = True\n            anti = True\n        if lead:\n            self._plot_chain(ax, self.traj, self.chainids[0], frame=frame, markersize=markersize, lw=lw, color=color_lead)\n        if anti:\n            self._plot_chain(ax, self.traj, self.chainids[1], frame=frame, markersize=markersize, lw=lw, color=color_anti)\n        if helical_axis:\n            self._plot_helical_axis(ax, frame=frame, lw=lw, color=color_axis)\n        if triads:\n            for triad in self.frames:\n                triad = triad[frame]\n                ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n        ax.axis('equal')\n        ax.axis('off')\n        if save:\n            fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n\n    def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 5, plot : bool = False):\n        \"\"\"\n        Minimize the DNA structure. This method updates the  of the DNA structure.\n\n        Args:\n            frame (int): The trajectory frame to minimize. Defaults to -1.\n            simple (bool): Whether to use simple equilibration. Defaults to False.\n            equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n            endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n            fixed (list): List of fixed base pairs. Defaults to an empty list.\n            exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n            temperature (int): Temperature for equilibration. Defaults to 300.\n            dump_every (int): Frequency of dumping frames. Defaults to 5.\n            plot (bool): Whether to plot the energy. Defaults to False.\n\n        Additional keyword arguments can be provided and will be passed to the minimizer.\n\n        Notes:\n\n            For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n            This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n            The other option is to use the full equilibration, which is based on the actual energy of the system.\n            We assume the energy to converge exponentially to the equilibrated value.\n            This works fairly well for most examples I checked but is not entirely robust. \n            Considering autocorrelation has some issues when there are relaxations at different timescales.\n            Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n            It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n        Example:\n            Load a DNA structure and minimize it\n            ```python\n            nuc = mdna.load(traj)\n            nuc.minimize(temperature=310, exvol_rad=2.0)\n            ```\n        \"\"\"\n        self.minimizer = Minimizer(self)\n        self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n        # Update the reference frames\n        self._frames_to_traj()\n\n    def get_MC_traj(self):\n        \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n        if self.minimizer is None:\n            raise ValueError('Run minimization first')\n        return self.minimizer.get_MC_traj()\n\n    def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n        \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n        The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n        Args:\n            mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n            complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n            frame (int, optional): The frame to mutate. Defaults to -1.\n            verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n        Raises:\n            ValueError: If no mutation dictionary is provided.\n\n        Notes:\n            - Valid nucleobases for mutations include:\n                - Canonical bases: A, T, G, C, U\n                - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n                - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n                - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n        Example:\n            Create a DNA object \n            ```python\n            dna = DNA()\n            mutations = {0: 'A', 1: 'T', 2: 'G'}\n            dna.mutate(mutations=mutations, complementary=True, frame=-1)\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if mutations is None:\n            raise ValueError('Provide a mutation dictionary')\n\n        # TODO: Check if valid letters in mutations dictionary\n\n        mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n        self.traj = mutant.get_traj()\n        # Update sequence\n        self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n\n\n    def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n            \"\"\"Flips the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n                deg (int): The degrees to flip. Defaults to 180.\n                frame (int): The frame to flip. Defaults to -1.\n\n            Raises:\n                ValueError: If no fliplist is provided.\n\n            Notes:\n                - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n\n            Example:\n                Flip DNA\n                ```python\n                dna = mdna.make('GCAAAGC)\n                dna.flip(fliplist=[3,4], deg=180)\n                ```\n\n            \"\"\"\n\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(fliplist) == 0:\n                raise ValueError('Provide a fliplist')\n\n            flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n            self.traj = flipper.get_traj()\n\n    def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n            \"\"\"Methylate the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                methylations (list): List of base pairs to methylate. Defaults to [].\n                CpG (bool): Whether to methylate CpG sites. Defaults to False.\n                leading_strand (int): The leading strand to methylate. Defaults to 0.\n                frame (int): The frame to methylate. Defaults to -1.\n\n            Raises:\n                ValueError: If the DNA structure is not loaded.\n                ValueError: If the methylations list is empty.\n\n            Notes:\n                Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n\n            Example:\n                Methylate DNA\n                ```python\n                dna = mdna.make('GCGCGCGAGCGA)\n                dna.metyhlate(fliplist=[3,4])\n                ```\n            \"\"\"\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(methylations) == 0 and not CpG:\n                raise ValueError('Provide a non-empty methylations list')\n\n            methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n            self.traj = methylator.get_traj()\n\n    def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n        \"\"\"Extend the DNA structure in the specified direction.\n            The method updates the attributes of the DNA object.\n\n\n        Args:\n            n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n            sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n            fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n            forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n            frame (int, optional): The time frame to extend. Defaults to -1.\n            shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n            margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n            minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n            plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n            exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n            temperature (int, optional): Temperature for equilibration. Defaults\n\n        Raises:\n            ValueError: If the DNA structure is circular and cannot be extended.\n            ValueError: If neither a fixed endpoint nor a length is specified for extension.\n            ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n        Notes:\n            - If the DNA structure is circular, it cannot be extended.\n\n        Example:\n            Extend DNA structure\n            ```python\n            nuc = mdna.make(n_bp=100)\n            nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n            ```\n        \"\"\"\n        if self.circular:\n            raise ValueError('Cannot extend circular DNA structure')  \n        if self.traj is None:\n            self._frames_to_traj()\n        if shape is None:\n            shape = Shapes.line(length=1)\n        if self.frames is None:\n            self._traj_to_frames()\n\n        # Check the input sequence and number of base pairs\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n        extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n        # Also update, n_bp, sequence, frames etc\n        self.nuc = extender.nuc\n\n        if minimize:\n            self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n        # Update attributes\n        self.sequence = self.nuc.sequence\n        self.traj = self.nuc.get_traj()\n        self.frames = self.nuc.get_frames()\n        self.n_bp = self.nuc.n_bp\n\n    def invert(self):\n        \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n         The method updates attributes of the DNA object.\n\n         Raises:\n            NotImplementedError.\"\"\"\n        raise NotImplementedError('Not implemented yet')\n\n    def get_linking_number(self, frame : int = -1):\n        \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n        Args:\n            frame (int, optional): Time frame of trajectory, by default -1\n\n        Returns:\n            linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n        \"\"\"\n        try:\n            from pmcpy import pmcpy\n        except ImportError:\n            pmcpy_available = False\n            print(\"pmcpy is not installed. You shall not pass.\")\n\n        if self.frames is None:\n                self._traj_to_frames()\n        frames = self.frames[:,frame,:,:]\n        positions = frames[:,0]\n        triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n        writhe = pylk.writhe(positions)\n        lk = pylk.triads2link(positions, triads)\n        return np.array([lk, writhe, lk - writhe])\n\n    def save_pdb(self, filename : str = None, frame : int = -1):\n        \"\"\"Save the DNA structure as a pdb file.\n\n        Args:\n            filename (str, optional): Filename to save the pdb file. Defaults to None.\n            frame (int, optional): If the trajectory has multiple frames, specify the frame to save. Defaults to -1.\n        \"\"\"\n\n        # check if traj\n        if self.traj is None:\n            self._frames_to_traj()\n        if filename is None:\n            filename = 'my_mdna'\n        self.traj[frame].save(f'{filename}.pdb')\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.__init__","title":"<code>__init__(sequence=None, n_bp=None, traj=None, frames=None, chainids=[0, 1], circular=None)</code>","text":"<p>Initializes the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence, e.g. 'CGCGAATTCGCG'.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>The number of base pairs. Default is None.</p> <code>None</code> <code>traj</code> <code>object</code> <p>The MDTraj trajectory. Default is None.</p> <code>None</code> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure. Default is None.</p> <code>None</code> <code>chainids</code> <code>list</code> <p>The chain IDs. Default is [0,1].</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both traj and frames are provided.</p> <code>ValueError</code> <p>If frames have an invalid shape.</p> <code>ValueError</code> <p>If the number of base pairs in the sequence and frames do not match.</p> <code>ValueError</code> <p>If neither traj nor frames are provided.</p> Notes <ul> <li>If traj is provided, sequence and n_bp will be extracted from the trajectory.</li> <li>If frames is provided, n_bp will be determined from the shape of frames.</li> <li>If sequence is provided, it will be checked against the number of base pairs.</li> </ul> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>str</code> <p>The DNA sequence.</p> <code>n_bp</code> <code>int</code> <p>The number of base pairs.</p> <code>traj</code> <code>object</code> <p>The MDTraj trajectory.</p> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure.</p> <code>chainids</code> <code>list</code> <p>The chain IDs.</p> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed.</p> <code>rigid</code> <code>None</code> <p>A container for rigid base parameters class output.</p> <code>minimizer</code> <code>None</code> <p>A container for minimizer class output.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=[0,1], circular=None):\n        \"\"\"Initializes the DNA structure.\n\n        Args:\n            sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n            n_bp (int): The number of base pairs. Default is None.\n            traj (object): The MDTraj trajectory. Default is None.\n            frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n            chainids (list): The chain IDs. Default is [0,1].\n            circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n        Raises:\n            ValueError: If both traj and frames are provided.\n            ValueError: If frames have an invalid shape.\n            ValueError: If the number of base pairs in the sequence and frames do not match.\n            ValueError: If neither traj nor frames are provided.\n\n        Notes:\n            - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n            - If frames is provided, n_bp will be determined from the shape of frames.\n            - If sequence is provided, it will be checked against the number of base pairs.\n\n        Attributes:\n            sequence (str): The DNA sequence.\n            n_bp (int): The number of base pairs.\n            traj (object): The MDTraj trajectory.\n            frames (np.ndarray): The reference frames of the DNA structure.\n            chainids (list): The chain IDs.\n            circular (bool): A flag that indicates if the structure is circular/closed.\n            rigid (None): A container for rigid base parameters class output.\n            minimizer (None): A container for minimizer class output.\n        \"\"\"\n        # Check for trajectory\n        if traj is not None:\n            if frames is not None:\n                raise ValueError('Provide either a trajectory or reference frames, not both')\n            # Extract sequence from the trajectory\n            sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n            n_bp = len(sequence)\n            sequence = ''.join(sequence)\n            frames = None  # Nucleic class will handle extraction from traj\n\n        # Check for reference frames\n        elif frames is not None:\n            if frames.ndim == 3:\n                # Case (n_bp, 4, 3)\n                frames = np.expand_dims(frames, axis=1)\n            if frames.ndim != 4:\n                raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n            n_bp = frames.shape[0]\n            if sequence is not None:\n                if len(sequence) != n_bp:\n                    raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                else:\n                    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n        else:\n            raise ValueError('Provide either a trajectory or reference frames')\n\n        self.sequence, self.n_bp = sequence, n_bp\n        self.traj = traj\n        self.frames = frames\n        self.chainids = chainids\n        self.circular = self._is_circular() if circular is None else circular \n        self.rigid = None # Container for rigid base parameters class output\n        self.minimizer = None # Container for minimizer class output\n        self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.describe","title":"<code>describe()</code>","text":"<p>Print the DNA structure information</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def describe(self):\n    \"\"\"Print the DNA structure information\"\"\"\n    print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n    print('Sequence:', ''.join(self.sequence))\n\n    if self.traj is not None:\n        print('Trajectory:',self.traj)\n    else:\n        print('Trajectory not loaded')\n\n    if self.frames is not None:\n        print('Frames: ', self.frames.shape)\n    else:\n        print('Frames not loaded')\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.draw","title":"<code>draw(ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23, color_lead='k', color_anti='darkgrey', color_axis='k')</code>","text":"<p>Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>object</code> <p>Matplotlib axis. Default is None.</p> <code>None</code> <code>fig</code> <code>object</code> <p>Figure axis. Default is None.</p> <code>None</code> <code>save</code> <code>bool</code> <p>Save image as png. Default is False.</p> <code>False</code> <code>frame</code> <code>int</code> <p>Index of trajectory to visualize. Default is -1.</p> <code>-1</code> <code>markersize</code> <code>int</code> <p>Width of backbone plot. Default is 2.</p> <code>2</code> <code>lw</code> <code>int</code> <p>Line width of plots. Default is 1.</p> <code>1</code> <code>helical_axis</code> <code>bool</code> <p>Plot central axis passing through frame origins. Default is True.</p> <code>True</code> <code>backbone</code> <code>bool</code> <p>Plot backbone as 'o-' line plot through phosphor atoms. Default is True.</p> <code>True</code> <code>lead</code> <code>bool</code> <p>Plot leading strand. Default is False.</p> <code>False</code> <code>anti</code> <code>bool</code> <p>Plot anti-sense opposing leading strand. Default is False.</p> <code>False</code> <code>triads</code> <code>bool</code> <p>Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.</p> <code>False</code> <code>length</code> <code>float</code> <p>Length of triad vectors. Default is 0.23.</p> <code>0.23</code> <code>color_lead</code> <code>str</code> <p>Color of the leading strand. Default is 'k'.</p> <code>'k'</code> <code>color_anti</code> <code>str</code> <p>Color of the anti strand. Default is 'darkgrey'.</p> <code>'darkgrey'</code> <code>color_axis</code> <code>str</code> <p>Color of the helical axis. Default is 'k'.</p> <code>'k'</code> Notes <ul> <li>The function draws a 3D representation of the DNA structure using matplotlib.</li> <li>The function requires either the trajectory or reference frames to be loaded before calling.</li> </ul> Example <p>Make a DNA structure and draw the 3D representation <pre><code>dna = nuc.make(sequence='CGCGAATTCGCG')\ndna.draw()\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey',color_axis='k'):\n    \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n    Args:\n        ax (object, optional): Matplotlib axis. Default is None.\n        fig (object, optional): Figure axis. Default is None.\n        save (bool, optional): Save image as png. Default is False.\n        frame (int, optional): Index of trajectory to visualize. Default is -1.\n        markersize (int, optional): Width of backbone plot. Default is 2.\n        lw (int, optional): Line width of plots. Default is 1.\n        helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n        backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n        lead (bool, optional): Plot leading strand. Default is False.\n        anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n        triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n        length (float, optional): Length of triad vectors. Default is 0.23.\n        color_lead (str, optional): Color of the leading strand. Default is 'k'.\n        color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n        color_axis (str, optional): Color of the helical axis. Default is 'k'.\n\n    Notes:\n        - The function draws a 3D representation of the DNA structure using matplotlib.\n        - The function requires either the trajectory or reference frames to be loaded before calling.\n\n    Example:\n        Make a DNA structure and draw the 3D representation\n        ```python\n        dna = nuc.make(sequence='CGCGAATTCGCG')\n        dna.draw()\n        ```\n    \"\"\"\n\n    # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n    # in shape (time/n_frames, n_bp, 4, 3)\n\n    if self.traj is None:\n        self._frames_to_traj()\n    elif self.frames is None:\n        self._traj_to_frames()\n\n    if fig is None and ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n\n    if backbone:\n        lead = True\n        anti = True\n    if lead:\n        self._plot_chain(ax, self.traj, self.chainids[0], frame=frame, markersize=markersize, lw=lw, color=color_lead)\n    if anti:\n        self._plot_chain(ax, self.traj, self.chainids[1], frame=frame, markersize=markersize, lw=lw, color=color_anti)\n    if helical_axis:\n        self._plot_helical_axis(ax, frame=frame, lw=lw, color=color_axis)\n    if triads:\n        for triad in self.frames:\n            triad = triad[frame]\n            ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n    ax.axis('equal')\n    ax.axis('off')\n    if save:\n        fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.extend","title":"<code>extend(n_bp=None, sequence=None, fixed_endpoints=False, forward=True, frame=-1, shape=None, margin=1, minimize=True, plot=False, exvol_rad=2.0, temperature=300)</code>","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure. Defaults to None.</p> <code>None</code> <code>sequence</code> <code>str or List</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <code>plot</code> <code>bool</code> <p>Whether to plot the Energy during minmization. Defaults to False.</p> <code>False</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults</p> <code>300</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> </ul> Example <p>Extend DNA structure <pre><code>nuc = mdna.make(n_bp=100)\nnuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n        sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n        plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n        exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n        temperature (int, optional): Temperature for equilibration. Defaults\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n\n    Example:\n        Extend DNA structure\n        ```python\n        nuc = mdna.make(n_bp=100)\n        nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n        ```\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')  \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.flip","title":"<code>flip(fliplist=[], deg=180, frame=-1)</code>","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <ul> <li>Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.</li> </ul> Example <p>Flip DNA <pre><code>dna = mdna.make('GCAAAGC)\ndna.flip(fliplist=[3,4], deg=180)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n\n        Example:\n            Flip DNA\n            ```python\n            dna = mdna.make('GCAAAGC)\n            dna.flip(fliplist=[3,4], deg=180)\n            ```\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_MC_traj","title":"<code>get_MC_traj()</code>","text":"<p>Get the MC sampling energy minimization trajectory of the new spline.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_MC_traj(self):\n    \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n    if self.minimizer is None:\n        raise ValueError('Run minimization first')\n    return self.minimizer.get_MC_traj()\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_base_frames","title":"<code>get_base_frames()</code>","text":"<p>Get the base reference frames of the DNA structure</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the base reference frames of the DNA structure.  The keys are residue topologies of the MDTraj object (traj.top.residues) and the values are the reference frames in shape (n_frames, 4, 3),  where the rows represent the origin, b_D, b_L, and b_N vectors.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_base_frames(self):\n    \"\"\"Get the base reference frames of the DNA structure\n\n    Returns:\n        dict: A dictionary containing the base reference frames of the DNA structure. \n          The keys are residue topologies of the MDTraj object (traj.top.residues) and the values are the reference frames in shape (n_frames, 4, 3), \n          where the rows represent the origin, b_D, b_L, and b_N vectors.\"\"\"\n\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_base_reference_frames()\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_frames","title":"<code>get_frames()</code>","text":"<p>Get the reference frames of the DNA structure belonging to the base steps: Returns: array of reference frames of shape (n_frames, n_bp, 4, 3) where n_frames is the number of frames, n_bp is the number of base pairs,  and 4 corresponds to the origin and the 3 vectors of the reference frame</p> <p>Returns:</p> Name Type Description <code>frames</code> <code>ndarray</code> <p>reference frames of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_frames(self):\n    \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n    Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n    where n_frames is the number of frames, n_bp is the number of base pairs, \n    and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n    Returns:\n        frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n    if self.frames is None:\n        self._traj_to_frames()\n    return self.frames\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_linking_number","title":"<code>get_linking_number(frame=-1)</code>","text":"<p>Get the linking number of the DNA structure based on Gauss's linking number theorem.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>Time frame of trajectory, by default -1</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>linking_number</code> <code>ndarray</code> <p>Numpy array containing the linking number, writhe, and twist corresponding to the time frame</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_linking_number(self, frame : int = -1):\n    \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n    Args:\n        frame (int, optional): Time frame of trajectory, by default -1\n\n    Returns:\n        linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n    \"\"\"\n    try:\n        from pmcpy import pmcpy\n    except ImportError:\n        pmcpy_available = False\n        print(\"pmcpy is not installed. You shall not pass.\")\n\n    if self.frames is None:\n            self._traj_to_frames()\n    frames = self.frames[:,frame,:,:]\n    positions = frames[:,0]\n    triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n    writhe = pylk.writhe(positions)\n    lk = pylk.triads2link(positions, triads)\n    return np.array([lk, writhe, lk - writhe])\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_parameter","title":"<code>get_parameter(parameter_name)</code>","text":"<p>Get a specific parameter from the rigid base parameters class object of the DNA structure</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>The name of the parameter to retrieve.</p> required Notes <p>The following parameters can be retrieved: - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening</p> <p>Returns:</p> Type Description <p>np.ndarray: The parameter values of the DNA structure.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_parameter(self, parameter_name : str):\n    \"\"\"Get a specific parameter from the rigid base parameters class object of the DNA structure\n\n    Args:\n        parameter_name (str): The name of the parameter to retrieve.\n\n    Notes:\n        The following parameters can be retrieved:\n        - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n    Returns:\n        np.ndarray: The parameter values of the DNA structure.\"\"\"\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_parameter(parameter_name)\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_parameters","title":"<code>get_parameters(step=False, base=False)</code>","text":"<p>By default retuns all the parameters of the DNA structure. Use arguments to get a specific parameter group of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>bool</code> <p>Returns only the step parameters of consequative bases. Defaults to False.</p> <code>False</code> <code>base</code> <code>bool</code> <p>Returns onlt the base pair parameters of opposing bases. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>(parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_parameters(self, step : bool = False, base : bool = False):\n    \"\"\"By default retuns all the parameters of the DNA structure.\n    Use arguments to get a specific parameter group of the DNA structure.\n\n    Args:\n        step (bool, optional): Returns only the step parameters of consequative bases. Defaults to False.\n        base (bool, optional): Returns onlt the base pair parameters of opposing bases. Defaults to False.\n\n    Returns:\n        (parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_parameters(step=step, base=base)\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_rigid_object","title":"<code>get_rigid_object()</code>","text":"<p>Get the rigid base class object of the DNA structure</p> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_rigid_object(self):\n    \"\"\"Get the rigid base class object of the DNA structure\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n    if self.rigid is None and self.traj is not None:\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    elif self.rigid is None and self.traj is None:\n        self._frames_to_traj()\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    else:\n        return self.rigid\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.get_traj","title":"<code>get_traj()</code>","text":"<p>Get the trajectory of the current state of the DNA structure Returns:     MDtraj object</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def get_traj(self):\n    \"\"\"Get the trajectory of the current state of the DNA structure\n    Returns:\n        MDtraj object\"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n\n    if self.traj.n_atoms &gt; 99999:\n        print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n    return self.traj\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.invert","title":"<code>invert()</code>","text":"<p>Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5 The method updates attributes of the DNA object.</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def invert(self):\n    \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n     The method updates attributes of the DNA object.\n\n     Raises:\n        NotImplementedError.\"\"\"\n    raise NotImplementedError('Not implemented yet')\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.methylate","title":"<code>methylate(methylations=[], CpG=False, leading_strand=0, frame=-1)</code>","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <p>Using the <code>CpG</code> flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.</p> Example <p>Methylate DNA <pre><code>dna = mdna.make('GCGCGCGAGCGA)\ndna.metyhlate(fliplist=[3,4])\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n\n        Example:\n            Methylate DNA\n            ```python\n            dna = mdna.make('GCGCGCGAGCGA)\n            dna.metyhlate(fliplist=[3,4])\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(methylations) == 0 and not CpG:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.minimize","title":"<code>minimize(frame=-1, exvol_rad=2.0, temperature=300, simple=False, equilibrate_writhe=False, endpoints_fixed=False, fixed=[], dump_every=5, plot=False)</code>","text":"<p>Minimize the DNA structure. This method updates the  of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The trajectory frame to minimize. Defaults to -1.</p> <code>-1</code> <code>simple</code> <code>bool</code> <p>Whether to use simple equilibration. Defaults to False.</p> <code>False</code> <code>equilibrate_writhe</code> <code>bool</code> <p>Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.</p> <code>False</code> <code>endpoints_fixed</code> <code>bool</code> <p>Whether the endpoints are fixed. Defaults to False.</p> <code>False</code> <code>fixed</code> <code>list</code> <p>List of fixed base pairs. Defaults to an empty list.</p> <code>[]</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults to 300.</p> <code>300</code> <code>dump_every</code> <code>int</code> <p>Frequency of dumping frames. Defaults to 5.</p> <code>5</code> <code>plot</code> <code>bool</code> <p>Whether to plot the energy. Defaults to False.</p> <code>False</code> <p>Additional keyword arguments can be provided and will be passed to the minimizer.</p> <p>Notes:</p> <pre><code>For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \nThis options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration.\n\nThe other option is to use the full equilibration, which is based on the actual energy of the system.\nWe assume the energy to converge exponentially to the equilibrated value.\nThis works fairly well for most examples I checked but is not entirely robust. \nConsidering autocorrelation has some issues when there are relaxations at different timescales.\nAlso, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \nIt is really non-trivial to set a criterion for whether or not a globally stable value is reached.\n</code></pre> Example <p>Load a DNA structure and minimize it <pre><code>nuc = mdna.load(traj)\nnuc.minimize(temperature=310, exvol_rad=2.0)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 5, plot : bool = False):\n    \"\"\"\n    Minimize the DNA structure. This method updates the  of the DNA structure.\n\n    Args:\n        frame (int): The trajectory frame to minimize. Defaults to -1.\n        simple (bool): Whether to use simple equilibration. Defaults to False.\n        equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n        endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n        fixed (list): List of fixed base pairs. Defaults to an empty list.\n        exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n        temperature (int): Temperature for equilibration. Defaults to 300.\n        dump_every (int): Frequency of dumping frames. Defaults to 5.\n        plot (bool): Whether to plot the energy. Defaults to False.\n\n    Additional keyword arguments can be provided and will be passed to the minimizer.\n\n    Notes:\n\n        For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n        This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n        The other option is to use the full equilibration, which is based on the actual energy of the system.\n        We assume the energy to converge exponentially to the equilibrated value.\n        This works fairly well for most examples I checked but is not entirely robust. \n        Considering autocorrelation has some issues when there are relaxations at different timescales.\n        Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n        It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n    Example:\n        Load a DNA structure and minimize it\n        ```python\n        nuc = mdna.load(traj)\n        nuc.minimize(temperature=310, exvol_rad=2.0)\n        ```\n    \"\"\"\n    self.minimizer = Minimizer(self)\n    self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n    # Update the reference frames\n    self._frames_to_traj()\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.mutate","title":"<code>mutate(mutations=None, complementary=True, frame=-1, verbose=False)</code>","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the mutated sequence. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> Example <p>Create a DNA object  <pre><code>dna = DNA()\nmutations = {0: 'A', 1: 'T', 2: 'G'}\ndna.mutate(mutations=mutations, complementary=True, frame=-1)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n        verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Example:\n        Create a DNA object \n        ```python\n        dna = DNA()\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n        ```\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.Nucleic.save_pdb","title":"<code>save_pdb(filename=None, frame=-1)</code>","text":"<p>Save the DNA structure as a pdb file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename to save the pdb file. Defaults to None.</p> <code>None</code> <code>frame</code> <code>int</code> <p>If the trajectory has multiple frames, specify the frame to save. Defaults to -1.</p> <code>-1</code> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def save_pdb(self, filename : str = None, frame : int = -1):\n    \"\"\"Save the DNA structure as a pdb file.\n\n    Args:\n        filename (str, optional): Filename to save the pdb file. Defaults to None.\n        frame (int, optional): If the trajectory has multiple frames, specify the frame to save. Defaults to -1.\n    \"\"\"\n\n    # check if traj\n    if self.traj is None:\n        self._frames_to_traj()\n    if filename is None:\n        filename = 'my_mdna'\n    self.traj[frame].save(f'{filename}.pdb')\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.compute_curvature","title":"<code>compute_curvature(traj, chainids=[0, 1])</code>","text":"<p>Compute the curvature of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_curvature(traj, chainids=[0,1]):\n    \"\"\"Compute the curvature of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.compute_groove_width","title":"<code>compute_groove_width(traj, chainids=[0, 1])</code>","text":"<p>Compute the groove width of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_groove_width(traj, chainids=[0,1]):\n    \"\"\"Compute the groove width of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.compute_linking_number","title":"<code>compute_linking_number(traj, chainids=[0, 1])</code>","text":"<p>Compute the linking number of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_linking_number(traj, chainids=[0,1]):\n    \"\"\"Compute the linking number of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.compute_rigid_parameters","title":"<code>compute_rigid_parameters(traj, chainids=[0, 1])</code>","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example <p>Compute the rigid base parameters of a DNA structure ```python traj = md.load('dna.pdb') rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1]) ````</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1]):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        Compute the rigid base parameters of a DNA structure\n        ```python\n        traj = md.load('dna.pdb')\n        rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1])\n        ````\n    \"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids)\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.connect","title":"<code>connect(Nucleic0, Nucleic1, sequence=None, n_bp=None, leader=0, frame=-1, margin=1, minimize=True, exvol_rad=0.0, temperature=300, control_points=None, index=0)</code>","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str or List</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Notes <ul> <li>The minimization does not use excluded volume interactions by default.This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</li> </ul> Example <p>Connect two DNA structures <pre><code>dna = connect(Nucleic0, Nucleic1, margin=5)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def connect(Nucleic0, Nucleic1, sequence: Union[str|List] = None, n_bp: int = None, leader: int = 0, frame: int = -1, margin: int = 1, minimize: bool = True, exvol_rad: float = 0.0, temperature: int = 300, control_points : np.ndarray = None, index : int = 0):  \n    \"\"\"Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.\n\n    The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure.\n    To connect the two strands, a straight line is interpolated between the two ends,\n    and the optimal number of base pairs is distributed to achieve a neutral twist.\n\n    Args:\n        Nucleic0 (Nucleic): First DNA structure to connect.\n        Nucleic1 (Nucleic): Second DNA structure to connect.\n        sequence (str or List, optional): DNA sequence of the connecting DNA strand. Default is None.\n        n_bp (int, optional): Number of base pairs of the connecting DNA strand. Default is None.\n        leader (int, optional): The leader of the DNA structure to connect. Default is 0.\n        frame (int, optional): The time frame to connect. Default is -1.\n        margin (int, optional): Number of base pairs to fix at the end. Default is 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure. Default is True.\n        exvol_rad (float, optional): Radius for excluded volume interactions during minimization. Default is 0.0.\n        temperature (int, optional): Temperature for minimization. Default is 300.\n\n    Returns:\n        Nucleic (object): DNA structure with the two DNA structures connected.\n\n    Raises:\n        ValueError: If either of the DNA structures is circular.\n\n    Notes:\n        - The minimization does not use excluded volume interactions by default.This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.\n\n    Example:\n        Connect two DNA structures\n        ```python\n        dna = connect(Nucleic0, Nucleic1, margin=5)\n        ```\n    \"\"\"\n    if Nucleic0.circular or Nucleic1.circular:\n        raise ValueError('Cannot connect circular DNA structures')\n\n    if (sequence is not None and n_bp is None) or (sequence is None and n_bp is not None) or (sequence is not None and n_bp is not None):\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    # Connect the two DNA structures\n    connector = Connector(Nucleic0, Nucleic1, sequence=sequence, n_bp=n_bp, leader=leader, frame=frame, margin=margin, control_points=control_points, index=index)\n    if minimize:\n        connector.connected_nuc.minimize(exvol_rad=exvol_rad, temperature=temperature, fixed=connector.fixed)\n    return connector.connected_nuc\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.load","title":"<code>load(traj=None, frames=None, sequence=None, chainids=[0, 1], circular=None, filename=None, top=None, stride=None)</code>","text":"<p>Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>frames</code> <code>array</code> <p>Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>sequence</code> <code>str</code> <p>DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>chainids</code> <code>list</code> <p>Chain IDs of the DNA structure. (default: [0,1])</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)</p> <code>None</code> <code>filename</code> <code>str</code> <p>The filename or filenames of the trajectory. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>top</code> <code>str</code> <p>The topology file of the trajectory. (default: None)</p> <code>None</code> <code>stride</code> <code>int</code> <p>The stride of the trajectory. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>The <code>traj</code> argument is prioritized over frames and sequence.</li> <li>If the <code>filename_or_filenames</code> argument is provided, the other arguments are ignored, except for the <code>top</code> and <code>stride</code> arguments and <code>chainids</code>.</li> </ul> Example <p>Load a DNA structure from a trajectory <pre><code>traj = md.load('dna.pdb')\ndna = mdna.load(traj=traj, chainids=[0, 1])\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def load(traj=None, frames=None, sequence=None, chainids=[0,1], circular=None, filename=None, top=None, stride=None):\n    \"\"\"Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.\n\n    Args:\n        traj (object, optional): MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)\n        frames (np.array, optional): Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)\n        sequence (str, optional): DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)\n        chainids (list, optional): Chain IDs of the DNA structure. (default: [0,1])\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)\n        filename (str, optional): The filename or filenames of the trajectory. If provided, the traj and frames arguments are ignored. (default: None)\n        top (str, optional): The topology file of the trajectory. (default: None)\n        stride (int, optional): The stride of the trajectory. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - The `traj` argument is prioritized over frames and sequence.\n        - If the `filename_or_filenames` argument is provided, the other arguments are ignored, except for the `top` and `stride` arguments and `chainids`.\n\n    Example:\n        Load a DNA structure from a trajectory\n        ```python\n        traj = md.load('dna.pdb')\n        dna = mdna.load(traj=traj, chainids=[0, 1])\n        ```\n    \"\"\"\n    # Load the trajectory directly using MDtraj from a file\n    if filename is not None and top is None:\n        traj = md.load(filename_or_filenames=filename, stride=stride)\n    elif filename is not None and top is not None:\n        traj = md.load(filename_or_filenames=filename, top=top, stride=stride)\n\n    return Nucleic(sequence=sequence, n_bp=None, traj=traj, frames=frames, chainids=chainids, circular=None)\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.make","title":"<code>make(sequence=None, control_points=None, circular=False, closed=False, n_bp=None, dLk=None)</code>","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Example <p>Generate a DNA structure from a sequence <pre><code>dna = make(sequence='CGCGAATTCGCG', control_points=None, circular=False, closed=False, n_bp=None, dLk=None)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def make(sequence: str = None, control_points: np.ndarray = None, circular : bool = False, closed: bool = False, n_bp : int = None, dLk : int = None):\n    \"\"\"Generate a DNA structure from a given DNA sequence and control points.\n\n    Args:\n        sequence (str, optional): DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)\n        control_points (ndarray, optional): Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)\n        closed (bool, optional): Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)\n        n_bp (int, optional): Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)\n        dLk (int, optional): Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Example:\n        Generate a DNA structure from a sequence\n        ```python\n        dna = make(sequence='CGCGAATTCGCG', control_points=None, circular=False, closed=False, n_bp=None, dLk=None)\n        ```\n    \"\"\"\n\n    # Check if control points are provided, otherwise generate a straight line\n    skip = False\n    if control_points is not None:\n        if len(control_points) &lt; 4:\n            raise ValueError('Control points should contain at least 4 points [x, y, z]')\n        elif len(control_points) &gt; 4 and n_bp is None and sequence is None:\n            skip = True\n    elif control_points is None and circular:\n        control_points = Shapes.circle(radius=1)\n        closed = True\n    else:\n        # Linear strand of control points\n        control_points = Shapes.line(length=1)\n\n    if not skip:\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n        spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n    else:\n        spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=spline.n_bp)\n\n\n\n\n    return Nucleic(sequence=sequence, n_bp=n_bp, frames=spline.frames, chainids=[0, 1], circular=circular)\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.sequence_to_md","title":"<code>sequence_to_md(sequence=None, time=10, time_unit='picoseconds', temperature=310, solvated=False, filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None, save_location='./')</code>","text":"<p>Simulate DNA sequence using OpenMM.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code.</p> <code>None</code> <code>time</code> <code>int</code> <p>Simulation time.</p> <code>10</code> <code>time_unit</code> <code>str</code> <p>Time unit (picoseconds or nanoseconds).</p> <code>'picoseconds'</code> <code>temperature</code> <code>int</code> <p>Temperature in Kelvin.</p> <code>310</code> <code>solvated</code> <code>bool</code> <p>Solvate DNA with water and ions.</p> <code>False</code> <code>filename</code> <code>str</code> <p>Filename for pdb output.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Save the trajectory.</p> <code>True</code> <code>output</code> <code>str</code> <p>Output format for the trajectory (GROMACS or HDF5).</p> <code>'GROMACS'</code> <code>shape</code> <code>str</code> <p>Shape of the DNA structure (linear or circular).</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs in the DNA structure.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in linking number of the DNA structure.</p> <code>None</code> <code>save_location</code> <code>str</code> <p>Location to save the trajectory.</p> <code>'./'</code> <p>Returns:</p> Name Type Description <code>MDTraj</code> <code>object</code> <p>MDtraj trajectory object of DNA structure.</p> Notes <ul> <li>This function uses the OpenMM library to simulate the behavior of a DNA sequence.</li> <li>The simulation can be performed for a specified time period at a given temperature.</li> <li>The DNA structure can be solvated with water and ions.</li> <li>The trajectory of the simulation can be saved in either GROMACS or HDF5 format.</li> </ul> Example <p>Simulate a linear DNA structure for 100 picoseconds at 300 K <pre><code>trajectory = mdna.sequence_to_md(sequence='ATCGATA', time=100, time_unit='picoseconds', temperature=300, shape='linear')\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def sequence_to_md(sequence=None, time=10, time_unit='picoseconds',temperature=310, solvated=False,  filename='my_dna', save=True, output='GROMACS',shape=None,n_bp=None,circular=False,dLk=None,save_location='./'):\n    \"\"\"Simulate DNA sequence using OpenMM.\n\n        Args:\n            sequence (str): DNA sequence code.\n            time (int): Simulation time.\n            time_unit (str): Time unit (picoseconds or nanoseconds).\n            temperature (int): Temperature in Kelvin.\n            solvated (bool): Solvate DNA with water and ions.\n            filename (str): Filename for pdb output.\n            save (bool): Save the trajectory.\n            output (str): Output format for the trajectory (GROMACS or HDF5).\n            shape (str): Shape of the DNA structure (linear or circular).\n            n_bp (int): Number of base pairs in the DNA structure.\n            circular (bool): Flag indicating if the DNA structure is circular.\n            dLk (int): Change in linking number of the DNA structure.\n            save_location (str): Location to save the trajectory.\n\n        Returns:\n            MDTraj (object): MDtraj trajectory object of DNA structure.\n\n        Notes:\n            - This function uses the OpenMM library to simulate the behavior of a DNA sequence.\n            - The simulation can be performed for a specified time period at a given temperature.\n            - The DNA structure can be solvated with water and ions.\n            - The trajectory of the simulation can be saved in either GROMACS or HDF5 format.\n\n        Example:\n            Simulate a linear DNA structure for 100 picoseconds at 300 K\n            ```python\n            trajectory = mdna.sequence_to_md(sequence='ATCGATA', time=100, time_unit='picoseconds', temperature=300, shape='linear')\n            ```\n        \"\"\"\n\n    # TODO update with make function\n    try:\n        import openmm as mm\n        import openmm.app as app\n        import openmm.unit as unit\n        from mdtraj.reporters import HDF5Reporter\n        import mdtraj as md\n        openmm_available = True\n    except ImportError:\n        openmm_available = False\n        print(\"Openmm is not installed. You shall not pass.\")\n    if filename is None:\n        filename = sequence\n\n    pdb = sequence_to_pdb(sequence=sequence, filename=f'{save_location}{filename}', save=True, output='GROMACS',shape=None,n_bp=None,circular=False,dLk=None)\n\n    if not openmm_available:\n        print('But here is your DNA structure')\n        return pdb\n    else:\n        if time_unit == 'picoseconds':\n            time_unit = time * unit.picoseconds\n        elif time_unit == 'nanoseconds':\n            time_unit = time * unit.nanoseconds\n\n        time = time * time_unit\n        time_step = 2 * unit.femtoseconds\n        temperature = 310 *unit.kelvin\n        steps = int(time/time_step)\n\n        print(f'Initialize DNA openMM simulation at {temperature._value} K for', time, 'time units')\n        topology = pdb.topology.to_openmm()\n        modeller = app.Modeller(topology, pdb.xyz[0])\n\n        forcefield = app.ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')\n        modeller.addHydrogens(forcefield)\n        if solvated:\n            print('Solvate DNA with padding of 1.0 nm and 0.1 M KCl')\n            modeller.addSolvent(forcefield, padding=1.0*unit.nanometers, ionicStrength=0.1*unit.molar, positiveIon='K+')\n\n        system = forcefield.createSystem(modeller.topology, nonbondedMethod=app.CutoffNonPeriodic)\n        integrator = mm.LangevinIntegrator(temperature, 1.0/unit.picoseconds, time_step)\n\n        simulation = app.Simulation(modeller.topology, system, integrator)\n        simulation.context.setPositions(modeller.positions)\n        simulation.reporters.append(HDF5Reporter(f'{save_location}{filename}'+'.h5', 100))\n        simulation.reporters.append(app.StateDataReporter(f'{save_location}/output_{filename}.csv', 100, step=True, potentialEnergy=True, temperature=True,speed=True))\n\n        print('Minimize energy')\n        simulation.minimizeEnergy()\n\n        print('Run simulation for', steps, 'steps')\n        simulation.step(steps)\n        simulation.reporters[0].close()\n        print('Simulation completed')\n        print('Saved trajectory as:', f'{save_location}{filename}'+'.h5')\n        traj = md.load_hdf5(f'{save_location}{filename}'+'.h5')\n        return traj\n</code></pre>"},{"location":"api/reference/#pymdna.nucleic.sequence_to_pdb","title":"<code>sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None, save_location='./')</code>","text":"<p>Generate a DNA structure from a DNA sequence code.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence code. Default is 'CGCGAATTCGCG'.</p> <code>'CGCGAATTCGCG'</code> <code>filename</code> <code>str</code> <p>The filename for the pdb output. Default is 'my_dna'.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Whether to save the pdb file. Default is True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The type of pdb DNA format. Default is 'GROMACS'.</p> <code>'GROMACS'</code> <code>shape</code> <code>ndarray</code> <p>Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Indicates if the structure is circular/closed. Default is False.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.</p> <code>None</code> <code>save_location</code> <code>str</code> <p>Location to save the trajectory. Default is './'.</p> <code>'./'</code> <p>Returns:</p> Type Description <code>Trajectory</code> <p>md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence is not provided.</p> Notes <ul> <li>The pdb file is saved in the current directory with the specified filename.</li> </ul> Example <p>Generate a DNA structure from a sequence <pre><code>traj = mdna.sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def sequence_to_pdb(sequence: str = 'CGCGAATTCGCG', filename: str = 'my_dna', save: bool = True, output: str = 'GROMACS', shape: np.ndarray = None, n_bp: int = None, circular: bool = False, dLk: int = None, save_location : str = './') -&gt; md.Trajectory:\n    \"\"\"Generate a DNA structure from a DNA sequence code.\n\n    Args:\n        sequence (str, optional): The DNA sequence code. Default is 'CGCGAATTCGCG'.\n        filename (str, optional): The filename for the pdb output. Default is 'my_dna'.\n        save (bool, optional): Whether to save the pdb file. Default is True.\n        output (str, optional): The type of pdb DNA format. Default is 'GROMACS'.\n        shape (np.ndarray, optional): Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.\n        n_bp (int, optional): Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.\n        circular (bool, optional): Indicates if the structure is circular/closed. Default is False.\n        dLk (int, optional): Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.\n        save_location (str, optional): Location to save the trajectory. Default is './'.\n\n    Returns:\n        md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).\n\n    Raises:\n        ValueError: If the sequence is not provided.\n\n    Notes:\n        - The pdb file is saved in the current directory with the specified filename.\n\n    Example:\n        Generate a DNA structure from a sequence\n        ```python\n        traj = mdna.sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)\n        ```\n    \"\"\"\n\n    # Check if the sequence is provided\n    if sequence is None:\n        raise ValueError(\"The sequence argument must be provided.\")\n\n    # TODO: Update with make function\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    # Linear strand of control points\n    if shape is None:\n        shape = Shapes.line(length=1)\n\n    # Convert the control points to a spline\n    spline = SplineFrames(control_points=shape, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    # Generate the DNA structure\n    generator = StructureGenerator(sequence=sequence, spline=spline, circular=circular)\n\n    # Edit the DNA structure to make it compatible with the AMBER force field\n    traj = generator.traj\n    if output == 'GROMACS':\n        phosphor_termini = traj.top.select(f'name P OP1 OP2 and resid 0 {traj.top.chain(0).n_residues}')\n        all_atoms = traj.top.select('all')\n        traj = traj.atom_slice([at for at in all_atoms if at not in phosphor_termini])\n\n    # Save the DNA structure as a pdb file\n    if save:\n        traj.save(f'{save_location}{filename}.pdb')\n\n    return traj\n</code></pre>"},{"location":"api/shapes-reference/","title":"Shapes class","text":""},{"location":"api/shapes-reference/#pymdna.utils.Shapes","title":"<code>pymdna.utils.Shapes</code>","text":"<p>Class for generating parametric shapes in 3D space.</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>class Shapes:\n    \"\"\"Class for generating parametric shapes in 3D space.\n    \"\"\"\n\n    def __init__(self, parametric_function, t_values=None, num_points=100):\n        self.num_points = num_points\n        self.parametric_function = parametric_function\n        self.points = self._generate_points(t_values)\n\n    def _generate_points(self,t_values=None):\n        x_values, y_values, z_values = self.parametric_function(t_values)\n        return np.stack((x_values, y_values, z_values), axis=1)\n\n    @classmethod\n    def circle(cls, radius=1, t_values=None, num_points=100):\n        \"\"\"Create a circle in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the circle of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * np.cos(t_values),\n            radius * np.sin(t_values),\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def line(cls, length=1, num_points=100):\n        \"\"\"Create a line in 3D space.\n\n        Args:\n            length (int, optional): _description_. Defaults to 1.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the line of shape (num_points, 3)\n        \"\"\"\n        t_values = np.linspace(0, 1, num=num_points)\n        parametric_function = lambda t_values: (\n            t_values * length,\n            np.zeros_like(t_values),\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def helix(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n        \"\"\"Create a helix in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            pitch (int, optional): _description_. Defaults to 1.\n            height (int, optional): _description_. Defaults to 1.\n            num_turns (int, optional): _description_. Defaults to 1.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the helix of shape (num_points, 3)\n        \"\"\"\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * np.cos(t_values),\n            radius * np.sin(t_values),\n            height * t_values / (2 * np.pi) - pitch * num_turns * t_values / (2 * np.pi)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def spiral(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n        \"\"\"Create a spiral in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            pitch (int, optional): _description_. Defaults to 1.\n            height (int, optional): _description_. Defaults to 1.\n            num_turns (int, optional): _description_. Defaults to 1.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the spiral of shape (num_points, 3)\n        \"\"\"\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * t_values * np.cos(t_values),\n            radius * t_values * np.sin(t_values),\n            height * t_values / (2 * np.pi) * pitch\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def mobius_strip(cls, radius=1, width=0.5, num_twists=1, t_values=None, num_points=100):\n        \"\"\"Create a Mobius strip in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            width (float, optional): _description_. Defaults to 0.5.\n            num_twists (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the Mobius strip of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        u_values = np.linspace(0, width, num=num_points)\n        u, t = np.meshgrid(u_values, t_values)\n        x_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.cos(t)\n        y_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.sin(t)\n        z_values = u * np.sin(t / 2) * np.cos(num_twists * t)\n        parametric_function = lambda t_values: (\n            x_values.flatten(),\n            y_values.flatten(),\n            z_values.flatten()\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def square(cls, side_length=1,t_values=None,num_points=100):\n        \"\"\"Create a square in 3D space.\n\n        Args:\n            side_length (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the square of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 1, num=num_points)\n        parametric_function = lambda t_values: (\n            side_length * (2 * (t_values &lt; 0.25) - 1),\n            side_length * (2 * (t_values &gt;= 0.25) &amp; (t_values &lt; 0.5)) - side_length,\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def trefoil(cls, radius=1, num_turns=1,t_values=None,num_points=100):\n        \"\"\"Create a trefoil knot in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            num_turns (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the trefoil knot of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        x_values = np.sin(t_values) + 2 * np.sin(2 * t_values)\n        y_values = np.cos(t_values) - 2 * np.cos(2 * t_values)\n        z_values = -np.sin(3 * t_values)\n        parametric_function = lambda t_values: (\n            radius * x_values,\n            radius * y_values,\n            radius * z_values\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def square(cls, side=1, t_values=None,num_points=100):\n        \"\"\"Create a square in 3D space.\n\n        Args:\n            side (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the square of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 4, num=num_points)\n        # Calculate x and y coordinates based on t_values\n        x_values = np.zeros_like(t_values)\n        y_values = np.zeros_like(t_values)\n        for i, t in enumerate(t_values):\n            if 0 &lt;= t &lt; 1:\n                x_values[i] = t * side\n                y_values[i] = 0\n            elif 1 &lt;= t &lt; 2:\n                x_values[i] = side\n                y_values[i] = (t - 1) * side\n            elif 2 &lt;= t &lt; 3:\n                x_values[i] = (3 - t) * side\n                y_values[i] = side\n            elif 3 &lt;= t &lt;= 4:\n                x_values[i] = 0\n                y_values[i] = (4 - t) * side\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (\n            x_values,\n            y_values,\n            z_values\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def heart(cls, a=1, b=1, c=1,t_values=None,num_points=100):\n        \"\"\"Create a heart shape in 3D space.\n\n        Args:\n            a (int, optional): _description_. Defaults to 1.\n            b (int, optional): _description_. Defaults to 1.\n            c (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the heart shape of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(-np.pi, np.pi, num=num_points)\n        x_values = a * np.sin(t_values) ** 3\n        y_values = b * np.cos(t_values) - c * np.cos(2 * t_values)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def ellipse(cls, a=1, b=1, t_values=None,num_points=100):\n        \"\"\"Create an ellipse in 3D space.\n\n        Args:\n            a (int, optional): _description_. Defaults to 1.\n            b (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the ellipse of shape (num_points, 3) \n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        x_values = a * np.cos(t_values)\n        y_values = b * np.sin(t_values)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def lemniscate_of_bernoulli(cls, a=1, b=1, t_values=None,num_points=100):\n        \"\"\"Create a lemniscate of Bernoulli in 3D space.\n\n        Args:\n            a (int, optional): _description_. Defaults to 1.\n            b (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the leminscate of Bernouli of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        x_values = a * np.sqrt(2) * np.cos(t_values) / (np.sin(t_values) ** 2 + 1)\n        y_values = b * np.sqrt(2) * np.cos(t_values) * np.sin(t_values) / (np.sin(t_values) ** 2 + 1)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def torus_helix(cls, R=1, r=2, num_windings=3, t_values=None, num_points=100):\n        \"\"\"Create a torus helix in 3D space.\n\n        Args:\n            R (int, optional): _description_. Defaults to 1.\n            r (int, optional): _description_. Defaults to 2.\n            num_windings (int, optional): _description_. Defaults to 3.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the torus helix of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n\n        parametric_function = lambda t_values: (\n            (R + r * np.cos(num_windings*t_values)) * np.cos( t_values),\n            (R + r * np.cos(num_windings*t_values)) * np.sin( t_values),\n            r * np.sin(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def bonus(cls, t_values=None,num_points=100):\n        \"\"\"Create a bonus shape in 3D space.\n\n        Credit: https://www.geogebra.org/m/pH8wD3rW, Author:Simona Riva\"\n\n        Args:\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the bonus function of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        t = t_values\n        parametric_function = lambda t: (\n                                        -(721*np.sin(t))/4 + 196/3*np.sin(2*t) - 86/3*np.sin(3*t) - 131/2*np.sin(4*t) + 477/14*np.sin(5*t) \n                                        + 27*np.sin(6*t) - 29/2*np.sin(7*t) + 68/5*np.sin(8*t) + 1/10*np.sin(9*t) + 23/4*np.sin(10*t) \n                                        - 19/2*np.sin(12*t) - 85/21*np.sin(13*t) + 2/3*np.sin(14*t) + 27/5*np.sin(15*t) + 7/4*np.sin(16*t) \n                                        + 17/9*np.sin(17*t) - 4*np.sin(18*t) - 1/2*np.sin(19*t) + 1/6*np.sin(20*t) + 6/7*np.sin(21*t) \n                                        - 1/8*np.sin(22*t) + 1/3*np.sin(23*t) + 3/2*np.sin(24*t) + 13/5*np.sin(25*t) + np.sin(26*t) \n                                        - 2*np.sin(27*t) + 3/5*np.sin(28*t) - 1/5*np.sin(29*t) + 1/5*np.sin(30*t) + (2337*np.cos(t))/8 \n                                        - 43/5*np.cos(2*t) + 322/5*np.cos(3*t) - 117/5*np.cos(4*t) - 26/5*np.cos(5*t) - 23/3*np.cos(6*t) \n                                        + 143/4*np.cos(7*t) - 11/4*np.cos(8*t) - 31/3*np.cos(9*t) - 13/4*np.cos(10*t) - 9/2*np.cos(11*t) \n                                        + 41/20*np.cos(12*t) + 8*np.cos(13*t) + 2/3*np.cos(14*t) + 6*np.cos(15*t) + 17/4*np.cos(16*t) \n                                        - 3/2*np.cos(17*t) - 29/10*np.cos(18*t) + 11/6*np.cos(19*t) + 12/5*np.cos(20*t) + 3/2*np.cos(21*t) \n                                        + 11/12*np.cos(22*t) - 4/5*np.cos(23*t) + np.cos(24*t) + 17/8*np.cos(25*t) - 7/2*np.cos(26*t) \n                                        - 5/6*np.cos(27*t) - 11/10*np.cos(28*t) + 1/2*np.cos(29*t) - 1/5*np.cos(30*t),\n                                        -(637/2)*np.sin(t) - (188/5)*np.sin(2*t) - (11/7)*np.sin(3*t) - (12/5)*np.sin(4*t) + (11/3)*np.sin(5*t)\n                                        - (37/4)*np.sin(6*t) + (8/3)*np.sin(7*t) + (65/6)*np.sin(8*t) - (32/5)*np.sin(9*t) - (41/4)*np.sin(10*t)\n                                        - (38/3)*np.sin(11*t) - (47/8)*np.sin(12*t) + (5/4)*np.sin(13*t) - (41/7)*np.sin(14*t) - (7/3)*np.sin(15*t)\n                                        - (13/7)*np.sin(16*t) + (17/4)*np.sin(17*t) - (9/4)*np.sin(18*t) + (8/9)*np.sin(19*t) + (3/5)*np.sin(20*t)\n                                        - (2/5)*np.sin(21*t) + (4/3)*np.sin(22*t) + (1/3)*np.sin(23*t) + (3/5)*np.sin(24*t) - (3/5)*np.sin(25*t)\n                                        + (6/5)*np.sin(26*t) - (1/5)*np.sin(27*t) + (10/9)*np.sin(28*t) + (1/3)*np.sin(29*t) - (3/4)*np.sin(30*t)\n                                        - (125/2)*np.cos(t) - (521/9)*np.cos(2*t) - (359/3)*np.cos(3*t) + (47/3)*np.cos(4*t) - (33/2)*np.cos(5*t)\n                                        - (5/4)*np.cos(6*t) + (31/8)*np.cos(7*t) + (9/10)*np.cos(8*t) - (119/4)*np.cos(9*t) - (17/2)*np.cos(10*t)\n                                        + (22/3)*np.cos(11*t) + (15/4)*np.cos(12*t) - (5/2)*np.cos(13*t) + (19/6)*np.cos(14*t) + (7/4)*np.cos(15*t)\n                                        + (31/4)*np.cos(16*t) - np.cos(17*t) + (11/10)*np.cos(18*t) - (2/3)*np.cos(19*t) + (13/3)*np.cos(20*t)\n                                        - (5/4)*np.cos(21*t) + (2/3)*np.cos(22*t) + (1/4)*np.cos(23*t) + (5/6)*np.cos(24*t) + (3/4)*np.cos(26*t)\n                                        - (1/2)*np.cos(27*t) - (1/10)*np.cos(28*t) - (1/3)*np.cos(29*t) - (1/19)*np.cos(30*t),\n                                        np.zeros_like(t))\n        return cls(parametric_function, t_values).points*0.1\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.bonus","title":"<code>bonus(t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a bonus shape in 3D space.</p> <p>Credit: https://www.geogebra.org/m/pH8wD3rW, Author:Simona Riva\"</p> <p>Parameters:</p> Name Type Description Default <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the bonus function of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef bonus(cls, t_values=None,num_points=100):\n    \"\"\"Create a bonus shape in 3D space.\n\n    Credit: https://www.geogebra.org/m/pH8wD3rW, Author:Simona Riva\"\n\n    Args:\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the bonus function of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    t = t_values\n    parametric_function = lambda t: (\n                                    -(721*np.sin(t))/4 + 196/3*np.sin(2*t) - 86/3*np.sin(3*t) - 131/2*np.sin(4*t) + 477/14*np.sin(5*t) \n                                    + 27*np.sin(6*t) - 29/2*np.sin(7*t) + 68/5*np.sin(8*t) + 1/10*np.sin(9*t) + 23/4*np.sin(10*t) \n                                    - 19/2*np.sin(12*t) - 85/21*np.sin(13*t) + 2/3*np.sin(14*t) + 27/5*np.sin(15*t) + 7/4*np.sin(16*t) \n                                    + 17/9*np.sin(17*t) - 4*np.sin(18*t) - 1/2*np.sin(19*t) + 1/6*np.sin(20*t) + 6/7*np.sin(21*t) \n                                    - 1/8*np.sin(22*t) + 1/3*np.sin(23*t) + 3/2*np.sin(24*t) + 13/5*np.sin(25*t) + np.sin(26*t) \n                                    - 2*np.sin(27*t) + 3/5*np.sin(28*t) - 1/5*np.sin(29*t) + 1/5*np.sin(30*t) + (2337*np.cos(t))/8 \n                                    - 43/5*np.cos(2*t) + 322/5*np.cos(3*t) - 117/5*np.cos(4*t) - 26/5*np.cos(5*t) - 23/3*np.cos(6*t) \n                                    + 143/4*np.cos(7*t) - 11/4*np.cos(8*t) - 31/3*np.cos(9*t) - 13/4*np.cos(10*t) - 9/2*np.cos(11*t) \n                                    + 41/20*np.cos(12*t) + 8*np.cos(13*t) + 2/3*np.cos(14*t) + 6*np.cos(15*t) + 17/4*np.cos(16*t) \n                                    - 3/2*np.cos(17*t) - 29/10*np.cos(18*t) + 11/6*np.cos(19*t) + 12/5*np.cos(20*t) + 3/2*np.cos(21*t) \n                                    + 11/12*np.cos(22*t) - 4/5*np.cos(23*t) + np.cos(24*t) + 17/8*np.cos(25*t) - 7/2*np.cos(26*t) \n                                    - 5/6*np.cos(27*t) - 11/10*np.cos(28*t) + 1/2*np.cos(29*t) - 1/5*np.cos(30*t),\n                                    -(637/2)*np.sin(t) - (188/5)*np.sin(2*t) - (11/7)*np.sin(3*t) - (12/5)*np.sin(4*t) + (11/3)*np.sin(5*t)\n                                    - (37/4)*np.sin(6*t) + (8/3)*np.sin(7*t) + (65/6)*np.sin(8*t) - (32/5)*np.sin(9*t) - (41/4)*np.sin(10*t)\n                                    - (38/3)*np.sin(11*t) - (47/8)*np.sin(12*t) + (5/4)*np.sin(13*t) - (41/7)*np.sin(14*t) - (7/3)*np.sin(15*t)\n                                    - (13/7)*np.sin(16*t) + (17/4)*np.sin(17*t) - (9/4)*np.sin(18*t) + (8/9)*np.sin(19*t) + (3/5)*np.sin(20*t)\n                                    - (2/5)*np.sin(21*t) + (4/3)*np.sin(22*t) + (1/3)*np.sin(23*t) + (3/5)*np.sin(24*t) - (3/5)*np.sin(25*t)\n                                    + (6/5)*np.sin(26*t) - (1/5)*np.sin(27*t) + (10/9)*np.sin(28*t) + (1/3)*np.sin(29*t) - (3/4)*np.sin(30*t)\n                                    - (125/2)*np.cos(t) - (521/9)*np.cos(2*t) - (359/3)*np.cos(3*t) + (47/3)*np.cos(4*t) - (33/2)*np.cos(5*t)\n                                    - (5/4)*np.cos(6*t) + (31/8)*np.cos(7*t) + (9/10)*np.cos(8*t) - (119/4)*np.cos(9*t) - (17/2)*np.cos(10*t)\n                                    + (22/3)*np.cos(11*t) + (15/4)*np.cos(12*t) - (5/2)*np.cos(13*t) + (19/6)*np.cos(14*t) + (7/4)*np.cos(15*t)\n                                    + (31/4)*np.cos(16*t) - np.cos(17*t) + (11/10)*np.cos(18*t) - (2/3)*np.cos(19*t) + (13/3)*np.cos(20*t)\n                                    - (5/4)*np.cos(21*t) + (2/3)*np.cos(22*t) + (1/4)*np.cos(23*t) + (5/6)*np.cos(24*t) + (3/4)*np.cos(26*t)\n                                    - (1/2)*np.cos(27*t) - (1/10)*np.cos(28*t) - (1/3)*np.cos(29*t) - (1/19)*np.cos(30*t),\n                                    np.zeros_like(t))\n    return cls(parametric_function, t_values).points*0.1\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.circle","title":"<code>circle(radius=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a circle in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the circle of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef circle(cls, radius=1, t_values=None, num_points=100):\n    \"\"\"Create a circle in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the circle of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * np.cos(t_values),\n        radius * np.sin(t_values),\n        np.zeros_like(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.ellipse","title":"<code>ellipse(a=1, b=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create an ellipse in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>b</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the ellipse of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef ellipse(cls, a=1, b=1, t_values=None,num_points=100):\n    \"\"\"Create an ellipse in 3D space.\n\n    Args:\n        a (int, optional): _description_. Defaults to 1.\n        b (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the ellipse of shape (num_points, 3) \n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    x_values = a * np.cos(t_values)\n    y_values = b * np.sin(t_values)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.heart","title":"<code>heart(a=1, b=1, c=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a heart shape in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>b</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>c</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the heart shape of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef heart(cls, a=1, b=1, c=1,t_values=None,num_points=100):\n    \"\"\"Create a heart shape in 3D space.\n\n    Args:\n        a (int, optional): _description_. Defaults to 1.\n        b (int, optional): _description_. Defaults to 1.\n        c (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the heart shape of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(-np.pi, np.pi, num=num_points)\n    x_values = a * np.sin(t_values) ** 3\n    y_values = b * np.cos(t_values) - c * np.cos(2 * t_values)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.helix","title":"<code>helix(radius=1, pitch=1, height=1, num_turns=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a helix in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>pitch</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>height</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the helix of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef helix(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n    \"\"\"Create a helix in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        pitch (int, optional): _description_. Defaults to 1.\n        height (int, optional): _description_. Defaults to 1.\n        num_turns (int, optional): _description_. Defaults to 1.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the helix of shape (num_points, 3)\n    \"\"\"\n    t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * np.cos(t_values),\n        radius * np.sin(t_values),\n        height * t_values / (2 * np.pi) - pitch * num_turns * t_values / (2 * np.pi)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.lemniscate_of_bernoulli","title":"<code>lemniscate_of_bernoulli(a=1, b=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a lemniscate of Bernoulli in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>b</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the leminscate of Bernouli of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef lemniscate_of_bernoulli(cls, a=1, b=1, t_values=None,num_points=100):\n    \"\"\"Create a lemniscate of Bernoulli in 3D space.\n\n    Args:\n        a (int, optional): _description_. Defaults to 1.\n        b (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the leminscate of Bernouli of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    x_values = a * np.sqrt(2) * np.cos(t_values) / (np.sin(t_values) ** 2 + 1)\n    y_values = b * np.sqrt(2) * np.cos(t_values) * np.sin(t_values) / (np.sin(t_values) ** 2 + 1)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.line","title":"<code>line(length=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a line in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the line of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef line(cls, length=1, num_points=100):\n    \"\"\"Create a line in 3D space.\n\n    Args:\n        length (int, optional): _description_. Defaults to 1.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the line of shape (num_points, 3)\n    \"\"\"\n    t_values = np.linspace(0, 1, num=num_points)\n    parametric_function = lambda t_values: (\n        t_values * length,\n        np.zeros_like(t_values),\n        np.zeros_like(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.mobius_strip","title":"<code>mobius_strip(radius=1, width=0.5, num_twists=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a Mobius strip in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>width</code> <code>float</code> <p>description. Defaults to 0.5.</p> <code>0.5</code> <code>num_twists</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the Mobius strip of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef mobius_strip(cls, radius=1, width=0.5, num_twists=1, t_values=None, num_points=100):\n    \"\"\"Create a Mobius strip in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        width (float, optional): _description_. Defaults to 0.5.\n        num_twists (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the Mobius strip of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    u_values = np.linspace(0, width, num=num_points)\n    u, t = np.meshgrid(u_values, t_values)\n    x_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.cos(t)\n    y_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.sin(t)\n    z_values = u * np.sin(t / 2) * np.cos(num_twists * t)\n    parametric_function = lambda t_values: (\n        x_values.flatten(),\n        y_values.flatten(),\n        z_values.flatten()\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.spiral","title":"<code>spiral(radius=1, pitch=1, height=1, num_turns=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a spiral in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>pitch</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>height</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the spiral of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef spiral(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n    \"\"\"Create a spiral in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        pitch (int, optional): _description_. Defaults to 1.\n        height (int, optional): _description_. Defaults to 1.\n        num_turns (int, optional): _description_. Defaults to 1.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the spiral of shape (num_points, 3)\n    \"\"\"\n    t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * t_values * np.cos(t_values),\n        radius * t_values * np.sin(t_values),\n        height * t_values / (2 * np.pi) * pitch\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.square","title":"<code>square(side=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a square in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the square of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef square(cls, side=1, t_values=None,num_points=100):\n    \"\"\"Create a square in 3D space.\n\n    Args:\n        side (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the square of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 4, num=num_points)\n    # Calculate x and y coordinates based on t_values\n    x_values = np.zeros_like(t_values)\n    y_values = np.zeros_like(t_values)\n    for i, t in enumerate(t_values):\n        if 0 &lt;= t &lt; 1:\n            x_values[i] = t * side\n            y_values[i] = 0\n        elif 1 &lt;= t &lt; 2:\n            x_values[i] = side\n            y_values[i] = (t - 1) * side\n        elif 2 &lt;= t &lt; 3:\n            x_values[i] = (3 - t) * side\n            y_values[i] = side\n        elif 3 &lt;= t &lt;= 4:\n            x_values[i] = 0\n            y_values[i] = (4 - t) * side\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (\n        x_values,\n        y_values,\n        z_values\n    )\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.torus_helix","title":"<code>torus_helix(R=1, r=2, num_windings=3, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a torus helix in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>R</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>r</code> <code>int</code> <p>description. Defaults to 2.</p> <code>2</code> <code>num_windings</code> <code>int</code> <p>description. Defaults to 3.</p> <code>3</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the torus helix of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef torus_helix(cls, R=1, r=2, num_windings=3, t_values=None, num_points=100):\n    \"\"\"Create a torus helix in 3D space.\n\n    Args:\n        R (int, optional): _description_. Defaults to 1.\n        r (int, optional): _description_. Defaults to 2.\n        num_windings (int, optional): _description_. Defaults to 3.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the torus helix of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n\n    parametric_function = lambda t_values: (\n        (R + r * np.cos(num_windings*t_values)) * np.cos( t_values),\n        (R + r * np.cos(num_windings*t_values)) * np.sin( t_values),\n        r * np.sin(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes-reference/#pymdna.utils.Shapes.trefoil","title":"<code>trefoil(radius=1, num_turns=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a trefoil knot in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the trefoil knot of shape (num_points, 3)</p> Source code in <code>src/pymdna/utils.py</code> <pre><code>@classmethod\ndef trefoil(cls, radius=1, num_turns=1,t_values=None,num_points=100):\n    \"\"\"Create a trefoil knot in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        num_turns (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the trefoil knot of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    x_values = np.sin(t_values) + 2 * np.sin(2 * t_values)\n    y_values = np.cos(t_values) - 2 * np.cos(2 * t_values)\n    z_values = -np.sin(3 * t_values)\n    parametric_function = lambda t_values: (\n        radius * x_values,\n        radius * y_values,\n        radius * z_values\n    )\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"explanation/explanation/","title":"Explanation","text":""},{"location":"explanation/explanation/#background-and-context","title":"Background and Context","text":"<p>MDNA was developed to address a critical need in molecular dynamics (MD) simulations, particularly for generating and analyzing DNA structures and DNA-protein complexes. Unlike proteins, which have abundant experimental data for structure generation, DNA often requires construction from scratch, especially when dealing with non-canonical bases or specific structural motifs like Hoogsteen base pairs. MDNA bridges this gap by providing a versatile and accurate tool that simplifies the generation of complex DNA structures and enhances the precision of MD simulations.</p> <p>The development of MDNA was driven by the limitations of existing tools that either lacked flexibility or required specialized knowledge to use effectively. These tools often struggled with complex DNA configurations or integrating into broader research workflows. MDNA was designed as an all-in-one solution that consolidates key functionalities into a cohesive Python ecosystem, making DNA structure generation and analysis more accessible and efficient.</p>"},{"location":"explanation/explanation/#working-with-mdna","title":"Working with MDNA","text":"<p>MDNA offers robust capabilities for generating and analyzing DNA structures. Researchers can create DNA models by specifying sequences, topologies, or custom shapes, and manipulate configurations to study specific structural motifs. Seamless integration with tools like MDTraj and OpenMM ensures a streamlined workflow from structure generation to MD simulations.</p> <p>MDNA enables researchers to explore the dynamic behavior of DNA and its interactions by providing tools to analyze rigid base parameters, linking numbers, and more. This comprehensive approach helps bridge the gap between DNA's static structure and its dynamic functions, making MDNA an invaluable resource for structural biology, genomics, and beyond.</p>"},{"location":"modules/modules-analyse/","title":"Analysis Modules","text":""},{"location":"modules/modules-analyse/#pymdna.nucleic","title":"<code>pymdna.nucleic</code>","text":""},{"location":"modules/modules-analyse/#pymdna.nucleic.compute_rigid_parameters","title":"<code>compute_rigid_parameters(traj, chainids=[0, 1])</code>","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example <p>Compute the rigid base parameters of a DNA structure ```python traj = md.load('dna.pdb') rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1]) ````</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1]):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        Compute the rigid base parameters of a DNA structure\n        ```python\n        traj = md.load('dna.pdb')\n        rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1])\n        ````\n    \"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids)\n</code></pre>"},{"location":"modules/modules-analyse/#pymdna.nucleic.compute_linking_number","title":"<code>compute_linking_number(traj, chainids=[0, 1])</code>","text":"<p>Compute the linking number of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_linking_number(traj, chainids=[0,1]):\n    \"\"\"Compute the linking number of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/modules-analyse/#pymdna.nucleic.compute_curvature","title":"<code>compute_curvature(traj, chainids=[0, 1])</code>","text":"<p>Compute the curvature of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_curvature(traj, chainids=[0,1]):\n    \"\"\"Compute the curvature of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/modules-analyse/#pymdna.nucleic.compute_groove_width","title":"<code>compute_groove_width(traj, chainids=[0, 1])</code>","text":"<p>Compute the groove width of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_groove_width(traj, chainids=[0,1]):\n    \"\"\"Compute the groove width of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/modules-build/","title":"Build","text":"<p>Contains mdna DNA structure with reference frames and trajectory</p>"},{"location":"modules/modules-build/#pymdna.nucleic.make","title":"<code>make(sequence=None, control_points=None, circular=False, closed=False, n_bp=None, dLk=None)</code>","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Example <p>Generate a DNA structure from a sequence <pre><code>dna = make(sequence='CGCGAATTCGCG', control_points=None, circular=False, closed=False, n_bp=None, dLk=None)\n</code></pre></p>"},{"location":"modules/modules-build/#pymdna.nucleic.connect","title":"<code>connect(Nucleic0, Nucleic1, sequence=None, n_bp=None, leader=0, frame=-1, margin=1, minimize=True, exvol_rad=0.0, temperature=300, control_points=None, index=0)</code>","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str or List</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Notes <ul> <li>The minimization does not use excluded volume interactions by default.This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</li> </ul> Example <p>Connect two DNA structures <pre><code>dna = connect(Nucleic0, Nucleic1, margin=5)\n</code></pre></p>"},{"location":"modules/modules-build/#pymdna.nucleic.Nucleic.extend","title":"<code>extend(n_bp=None, sequence=None, fixed_endpoints=False, forward=True, frame=-1, shape=None, margin=1, minimize=True, plot=False, exvol_rad=2.0, temperature=300)</code>","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure. Defaults to None.</p> <code>None</code> <code>sequence</code> <code>str or List</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <code>plot</code> <code>bool</code> <p>Whether to plot the Energy during minmization. Defaults to False.</p> <code>False</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults</p> <code>300</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> </ul> Example <p>Extend DNA structure <pre><code>nuc = mdna.make(n_bp=100)\nnuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n</code></pre></p>"},{"location":"modules/modules-core/","title":"Core","text":""},{"location":"modules/modules-core/#pymdna.nucleic","title":"<code>pymdna.nucleic</code>","text":""},{"location":"modules/modules-core/#pymdna.nucleic.load","title":"<code>load(traj=None, frames=None, sequence=None, chainids=[0, 1], circular=None, filename=None, top=None, stride=None)</code>","text":"<p>Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>frames</code> <code>array</code> <p>Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>sequence</code> <code>str</code> <p>DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>chainids</code> <code>list</code> <p>Chain IDs of the DNA structure. (default: [0,1])</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)</p> <code>None</code> <code>filename</code> <code>str</code> <p>The filename or filenames of the trajectory. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>top</code> <code>str</code> <p>The topology file of the trajectory. (default: None)</p> <code>None</code> <code>stride</code> <code>int</code> <p>The stride of the trajectory. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>The <code>traj</code> argument is prioritized over frames and sequence.</li> <li>If the <code>filename_or_filenames</code> argument is provided, the other arguments are ignored, except for the <code>top</code> and <code>stride</code> arguments and <code>chainids</code>.</li> </ul> Example <p>Load a DNA structure from a trajectory <pre><code>traj = md.load('dna.pdb')\ndna = mdna.load(traj=traj, chainids=[0, 1])\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def load(traj=None, frames=None, sequence=None, chainids=[0,1], circular=None, filename=None, top=None, stride=None):\n    \"\"\"Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.\n\n    Args:\n        traj (object, optional): MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)\n        frames (np.array, optional): Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)\n        sequence (str, optional): DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)\n        chainids (list, optional): Chain IDs of the DNA structure. (default: [0,1])\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)\n        filename (str, optional): The filename or filenames of the trajectory. If provided, the traj and frames arguments are ignored. (default: None)\n        top (str, optional): The topology file of the trajectory. (default: None)\n        stride (int, optional): The stride of the trajectory. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - The `traj` argument is prioritized over frames and sequence.\n        - If the `filename_or_filenames` argument is provided, the other arguments are ignored, except for the `top` and `stride` arguments and `chainids`.\n\n    Example:\n        Load a DNA structure from a trajectory\n        ```python\n        traj = md.load('dna.pdb')\n        dna = mdna.load(traj=traj, chainids=[0, 1])\n        ```\n    \"\"\"\n    # Load the trajectory directly using MDtraj from a file\n    if filename is not None and top is None:\n        traj = md.load(filename_or_filenames=filename, stride=stride)\n    elif filename is not None and top is not None:\n        traj = md.load(filename_or_filenames=filename, top=top, stride=stride)\n\n    return Nucleic(sequence=sequence, n_bp=None, traj=traj, frames=frames, chainids=chainids, circular=None)\n</code></pre>"},{"location":"modules/modules-modify/","title":"Modify","text":""},{"location":"modules/modules-modify/#pymdna.nucleic.Nucleic","title":"<code>pymdna.nucleic.Nucleic</code>","text":"<p>Contains mdna DNA structure with reference frames and trajectory</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>class Nucleic:\n\n    \"\"\"Contains mdna DNA structure with reference frames and trajectory\"\"\"\n\n    def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=[0,1], circular=None):\n            \"\"\"Initializes the DNA structure.\n\n            Args:\n                sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n                n_bp (int): The number of base pairs. Default is None.\n                traj (object): The MDTraj trajectory. Default is None.\n                frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n                chainids (list): The chain IDs. Default is [0,1].\n                circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n            Raises:\n                ValueError: If both traj and frames are provided.\n                ValueError: If frames have an invalid shape.\n                ValueError: If the number of base pairs in the sequence and frames do not match.\n                ValueError: If neither traj nor frames are provided.\n\n            Notes:\n                - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n                - If frames is provided, n_bp will be determined from the shape of frames.\n                - If sequence is provided, it will be checked against the number of base pairs.\n\n            Attributes:\n                sequence (str): The DNA sequence.\n                n_bp (int): The number of base pairs.\n                traj (object): The MDTraj trajectory.\n                frames (np.ndarray): The reference frames of the DNA structure.\n                chainids (list): The chain IDs.\n                circular (bool): A flag that indicates if the structure is circular/closed.\n                rigid (None): A container for rigid base parameters class output.\n                minimizer (None): A container for minimizer class output.\n            \"\"\"\n            # Check for trajectory\n            if traj is not None:\n                if frames is not None:\n                    raise ValueError('Provide either a trajectory or reference frames, not both')\n                # Extract sequence from the trajectory\n                sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n                n_bp = len(sequence)\n                sequence = ''.join(sequence)\n                frames = None  # Nucleic class will handle extraction from traj\n\n            # Check for reference frames\n            elif frames is not None:\n                if frames.ndim == 3:\n                    # Case (n_bp, 4, 3)\n                    frames = np.expand_dims(frames, axis=1)\n                if frames.ndim != 4:\n                    raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n                n_bp = frames.shape[0]\n                if sequence is not None:\n                    if len(sequence) != n_bp:\n                        raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                    else:\n                        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n            else:\n                raise ValueError('Provide either a trajectory or reference frames')\n\n            self.sequence, self.n_bp = sequence, n_bp\n            self.traj = traj\n            self.frames = frames\n            self.chainids = chainids\n            self.circular = self._is_circular() if circular is None else circular \n            self.rigid = None # Container for rigid base parameters class output\n            self.minimizer = None # Container for minimizer class output\n            self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n\n    def describe(self):\n        \"\"\"Print the DNA structure information\"\"\"\n        print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n        print('Sequence:', ''.join(self.sequence))\n\n        if self.traj is not None:\n            print('Trajectory:',self.traj)\n        else:\n            print('Trajectory not loaded')\n\n        if self.frames is not None:\n            print('Frames: ', self.frames.shape)\n        else:\n            print('Frames not loaded')\n\n    def _frames_to_traj(self, frame=-1):\n        \"\"\"Convert reference frames to trajectory\"\"\"\n        if self.frames is None:\n            raise ValueError('Load reference frames first')\n        self.traj = None\n        generator = StructureGenerator(frames=self.frames[:,frame,:,:], sequence=self.sequence, circular=self.circular)\n        self.traj = generator.get_traj()\n\n    def _traj_to_frames(self):\n        \"\"\"Convert trajectory to reference frames\"\"\"\n        if self.traj is None:\n            raise ValueError('Load trajectory first')\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        self.frames =self.rigid.frames\n\n    def get_frames(self):\n        \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n        Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n        where n_frames is the number of frames, n_bp is the number of base pairs, \n        and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n        Returns:\n            frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n        if self.frames is None:\n            self._traj_to_frames()\n        return self.frames\n\n    def get_traj(self):\n        \"\"\"Get the trajectory of the current state of the DNA structure\n        Returns:\n            MDtraj object\"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n\n        if self.traj.n_atoms &gt; 99999:\n            print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n        return self.traj\n\n    def get_rigid_object(self):\n        \"\"\"Get the rigid base class object of the DNA structure\n\n        Returns:\n            NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n        if self.rigid is None and self.traj is not None:\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        elif self.rigid is None and self.traj is None:\n            self._frames_to_traj()\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        else:\n            return self.rigid\n\n    def get_parameters(self, step : bool = False, base : bool = False):\n        \"\"\"By default retuns all the parameters of the DNA structure.\n        Use arguments to get a specific parameter group of the DNA structure.\n\n        Args:\n            step (bool, optional): Returns only the step parameters of consequative bases. Defaults to False.\n            base (bool, optional): Returns onlt the base pair parameters of opposing bases. Defaults to False.\n\n        Returns:\n            (parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameters(step=step, base=base)\n\n    def get_parameter(self, parameter_name : str):\n        \"\"\"Get a specific parameter from the rigid base parameters class object of the DNA structure\n\n        Args:\n            parameter_name (str): The name of the parameter to retrieve.\n\n        Notes:\n            The following parameters can be retrieved:\n            - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n        Returns:\n            np.ndarray: The parameter values of the DNA structure.\"\"\"\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameter(parameter_name)\n\n    def get_base_frames(self):\n        \"\"\"Get the base reference frames of the DNA structure\n\n        Returns:\n            dict: A dictionary containing the base reference frames of the DNA structure. \n              The keys are residue topologies of the MDTraj object (traj.top.residues) and the values are the reference frames in shape (n_frames, 4, 3), \n              where the rows represent the origin, b_D, b_L, and b_N vectors.\"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_base_reference_frames()\n\n\n    def _is_circular(self, frame=0):\n        \"\"\"Detects if the DNA structure is circular for a given chain and frame.\n\n        Args:\n            frame (int, optional): Frame index to check. Default is 0.\n\n        Returns:\n            bool: True if the DNA is circular, False otherwise.\n        \"\"\"\n        if self.frames is None:\n            self._traj_to_frames()\n\n        start = self.frames[0, frame, 0]\n        end = self.frames[-1, frame, 0]\n        distance = np.linalg.norm(start - end)\n\n        # 0.34 nm is roughly the distance between base pairs and 20 is the minimum number of base pairs for circular DNA\n        return distance &lt; 1 and self.frames.shape[0] &gt; 20\n\n    def _plot_chain(self, ax, traj, chainid, frame, lw=1, markersize=2, color='k'):\n        \"\"\"Plot the DNA structure of a chain\"\"\"\n        phosphor = traj.top.select(f'name P and chainid {chainid}')\n        x = traj.xyz[frame, phosphor, 0]\n        y = traj.xyz[frame, phosphor, 1]\n        z = traj.xyz[frame, phosphor, 2]\n\n        ax.plot(x, y, z, '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n        if self.circular:\n            # Connect the last point to the first point\n            ax.plot([x[-1], x[0]], [y[-1], y[0]], [z[-1], z[0]], '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n    def _plot_helical_axis(self, ax, frame, lw=1, color='k'):\n        helical_axis = self.frames[:,frame,0]\n        ax.plot(helical_axis[:,0],helical_axis[:,1],helical_axis[:,2],':',c=color,lw=lw*0.7)\n        if self.circular:\n            ax.plot([helical_axis[-1,0],helical_axis[0,0]],[helical_axis[-1,1],helical_axis[0,1]],[helical_axis[-1,2],helical_axis[0,2]],':',c='k',lw=lw*0.7)\n\n    def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey',color_axis='k'):\n        \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n        Args:\n            ax (object, optional): Matplotlib axis. Default is None.\n            fig (object, optional): Figure axis. Default is None.\n            save (bool, optional): Save image as png. Default is False.\n            frame (int, optional): Index of trajectory to visualize. Default is -1.\n            markersize (int, optional): Width of backbone plot. Default is 2.\n            lw (int, optional): Line width of plots. Default is 1.\n            helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n            backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n            lead (bool, optional): Plot leading strand. Default is False.\n            anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n            triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n            length (float, optional): Length of triad vectors. Default is 0.23.\n            color_lead (str, optional): Color of the leading strand. Default is 'k'.\n            color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n            color_axis (str, optional): Color of the helical axis. Default is 'k'.\n\n        Notes:\n            - The function draws a 3D representation of the DNA structure using matplotlib.\n            - The function requires either the trajectory or reference frames to be loaded before calling.\n\n        Example:\n            Make a DNA structure and draw the 3D representation\n            ```python\n            dna = nuc.make(sequence='CGCGAATTCGCG')\n            dna.draw()\n            ```\n        \"\"\"\n\n        # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n        # in shape (time/n_frames, n_bp, 4, 3)\n\n        if self.traj is None:\n            self._frames_to_traj()\n        elif self.frames is None:\n            self._traj_to_frames()\n\n        if fig is None and ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n\n        if backbone:\n            lead = True\n            anti = True\n        if lead:\n            self._plot_chain(ax, self.traj, self.chainids[0], frame=frame, markersize=markersize, lw=lw, color=color_lead)\n        if anti:\n            self._plot_chain(ax, self.traj, self.chainids[1], frame=frame, markersize=markersize, lw=lw, color=color_anti)\n        if helical_axis:\n            self._plot_helical_axis(ax, frame=frame, lw=lw, color=color_axis)\n        if triads:\n            for triad in self.frames:\n                triad = triad[frame]\n                ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n        ax.axis('equal')\n        ax.axis('off')\n        if save:\n            fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n\n    def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 5, plot : bool = False):\n        \"\"\"\n        Minimize the DNA structure. This method updates the  of the DNA structure.\n\n        Args:\n            frame (int): The trajectory frame to minimize. Defaults to -1.\n            simple (bool): Whether to use simple equilibration. Defaults to False.\n            equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n            endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n            fixed (list): List of fixed base pairs. Defaults to an empty list.\n            exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n            temperature (int): Temperature for equilibration. Defaults to 300.\n            dump_every (int): Frequency of dumping frames. Defaults to 5.\n            plot (bool): Whether to plot the energy. Defaults to False.\n\n        Additional keyword arguments can be provided and will be passed to the minimizer.\n\n        Notes:\n\n            For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n            This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n            The other option is to use the full equilibration, which is based on the actual energy of the system.\n            We assume the energy to converge exponentially to the equilibrated value.\n            This works fairly well for most examples I checked but is not entirely robust. \n            Considering autocorrelation has some issues when there are relaxations at different timescales.\n            Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n            It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n        Example:\n            Load a DNA structure and minimize it\n            ```python\n            nuc = mdna.load(traj)\n            nuc.minimize(temperature=310, exvol_rad=2.0)\n            ```\n        \"\"\"\n        self.minimizer = Minimizer(self)\n        self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n        # Update the reference frames\n        self._frames_to_traj()\n\n    def get_MC_traj(self):\n        \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n        if self.minimizer is None:\n            raise ValueError('Run minimization first')\n        return self.minimizer.get_MC_traj()\n\n    def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n        \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n        The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n        Args:\n            mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n            complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n            frame (int, optional): The frame to mutate. Defaults to -1.\n            verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n        Raises:\n            ValueError: If no mutation dictionary is provided.\n\n        Notes:\n            - Valid nucleobases for mutations include:\n                - Canonical bases: A, T, G, C, U\n                - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n                - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n                - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n        Example:\n            Create a DNA object \n            ```python\n            dna = DNA()\n            mutations = {0: 'A', 1: 'T', 2: 'G'}\n            dna.mutate(mutations=mutations, complementary=True, frame=-1)\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if mutations is None:\n            raise ValueError('Provide a mutation dictionary')\n\n        # TODO: Check if valid letters in mutations dictionary\n\n        mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n        self.traj = mutant.get_traj()\n        # Update sequence\n        self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n\n\n    def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n            \"\"\"Flips the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n                deg (int): The degrees to flip. Defaults to 180.\n                frame (int): The frame to flip. Defaults to -1.\n\n            Raises:\n                ValueError: If no fliplist is provided.\n\n            Notes:\n                - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n\n            Example:\n                Flip DNA\n                ```python\n                dna = mdna.make('GCAAAGC)\n                dna.flip(fliplist=[3,4], deg=180)\n                ```\n\n            \"\"\"\n\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(fliplist) == 0:\n                raise ValueError('Provide a fliplist')\n\n            flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n            self.traj = flipper.get_traj()\n\n    def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n            \"\"\"Methylate the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                methylations (list): List of base pairs to methylate. Defaults to [].\n                CpG (bool): Whether to methylate CpG sites. Defaults to False.\n                leading_strand (int): The leading strand to methylate. Defaults to 0.\n                frame (int): The frame to methylate. Defaults to -1.\n\n            Raises:\n                ValueError: If the DNA structure is not loaded.\n                ValueError: If the methylations list is empty.\n\n            Notes:\n                Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n\n            Example:\n                Methylate DNA\n                ```python\n                dna = mdna.make('GCGCGCGAGCGA)\n                dna.metyhlate(fliplist=[3,4])\n                ```\n            \"\"\"\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(methylations) == 0 and not CpG:\n                raise ValueError('Provide a non-empty methylations list')\n\n            methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n            self.traj = methylator.get_traj()\n\n    def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n        \"\"\"Extend the DNA structure in the specified direction.\n            The method updates the attributes of the DNA object.\n\n\n        Args:\n            n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n            sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n            fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n            forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n            frame (int, optional): The time frame to extend. Defaults to -1.\n            shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n            margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n            minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n            plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n            exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n            temperature (int, optional): Temperature for equilibration. Defaults\n\n        Raises:\n            ValueError: If the DNA structure is circular and cannot be extended.\n            ValueError: If neither a fixed endpoint nor a length is specified for extension.\n            ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n        Notes:\n            - If the DNA structure is circular, it cannot be extended.\n\n        Example:\n            Extend DNA structure\n            ```python\n            nuc = mdna.make(n_bp=100)\n            nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n            ```\n        \"\"\"\n        if self.circular:\n            raise ValueError('Cannot extend circular DNA structure')  \n        if self.traj is None:\n            self._frames_to_traj()\n        if shape is None:\n            shape = Shapes.line(length=1)\n        if self.frames is None:\n            self._traj_to_frames()\n\n        # Check the input sequence and number of base pairs\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n        extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n        # Also update, n_bp, sequence, frames etc\n        self.nuc = extender.nuc\n\n        if minimize:\n            self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n        # Update attributes\n        self.sequence = self.nuc.sequence\n        self.traj = self.nuc.get_traj()\n        self.frames = self.nuc.get_frames()\n        self.n_bp = self.nuc.n_bp\n\n    def invert(self):\n        \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n         The method updates attributes of the DNA object.\n\n         Raises:\n            NotImplementedError.\"\"\"\n        raise NotImplementedError('Not implemented yet')\n\n    def get_linking_number(self, frame : int = -1):\n        \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n        Args:\n            frame (int, optional): Time frame of trajectory, by default -1\n\n        Returns:\n            linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n        \"\"\"\n        try:\n            from pmcpy import pmcpy\n        except ImportError:\n            pmcpy_available = False\n            print(\"pmcpy is not installed. You shall not pass.\")\n\n        if self.frames is None:\n                self._traj_to_frames()\n        frames = self.frames[:,frame,:,:]\n        positions = frames[:,0]\n        triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n        writhe = pylk.writhe(positions)\n        lk = pylk.triads2link(positions, triads)\n        return np.array([lk, writhe, lk - writhe])\n\n    def save_pdb(self, filename : str = None, frame : int = -1):\n        \"\"\"Save the DNA structure as a pdb file.\n\n        Args:\n            filename (str, optional): Filename to save the pdb file. Defaults to None.\n            frame (int, optional): If the trajectory has multiple frames, specify the frame to save. Defaults to -1.\n        \"\"\"\n\n        # check if traj\n        if self.traj is None:\n            self._frames_to_traj()\n        if filename is None:\n            filename = 'my_mdna'\n        self.traj[frame].save(f'{filename}.pdb')\n</code></pre>"},{"location":"modules/modules-modify/#pymdna.nucleic.Nucleic.mutate","title":"<code>mutate(mutations=None, complementary=True, frame=-1, verbose=False)</code>","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the mutated sequence. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> Example <p>Create a DNA object  <pre><code>dna = DNA()\nmutations = {0: 'A', 1: 'T', 2: 'G'}\ndna.mutate(mutations=mutations, complementary=True, frame=-1)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n        verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Example:\n        Create a DNA object \n        ```python\n        dna = DNA()\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n        ```\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"modules/modules-modify/#pymdna.nucleic.Nucleic.methylate","title":"<code>methylate(methylations=[], CpG=False, leading_strand=0, frame=-1)</code>","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <p>Using the <code>CpG</code> flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.</p> Example <p>Methylate DNA <pre><code>dna = mdna.make('GCGCGCGAGCGA)\ndna.metyhlate(fliplist=[3,4])\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n\n        Example:\n            Methylate DNA\n            ```python\n            dna = mdna.make('GCGCGCGAGCGA)\n            dna.metyhlate(fliplist=[3,4])\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(methylations) == 0 and not CpG:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre>"},{"location":"modules/modules-modify/#pymdna.nucleic.Nucleic.flip","title":"<code>flip(fliplist=[], deg=180, frame=-1)</code>","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <ul> <li>Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.</li> </ul> Example <p>Flip DNA <pre><code>dna = mdna.make('GCAAAGC)\ndna.flip(fliplist=[3,4], deg=180)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n\n        Example:\n            Flip DNA\n            ```python\n            dna = mdna.make('GCAAAGC)\n            dna.flip(fliplist=[3,4], deg=180)\n            ```\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"modules/modules/","title":"Reference","text":""},{"location":"modules/modules/#build","title":"Build","text":""},{"location":"modules/modules/#make","title":"Make","text":""},{"location":"modules/modules/#pymdna.nucleic.make","title":"<code>pymdna.nucleic.make(sequence=None, control_points=None, circular=False, closed=False, n_bp=None, dLk=None)</code>","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Example <p>Generate a DNA structure from a sequence <pre><code>dna = make(sequence='CGCGAATTCGCG', control_points=None, circular=False, closed=False, n_bp=None, dLk=None)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def make(sequence: str = None, control_points: np.ndarray = None, circular : bool = False, closed: bool = False, n_bp : int = None, dLk : int = None):\n    \"\"\"Generate a DNA structure from a given DNA sequence and control points.\n\n    Args:\n        sequence (str, optional): DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)\n        control_points (ndarray, optional): Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)\n        closed (bool, optional): Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)\n        n_bp (int, optional): Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)\n        dLk (int, optional): Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Example:\n        Generate a DNA structure from a sequence\n        ```python\n        dna = make(sequence='CGCGAATTCGCG', control_points=None, circular=False, closed=False, n_bp=None, dLk=None)\n        ```\n    \"\"\"\n\n    # Check if control points are provided, otherwise generate a straight line\n    skip = False\n    if control_points is not None:\n        if len(control_points) &lt; 4:\n            raise ValueError('Control points should contain at least 4 points [x, y, z]')\n        elif len(control_points) &gt; 4 and n_bp is None and sequence is None:\n            skip = True\n    elif control_points is None and circular:\n        control_points = Shapes.circle(radius=1)\n        closed = True\n    else:\n        # Linear strand of control points\n        control_points = Shapes.line(length=1)\n\n    if not skip:\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n        spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n    else:\n        spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=spline.n_bp)\n\n\n\n\n    return Nucleic(sequence=sequence, n_bp=n_bp, frames=spline.frames, chainids=[0, 1], circular=circular)\n</code></pre>"},{"location":"modules/modules/#extend","title":"Extend","text":""},{"location":"modules/modules/#pymdna.nucleic.Nucleic.extend","title":"<code>pymdna.nucleic.Nucleic.extend(n_bp=None, sequence=None, fixed_endpoints=False, forward=True, frame=-1, shape=None, margin=1, minimize=True, plot=False, exvol_rad=2.0, temperature=300)</code>","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure. Defaults to None.</p> <code>None</code> <code>sequence</code> <code>str or List</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <code>plot</code> <code>bool</code> <p>Whether to plot the Energy during minmization. Defaults to False.</p> <code>False</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults</p> <code>300</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> </ul> Example <p>Extend DNA structure <pre><code>nuc = mdna.make(n_bp=100)\nnuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n        sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n        plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n        exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n        temperature (int, optional): Temperature for equilibration. Defaults\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n\n    Example:\n        Extend DNA structure\n        ```python\n        nuc = mdna.make(n_bp=100)\n        nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n        ```\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')  \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"modules/modules/#connect","title":"Connect","text":""},{"location":"modules/modules/#pymdna.nucleic.connect","title":"<code>pymdna.nucleic.connect(Nucleic0, Nucleic1, sequence=None, n_bp=None, leader=0, frame=-1, margin=1, minimize=True, exvol_rad=0.0, temperature=300, control_points=None, index=0)</code>","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str or List</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Notes <ul> <li>The minimization does not use excluded volume interactions by default.This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</li> </ul> Example <p>Connect two DNA structures <pre><code>dna = connect(Nucleic0, Nucleic1, margin=5)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def connect(Nucleic0, Nucleic1, sequence: Union[str|List] = None, n_bp: int = None, leader: int = 0, frame: int = -1, margin: int = 1, minimize: bool = True, exvol_rad: float = 0.0, temperature: int = 300, control_points : np.ndarray = None, index : int = 0):  \n    \"\"\"Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.\n\n    The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure.\n    To connect the two strands, a straight line is interpolated between the two ends,\n    and the optimal number of base pairs is distributed to achieve a neutral twist.\n\n    Args:\n        Nucleic0 (Nucleic): First DNA structure to connect.\n        Nucleic1 (Nucleic): Second DNA structure to connect.\n        sequence (str or List, optional): DNA sequence of the connecting DNA strand. Default is None.\n        n_bp (int, optional): Number of base pairs of the connecting DNA strand. Default is None.\n        leader (int, optional): The leader of the DNA structure to connect. Default is 0.\n        frame (int, optional): The time frame to connect. Default is -1.\n        margin (int, optional): Number of base pairs to fix at the end. Default is 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure. Default is True.\n        exvol_rad (float, optional): Radius for excluded volume interactions during minimization. Default is 0.0.\n        temperature (int, optional): Temperature for minimization. Default is 300.\n\n    Returns:\n        Nucleic (object): DNA structure with the two DNA structures connected.\n\n    Raises:\n        ValueError: If either of the DNA structures is circular.\n\n    Notes:\n        - The minimization does not use excluded volume interactions by default.This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.\n\n    Example:\n        Connect two DNA structures\n        ```python\n        dna = connect(Nucleic0, Nucleic1, margin=5)\n        ```\n    \"\"\"\n    if Nucleic0.circular or Nucleic1.circular:\n        raise ValueError('Cannot connect circular DNA structures')\n\n    if (sequence is not None and n_bp is None) or (sequence is None and n_bp is not None) or (sequence is not None and n_bp is not None):\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    # Connect the two DNA structures\n    connector = Connector(Nucleic0, Nucleic1, sequence=sequence, n_bp=n_bp, leader=leader, frame=frame, margin=margin, control_points=control_points, index=index)\n    if minimize:\n        connector.connected_nuc.minimize(exvol_rad=exvol_rad, temperature=temperature, fixed=connector.fixed)\n    return connector.connected_nuc\n</code></pre>"},{"location":"modules/modules/#modify","title":"Modify","text":""},{"location":"modules/modules/#pymdna.nucleic.Nucleic.mutate","title":"<code>pymdna.nucleic.Nucleic.mutate(mutations=None, complementary=True, frame=-1, verbose=False)</code>","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the mutated sequence. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> Example <p>Create a DNA object  <pre><code>dna = DNA()\nmutations = {0: 'A', 1: 'T', 2: 'G'}\ndna.mutate(mutations=mutations, complementary=True, frame=-1)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n        verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Example:\n        Create a DNA object \n        ```python\n        dna = DNA()\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n        ```\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"modules/modules/#pymdna.nucleic.Nucleic.methylate","title":"<code>pymdna.nucleic.Nucleic.methylate(methylations=[], CpG=False, leading_strand=0, frame=-1)</code>","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <p>Using the <code>CpG</code> flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.</p> Example <p>Methylate DNA <pre><code>dna = mdna.make('GCGCGCGAGCGA)\ndna.metyhlate(fliplist=[3,4])\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n\n        Example:\n            Methylate DNA\n            ```python\n            dna = mdna.make('GCGCGCGAGCGA)\n            dna.metyhlate(fliplist=[3,4])\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(methylations) == 0 and not CpG:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre>"},{"location":"modules/modules/#pymdna.nucleic.Nucleic.flip","title":"<code>pymdna.nucleic.Nucleic.flip(fliplist=[], deg=180, frame=-1)</code>","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <ul> <li>Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.</li> </ul> Example <p>Flip DNA <pre><code>dna = mdna.make('GCAAAGC)\ndna.flip(fliplist=[3,4], deg=180)\n</code></pre></p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n\n        Example:\n            Flip DNA\n            ```python\n            dna = mdna.make('GCAAAGC)\n            dna.flip(fliplist=[3,4], deg=180)\n            ```\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"modules/modules/#analyse-modules","title":"Analyse Modules","text":""},{"location":"modules/modules/#rigid-base-parameters","title":"Rigid Base Parameters","text":""},{"location":"modules/modules/#pymdna.nucleic.compute_rigid_parameters","title":"<code>pymdna.nucleic.compute_rigid_parameters(traj, chainids=[0, 1])</code>","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example <p>Compute the rigid base parameters of a DNA structure ```python traj = md.load('dna.pdb') rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1]) ````</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1]):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        Compute the rigid base parameters of a DNA structure\n        ```python\n        traj = md.load('dna.pdb')\n        rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1])\n        ````\n    \"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids)\n</code></pre>"},{"location":"modules/modules/#linking-number","title":"Linking Number","text":""},{"location":"modules/modules/#pymdna.nucleic.compute_linking_number","title":"<code>pymdna.nucleic.compute_linking_number(traj, chainids=[0, 1])</code>","text":"<p>Compute the linking number of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_linking_number(traj, chainids=[0,1]):\n    \"\"\"Compute the linking number of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/modules/#curvature","title":"Curvature","text":""},{"location":"modules/modules/#pymdna.nucleic.compute_curvature","title":"<code>pymdna.nucleic.compute_curvature(traj, chainids=[0, 1])</code>","text":"<p>Compute the curvature of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_curvature(traj, chainids=[0,1]):\n    \"\"\"Compute the curvature of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/modules/#groove-widths","title":"Groove Widths","text":""},{"location":"modules/modules/#pymdna.nucleic.compute_groove_width","title":"<code>pymdna.nucleic.compute_groove_width(traj, chainids=[0, 1])</code>","text":"<p>Compute the groove width of the DNA structure</p> Source code in <code>src/pymdna/nucleic.py</code> <pre><code>def compute_groove_width(traj, chainids=[0,1]):\n    \"\"\"Compute the groove width of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"notebooks/0_structure_tutorial/","title":"Structure Generation Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport nglview as nv\nimport seaborn as sns\n\n\n# # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction\n# # import pymdna as mdna\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n%load_ext autoreload\n%autoreload 2\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import nglview as nv import seaborn as sns   # # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction # # import pymdna as mdna import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna  %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Build DNA with nothing, will output Drew Dickerson dodecamer DDD sequence\ndna = mdna.make()\ndna.describe()\n</pre> # Build DNA with nothing, will output Drew Dickerson dodecamer DDD sequence dna = mdna.make() dna.describe() <pre>Default sequence: CGCGAATTCGCG\nNumber of base pairs: 12 \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\nDNA structure with 12 base pairs\nSequence: CGCGAATTCGCG\nTrajectory not loaded\nFrames:  (12, 1, 4, 3)\n</pre> In\u00a0[3]: Copied! <pre># Or provide a sequence\ndna = mdna.make(sequence='GCGCGCGCGC')\ndna.describe()\n</pre> # Or provide a sequence dna = mdna.make(sequence='GCGCGCGCGC') dna.describe() <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 10\n\nDNA structure with 10 base pairs\nSequence: GCGCGCGCGC\nTrajectory not loaded\nFrames:  (10, 1, 4, 3)\n</pre> In\u00a0[4]: Copied! <pre># Or provide a number of basepairs, resulting in a random sequence\ndna = mdna.make(n_bp=10)\ndna.describe()\n</pre> # Or provide a number of basepairs, resulting in a random sequence dna = mdna.make(n_bp=10) dna.describe() <pre>Random sequence: GTTAGTTCTC \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 10\n\nDNA structure with 10 base pairs\nSequence: GTTAGTTCTC\nTrajectory not loaded\nFrames:  (10, 1, 4, 3)\n</pre> In\u00a0[5]: Copied! <pre># Or make a minicircle DNA in circular form\ndna = mdna.make(n_bp=200, circular=True)\nprint('Lk, Wr, Tw', dna.get_linking_number())\ndna.draw()\n</pre> # Or make a minicircle DNA in circular form dna = mdna.make(n_bp=200, circular=True) print('Lk, Wr, Tw', dna.get_linking_number()) dna.draw() <pre>Random sequence: GAACCTCCATGATCAGATGCGACAGCTCCTTCTTTTATCGAGCACGACCTCTAAAACAAGTTATCTCCTGCGCTGAGACATGTCAAAAACCCAGAGAAATTCTCGGACGGGATACCATCGTCCCGAAGAGTTTGGCACCTGGTATCCGTTTACCCTGGCGACTCCTCCCACGGTCGAGTAGGTATGCGTGTAATATACTA \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 200\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 1.71 degrees\n\tNew twist angle per base pair: 36.0 \n\nusing numba\nLk, Wr, Tw [20.  0. 20.]\n</pre> In\u00a0[6]: Copied! <pre># Let's also minimize the DNA configuration\ndna.minimize()\n\n# See the final configuration\ndna.draw()\n\n# Or save it to a file\ndna.save_pdb('./pdbs/minimized_nbp_200_closed.pdb')\n</pre> # Let's also minimize the DNA configuration dna.minimize()  # See the final configuration dna.draw()  # Or save it to a file dna.save_pdb('./pdbs/minimized_nbp_200_closed.pdb') <pre>Minimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: True\n####################################\nInitiating Excluded Volume...\nEV_bead mismatch: including additional boundary checks.\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 29\n   bp per EV bead:     7\n   Effective size:     3.57\n   Exclusion distance: 4.0\n######################################\n</pre> In\u00a0[7]: Copied! <pre># Also change the linking number by under or overwinding the DNA using the dLk parameter\ndna = mdna.make(n_bp=200, circular=True, dLk=8)\ndna.describe()\ndna.get_linking_number()\n\n# Minimize the DNA configuration,\ndna.minimize(equilibrate_writhe=True)\ndna.get_linking_number()\n</pre> # Also change the linking number by under or overwinding the DNA using the dLk parameter dna = mdna.make(n_bp=200, circular=True, dLk=8) dna.describe() dna.get_linking_number()  # Minimize the DNA configuration, dna.minimize(equilibrate_writhe=True) dna.get_linking_number() <pre>Random sequence: GAATTCAGGCCCCTTCCTGCGTTCGAGGGCGCCCGTGTATTAGACCCTTGGCAGGCTAGTCTAGCTGGCCAAAGTGGCCAATTTGTTCGAGTATCTAAAATCCGGAGCTATCCAACCCCCTACTGCAATCCTTGCACTCGTACCGTGGAAGAGTAAGTAGAGGTGTTATTTTGGCACAACGCAGTATTCCCCGATCAATT \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 200\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 1.71 degrees\n\tNew twist angle per base pair: 36.0 \n\nAdjusting twist angles to match the given Delta linking number: 8\n\tCurrent twist number: 20.00\n\tOld twist angle per base pair: 36.00 degrees\n\tAdjusted twist angle per base pair: 50.40 degrees\n\nCircular DNA structure with 200 base pairs\nSequence: GAATTCAGGCCCCTTCCTGCGTTCGAGGGCGCCCGTGTATTAGACCCTTGGCAGGCTAGTCTAGCTGGCCAAAGTGGCCAATTTGTTCGAGTATCTAAAATCCGGAGCTATCCAACCCCCTACTGCAATCCTTGCACTCGTACCGTGGAAGAGTAAGTAGAGGTGTTATTTTGGCACAACGCAGTATTCCCCGATCAATT\nTrajectory not loaded\nFrames:  (200, 1, 4, 3)\nusing numba\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = True \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: True\n####################################\nInitiating Excluded Volume...\nEV_bead mismatch: including additional boundary checks.\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 29\n   bp per EV bead:     7\n   Effective size:     3.57\n   Exclusion distance: 4.0\n######################################\nE1 = 1668.43 kT\nE2 = 1477.60 kT\nwr_equi=False\nwr1 = 1.22\nwr2 = 2.26\nE = 1435.28 kT\nE_num_below=0\nwr = 2.29\nwr_num_below=0\nE = 1438.77 kT\nE_num_below=1\nwr = 2.45\nwr_num_below=0\nE = 1466.07 kT\nE_num_below=2\nwr = 2.45\nwr_num_below=1\nE = 1425.35 kT\nE_num_below=0\nwr = 2.50\nwr_num_below=0\nE = 1412.55 kT\nE_num_below=0\nwr = 2.47\nwr_num_below=1\nE = 1409.98 kT\nE_num_below=0\nwr = 2.39\nwr_num_below=2\nE = 1397.76 kT\nE_num_below=0\nwr = 2.36\nwr_num_below=3\nE = 1396.42 kT\nE_num_below=0\nE = 1412.80 kT\nE_num_below=1\nE = 1399.41 kT\nE_num_below=2\nE = 1382.67 kT\nE_num_below=0\nE = 1403.02 kT\nE_num_below=1\nE = 1416.32 kT\nE_num_below=2\nE = 1412.84 kT\nE_num_below=3\nusing numba\n</pre> Out[7]: <pre>array([28.        ,  2.56118198, 25.43881802])</pre> In\u00a0[8]: Copied! <pre># We can also use custom shapes using the Shape class\ncontrol_points = mdna.Shapes.helix(height=3, pitch=5, radius=7, num_turns=4)\ndna = mdna.make(n_bp=300, control_points=control_points)\ndna.draw()\n</pre> # We can also use custom shapes using the Shape class control_points = mdna.Shapes.helix(height=3, pitch=5, radius=7, num_turns=4) dna = mdna.make(n_bp=300, control_points=control_points) dna.draw() <pre>Random sequence: AAAATCCTGACTACACCATCTTTGACGCAATACCGCATGGGGTAGGCCAAATTTGTATGTCACCCACGTCTCGCAGAGAAGATTCGGCCATGTCAGCCACACAGGGGACATCAAGACACGCGATAGCCCACTGCACCCAAAATCATGAACTCCGCCAGCACCAGGCAATGGGTCGACGTCGGACGTTCGCTGTTCGTATTCTGGATAACAGTGATACCGAGGAAACCTCCTTCAGGACAGTAGCACTATGAAAGATTTCACGGAGACTCTTTATAAACATGGCGATCCTGCCTAGTGGTT \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 300\n\n</pre> In\u00a0[18]: Copied! <pre># Or use the control points to define a custom shape\ncontrol_points = np.array([[0,0,0],[30,10,-10],[50,10,20],[20,4,60]])\ndna = mdna.make(n_bp=100, control_points=control_points, sequence=['A']*100)\ndna.draw()\ndna.describe()\ndna.sequence\n</pre> # Or use the control points to define a custom shape control_points = np.array([[0,0,0],[30,10,-10],[50,10,20],[20,4,60]]) dna = mdna.make(n_bp=100, control_points=control_points, sequence=['A']*100) dna.draw() dna.describe() dna.sequence <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 100\n\nDNA structure with 100 base pairs\nSequence: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 4094 atoms, 200 residues, without unitcells&gt;\nFrames:  (100, 1, 4, 3)\n</pre> Out[18]: <pre>'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'</pre> In\u00a0[19]: Copied! <pre># We can also extend our DNA \ndna.extend(sequence=['G']*40)\n\n# Or extend it in the opposite direction\ndna.extend(sequence=['C']*40, forward=False)\ndna.draw()\n</pre> # We can also extend our DNA  dna.extend(sequence=['G']*40)  # Or extend it in the opposite direction dna.extend(sequence=['C']*40, forward=False) dna.draw() <pre>Minimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: False\n####################################\nInitiating Excluded Volume...\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 20\n   bp per EV bead:     7\n   Effective size:     3.573\n   Exclusion distance: 4.0\n######################################\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: False\n####################################\nInitiating Excluded Volume...\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 26\n   bp per EV bead:     7\n   Effective size:     3.59\n   Exclusion distance: 4.0\n######################################\n</pre> In\u00a0[20]: Copied! <pre># Lets generate two strands of DNA and displace the second one away from the first one\ndna0 = mdna.make(sequence='AAAAAAAAA', control_points=mdna.Shapes.line(1))\ndna1 = mdna.make(sequence='GGGGGGGGG', control_points=mdna.Shapes.line(1)+np.array([4,0,-5]))\n\n# Now we can connect the two strands\ndna2 = mdna.connect(dna0, dna1)\ndna2.draw()\ndna2.describe()\n</pre> # Lets generate two strands of DNA and displace the second one away from the first one dna0 = mdna.make(sequence='AAAAAAAAA', control_points=mdna.Shapes.line(1)) dna1 = mdna.make(sequence='GGGGGGGGG', control_points=mdna.Shapes.line(1)+np.array([4,0,-5]))  # Now we can connect the two strands dna2 = mdna.connect(dna0, dna1) dna2.draw() dna2.describe() <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 9\n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 9\n\nOptimal BP: 54, Twist Difference per BP: 0.002 degrees\nOptimal number of base pairs: 54\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 56\n\nRandom sequence: TCCGACGCCTCGTAGGGTTGTTAAGCACTCATTCAGGGCCTCGCTATTAACTAG \n\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 0.0 \ntemperature = 300\nCircular: False\nDNA structure with 72 base pairs\nSequence: AAAAAAAAATCCGACGCCTCGTAGGGTTGTTAAGCACTCATTCAGGGCCTCGCTATTAACTAGGGGGGGGGG\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 2946 atoms, 144 residues, without unitcells&gt;\nFrames:  (72, 1, 4, 3)\n</pre> In\u00a0[21]: Copied! <pre># visualize using nglview MC minimization\nview = nv.show_mdtraj(dna2.get_MC_traj())\nview\n</pre> # visualize using nglview MC minimization view = nv.show_mdtraj(dna2.get_MC_traj()) view <pre>NGLWidget(max_frame=127)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/0_structure_tutorial/#structure-generation-tutorial","title":"Structure Generation Tutorial\u00b6","text":"<p>Welcome to the DNA structure generation tutorial using the MDNA module. This notebook will guide you through various ways to generate and manipulate DNA structures. You'll learn to:</p> <ul> <li>Generate DNA sequences from scratch.</li> <li>Use custom sequences and define DNA topology to manipulate the linking number</li> <li>Apply custom shapes using control points</li> <li>Visualize and save DNA structures.</li> </ul>"},{"location":"notebooks/0_structure_tutorial/#basic-dna-structure-generation","title":"Basic DNA Structure Generation\u00b6","text":"<p>We start by generating a basic DNA structure using default settings, which outputs a DNA sequence known as the Drew Dickerson dodecamer.</p>"},{"location":"notebooks/0_structure_tutorial/#specifying-a-sequence","title":"Specifying a Sequence\u00b6","text":"<p>You can specify a DNA sequence directly when generating the structure. Note, this will by default generate a linear strand of DNA.</p>"},{"location":"notebooks/0_structure_tutorial/#generating-dna-with-specific-base-pairs","title":"Generating DNA with Specific Base Pairs\u00b6","text":"<p>Generate a DNA structure with a defined number of base pairs, resulting in a random sequence.</p>"},{"location":"notebooks/0_structure_tutorial/#creating-circular-dna-structures","title":"Creating Circular DNA Structures\u00b6","text":"<p>Generate circular DNA structures, commonly known as minicircles.</p>"},{"location":"notebooks/0_structure_tutorial/#minimizing-the-dna-structure","title":"Minimizing the DNA structure\u00b6","text":"<p>After generating the structure, you can minimize it to find a more energetically favorable conformation. The resulting structure is an idealized minicircle, however, if we can also minimize the DNA configuration using Monte Carlo (MC) simulations using a twistable worm like chain (TWLC) model of dsDNA.</p>"},{"location":"notebooks/0_structure_tutorial/#modifying-linking-number","title":"Modifying Linking Number\u00b6","text":"<p>Change the linking number by underwinding or overwinding the DNA using the <code>dLk</code> parameter. Note, to equilibrate the writhe use <code>equilibrate_writhe=True</code>, otherwise the linking number of the topology will not be conserved.</p>"},{"location":"notebooks/0_structure_tutorial/#using-custom-shapes","title":"Using Custom Shapes\u00b6","text":"<p>Explore the use of custom shapes for DNA structures through control points, allowing complex configurations. The <code>Shapes</code> class contains many predefined parametric functions that describe common shapes in 3D space. Utilize custom shapes for DNA structure generation, including helical shapes and more.</p>"},{"location":"notebooks/0_structure_tutorial/#defining-complex-custom-shapes","title":"Defining Complex Custom Shapes\u00b6","text":"<p>Define intricate shapes by specifying control points manually. The points are used to fit a B-spline that goes through each of these points. Note, the minimum number of <code>control_points</code> to fit a spline through is 4.</p>"},{"location":"notebooks/0_structure_tutorial/#extending-dna-sequences","title":"Extending DNA Sequences\u00b6","text":"<p>We can use the custom shaped DNA structure to learn how to extend DNA sequences from both ends. By default the minimization is on using the <code>.extend()</code> function.</p>"},{"location":"notebooks/0_structure_tutorial/#connecting-two-dna-strands","title":"Connecting Two DNA Strands\u00b6","text":"<p>Connect two separate DNA strands and visualize the configuration. This function will find the optimal number of basepairs to connect the two strands to minimize the twist. Alternatively you can also pass the <code>n_bp</code> or <code>control_points</code>.</p>"},{"location":"notebooks/0_structure_tutorial/#visualizing-dna-minimization","title":"Visualizing DNA Minimization\u00b6","text":"<p>Use NGLview to visualize molecular dynamics and the results of Monte Carlo minimization.</p>"},{"location":"notebooks/1_visualization_tutorial/","title":"Visualization Tutorial","text":"In\u00a0[2]: Copied! <pre># # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction\n# # import pymdna as mdna\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n%load_ext autoreload\n%autoreload 2\n</pre> # # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction # # import pymdna as mdna import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna  %load_ext autoreload %autoreload 2 <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> <p>Welcome to the DNA visualization tutorial using the MDNA module. This notebook will demonstrate different ways to visualize DNA structures. You'll learn to:</p> <ul> <li>Perform basic DNA drawing.</li> <li>Customize drawing styles and visual aspects of DNA structures.</li> <li>Integrate multiple DNA visualizations in a single plot.</li> </ul> In\u00a0[3]: Copied! <pre># Basic drawing\ndna = mdna.make(n_bp=24)\ndna.draw()\n</pre> # Basic drawing dna = mdna.make(n_bp=24) dna.draw() <pre>Random sequence: GAATCCTAGGCGCATAGCGTCTGC \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 24\n\n</pre> In\u00a0[4]: Copied! <pre># Change styling\ndna.draw(backbone=True, triads=False, helical_axis=True, lw=3, markersize=4, color_anti='red', color_lead='blue', color_axis='green')\n</pre> # Change styling dna.draw(backbone=True, triads=False, helical_axis=True, lw=3, markersize=4, color_anti='red', color_lead='blue', color_axis='green') In\u00a0[5]: Copied! <pre># Draw mean reference frames of base pairs\ndna.draw(backbone=False, triads=True)\n\n# Change styling\ndna.draw(backbone=False, triads=True, length=1)\n</pre> # Draw mean reference frames of base pairs dna.draw(backbone=False, triads=True)  # Change styling dna.draw(backbone=False, triads=True, length=1) In\u00a0[9]: Copied! <pre># Add multiple drawings to the same figure\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\ndna1 = mdna.make(n_bp=100, circular=True)\ndna1.draw(ax=ax, lw=1, color_anti='blue')\n\nshape = np.array([[15,5,5],[3,3,3],[2,2,2],[0,0,0]])\ndna2 = mdna.make(control_points=shape,n_bp=50)\ndna2.draw(ax=ax, color_anti='red')\n</pre> # Add multiple drawings to the same figure import matplotlib.pyplot as plt import numpy as np  fig = plt.figure() ax = fig.add_subplot(111, projection='3d')  dna1 = mdna.make(n_bp=100, circular=True) dna1.draw(ax=ax, lw=1, color_anti='blue')  shape = np.array([[15,5,5],[3,3,3],[2,2,2],[0,0,0]]) dna2 = mdna.make(control_points=shape,n_bp=50) dna2.draw(ax=ax, color_anti='red') <pre>Random sequence: TCATGGGATTTCGTTGCATGACTGTCCTAGCATTGATAATCGCGTAAGCGCATAACCATAAACATTGCTGTATACGAGAGATGCCGCAGGTTGTCCGAGG \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 100\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 1.71 degrees\n\tNew twist angle per base pair: 36.0 \n\nRandom sequence: AGAAGTTTTATAGACCAACCATTATAATCGTAACGAAACGTTCTATCCAA \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 50\n\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/1_visualization_tutorial/#visualization-tutorial","title":"Visualization Tutorial\u00b6","text":""},{"location":"notebooks/1_visualization_tutorial/#basic-dna-drawing","title":"Basic DNA Drawing\u00b6","text":"<p>Start by generating a simple DNA structure and drawing it using default settings.</p>"},{"location":"notebooks/1_visualization_tutorial/#advanced-drawing-options","title":"Advanced Drawing Options\u00b6","text":"<p>Customize the drawing by adjusting styles and adding components like helical axes.</p>"},{"location":"notebooks/1_visualization_tutorial/#drawing-mean-reference-frames-of-base-pairs","title":"Drawing Mean Reference Frames of Base Pairs\u00b6","text":"<p>Visualize only the reference frames without the backbone for clarity.</p>"},{"location":"notebooks/1_visualization_tutorial/#combining-multiple-dna-structures-in-one-figure","title":"Combining Multiple DNA Structures in One Figure\u00b6","text":"<p>Combine multiple DNA structures in a single 3D plot using matplotlib.</p>"},{"location":"notebooks/2_modification_tutorial/","title":"Modification Tutorial","text":"<p>Welcome to the DNA modification tutorial using the MDNA module. This notebook will demonstrate how to modify DNA structures using mutation, methylation, and flipping techniques. You'll learn to:</p> <ul> <li>Mutate specific bases in a DNA sequence.</li> <li>Apply methylation to DNA bases and explore its effects.</li> <li>Perform Hoogsteen base flipping to study alternative DNA structures.</li> <li>Save and visualize the modified DNA structures.</li> </ul> In\u00a0[1]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport nglview as nv\n\n\n# # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction\n# # import pymdna as mdna\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n%load_ext autoreload\n%autoreload 2\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import nglview as nv   # # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction # # import pymdna as mdna import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna  %load_ext autoreload %autoreload 2 <pre></pre> <pre>/Users/thor/surfdrive/Projects/PMCpy/pmcpy/Evals/PyLk/pylk/writhemap.py:16: UserWarning: Cython version of writhemap (PyLk) not compiled. Defaulting to numba implementation. Consider compiling the cython version.\n  warnings.warn(\n/Users/thor/surfdrive/Projects/PMCpy/pmcpy/Evals/PyLk/pylk/eval_link.py:10: UserWarning: Cython version of linkingnumber (PyLk) not compiled. Defaulting to numba implementation. Consider compiling the cython version.\n  warnings.warn(\n</pre> In\u00a0[2]: Copied! <pre># Here we make a DNA with the following sequence\ndna = mdna.make(sequence='AGCGATATAGA')\n</pre> # Here we make a DNA with the following sequence dna = mdna.make(sequence='AGCGATATAGA') <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 11\n\n</pre> In\u00a0[3]: Copied! <pre># Let's save the original structure\ntraj = dna.get_traj()\ntraj.save_pdb('.pdbs/dna_original.pdb')\n</pre> # Let's save the original structure traj = dna.get_traj() traj.save_pdb('.pdbs/dna_original.pdb') In\u00a0[9]: Copied! <pre># Let's mutate the first base to a G and the last base to a C\ndna.mutate(mutations={0: 'G', dna.n_bp-1: 'C'})\n\n# Get information about the DNA and see the mutated sequence\ndna.describe()\n</pre> # Let's mutate the first base to a G and the last base to a C dna.mutate(mutations={0: 'G', dna.n_bp-1: 'C'})  # Get information about the DNA and see the mutated sequence dna.describe() <pre>DNA structure with 11 base pairs\nSequence: GGCGATATAGC\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 445 atoms, 22 residues, without unitcells&gt;\nFrames:  (11, 1, 4, 3)\n</pre> In\u00a0[10]: Copied! <pre># Use methylation list, here we methylate the 5th position, which is T, so methylation won't work but is caught by the function\ndna.methylate(methylations=[5])\n\n# Or use the methylation function to methylate all CpG sites\ndna.methylate(CpG=True)\n</pre> # Use methylation list, here we methylate the 5th position, which is T, so methylation won't work but is caught by the function dna.methylate(methylations=[5])  # Or use the methylation function to methylate all CpG sites dna.methylate(CpG=True) <pre>Residue DT6 with methylations index 5 could not be methylated.\nMethylate all C in CpG context, superseeds methylations list.\nMethtylating: [2]\n</pre> In\u00a0[11]: Copied! <pre># Hoogsteen flip can be done at any base pair, here we flip the 5th base pair\ndna.flip(fliplist=[5], deg=180)\n</pre> # Hoogsteen flip can be done at any base pair, here we flip the 5th base pair dna.flip(fliplist=[5], deg=180) <pre>Flipped residues [5] by 3.141592653589793 radians\n</pre> In\u00a0[12]: Copied! <pre># Get trajectory or save as pdb\ntraj_mod = dna.get_traj()\ntraj_mod.save_pdb('./pdbs/dna_modified.pdb')\n</pre> # Get trajectory or save as pdb traj_mod = dna.get_traj() traj_mod.save_pdb('./pdbs/dna_modified.pdb') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/2_modification_tutorial/#modification-tutorial","title":"Modification Tutorial\u00b6","text":""},{"location":"notebooks/2_modification_tutorial/#initial-dna-structure-generation","title":"Initial DNA Structure Generation\u00b6","text":"<p>We begin by generating a DNA structure with a specific sequence to prepare it for modifications.</p>"},{"location":"notebooks/2_modification_tutorial/#saving-the-original-dna-structure","title":"Saving the Original DNA Structure\u00b6","text":"<p>It's often useful to save the original DNA structure before modifications for comparison purposes.</p>"},{"location":"notebooks/2_modification_tutorial/#dna-mutation","title":"DNA Mutation\u00b6","text":"<p>Modify specific bases within the DNA sequence to see how mutations affect the structure and properties.</p>"},{"location":"notebooks/2_modification_tutorial/#dna-methylation","title":"DNA Methylation\u00b6","text":"<p>Apply methylation to specific bases or patterns within the DNA sequence.</p>"},{"location":"notebooks/2_modification_tutorial/#hoogsteen-base-flipping","title":"Hoogsteen Base Flipping\u00b6","text":"<p>Perform Hoogsteen flips on specific bases to explore alternative DNA configurations.</p>"},{"location":"notebooks/2_modification_tutorial/#saving-and-viewing-modified-dna-structures","title":"Saving and Viewing Modified DNA Structures\u00b6","text":"<p>After modification, save the new DNA structure and compare it to the original.</p>"},{"location":"notebooks/3_analysis_tutorial/","title":"Analysis Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n# # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction\n# # import pymdna as mdna\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n%load_ext autoreload\n%autoreload 2\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import seaborn as sns   # # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction # # import pymdna as mdna import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna  %load_ext autoreload %autoreload 2 <pre>/Users/thor/surfdrive/Projects/PMCpy/pmcpy/Evals/PyLk/pylk/writhemap.py:16: UserWarning: Cython version of writhemap (PyLk) not compiled. Defaulting to numba implementation. Consider compiling the cython version.\n  warnings.warn(\n/Users/thor/surfdrive/Projects/PMCpy/pmcpy/Evals/PyLk/pylk/eval_link.py:10: UserWarning: Cython version of linkingnumber (PyLk) not compiled. Defaulting to numba implementation. Consider compiling the cython version.\n  warnings.warn(\n</pre> In\u00a0[2]: Copied! <pre># Initiate a DNA simulation using OpenMM \ntraj = mdna.sequence_to_md(sequence='GCAATATATTGC', time=1, time_unit='nanoseconds', solvated=True, save_location='./data/')\ntraj.center_coordinates()\n</pre> # Initiate a DNA simulation using OpenMM  traj = mdna.sequence_to_md(sequence='GCAATATATTGC', time=1, time_unit='nanoseconds', solvated=True, save_location='./data/') traj.center_coordinates() <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\nInitialize DNA openMM simulation at 310 K for 1 ns time units\nSolvate DNA with padding of 1.0 nm and 0.1 M KCl\nMinimize energy\nRun simulation for 499999 steps\nSimulation completed\nSaved trajectory as: ./data/my_dna.h5\n</pre> Out[2]: <pre>&lt;mdtraj.Trajectory with 4999 frames, 17187 atoms, 5527 residues, and unitcells at 0x2b1553500&gt;</pre> In\u00a0[3]: Copied! <pre># Find index of residue in the middle of the DNA structure\nindices = traj.top.select('resid 4')\nresidx = traj.topology.atom(indices[0]).residue.index\nanchor_molecules=[set(traj.topology.residue(residx).atoms)]\n\n# Put everything in the same box based on the anchor residue\ntraj = traj.image_molecules(anchor_molecules=anchor_molecules)\ntraj = traj.superpose(traj, 0)\n</pre> # Find index of residue in the middle of the DNA structure indices = traj.top.select('resid 4') residx = traj.topology.atom(indices[0]).residue.index anchor_molecules=[set(traj.topology.residue(residx).atoms)]  # Put everything in the same box based on the anchor residue traj = traj.image_molecules(anchor_molecules=anchor_molecules) traj = traj.superpose(traj, 0) In\u00a0[4]: Copied! <pre># Load the trajectory\ndna = mdna.load(traj)\n\n# Extract mean reference frames and base reference frames\nmean_frames = dna.get_frames()\nprint(mean_frames.shape)\n\nbase_frames = dna.get_base_frames()\nfor res, ref in base_frames.items():\n    print(res, ref.shape)\n    break\n</pre> # Load the trajectory dna = mdna.load(traj)  # Extract mean reference frames and base reference frames mean_frames = dna.get_frames() print(mean_frames.shape)  base_frames = dna.get_base_frames() for res, ref in base_frames.items():     print(res, ref.shape)     break <pre>(12, 4999, 4, 3)\nDG1 (4999, 4, 3)\n</pre> In\u00a0[5]: Copied! <pre># Extract and visualize parameters\nbase, names = dna.get_parameters(base=True)\nprint(base.shape, names)\n\nstep, names = dna.get_parameters(step=True)\nprint(step.shape, names)\n\nparams, names = dna.get_parameters()\nprint(params.shape, names)\n</pre> # Extract and visualize parameters base, names = dna.get_parameters(base=True) print(base.shape, names)  step, names = dna.get_parameters(step=True) print(step.shape, names)  params, names = dna.get_parameters() print(params.shape, names) <pre>(4999, 12, 6) ['shear', 'stretch', 'stagger', 'buckle', 'propeller', 'opening']\n(4999, 12, 6) ['shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n(4999, 12, 12) ['shear', 'stretch', 'stagger', 'buckle', 'propeller', 'opening', 'shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n</pre> <p>We can also extract just a single parameter</p> In\u00a0[6]: Copied! <pre>name = 'twist'\npara = dna.get_parameter(name)\nprint(para.shape)\n</pre> name = 'twist' para = dna.get_parameter(name) print(para.shape) <pre>(4999, 12)\n</pre> <p>Next we plot</p> In\u00a0[7]: Copied! <pre># Plot the twist parameter\nfig, ax = plt.subplots(figsize=[5,3])\ncolor = 'tab:orange'\nmean = np.mean(para, axis=0)\nstd = np.std(para, axis=0)\nx = range(len(mean))\n\nax.fill_between(x, mean-std, mean+std, color=color, alpha=0.2)\nax.plot(mean, color=color, lw=1)    \nax.scatter(x=x, y=mean, color=color, s=10)\nax.set_title(name)\nax.set_ylabel(f'{name} [degrees]')\nax.set_xlabel('Base pair step')\nbase_map = dna.base_pair_map\nanti_sequence = [base_map[c] for c in dna.sequence]\nbase_pairs = [f'{i}-{j}' for i, j in zip(dna.sequence, anti_sequence)]\n_ = ax.set_xticklabels(base_pairs, rotation=45)\n</pre>  # Plot the twist parameter fig, ax = plt.subplots(figsize=[5,3]) color = 'tab:orange' mean = np.mean(para, axis=0) std = np.std(para, axis=0) x = range(len(mean))  ax.fill_between(x, mean-std, mean+std, color=color, alpha=0.2) ax.plot(mean, color=color, lw=1)     ax.scatter(x=x, y=mean, color=color, s=10) ax.set_title(name) ax.set_ylabel(f'{name} [degrees]') ax.set_xlabel('Base pair step') base_map = dna.base_pair_map anti_sequence = [base_map[c] for c in dna.sequence] base_pairs = [f'{i}-{j}' for i, j in zip(dna.sequence, anti_sequence)] _ = ax.set_xticklabels(base_pairs, rotation=45) <pre>/var/folders/n2/v5z2p1nn4f3bx7dhf2zlzdjw0000gn/T/ipykernel_40850/4214002102.py:17: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.\n  _ = ax.set_xticklabels(base_pairs, rotation=45)\n</pre> In\u00a0[8]: Copied! <pre># Example on how to plot KDE's of all parameters\nimport matplotlib as mpl, matplotlib.font_manager as font_manager\nimport seaborn as sns\nmpl.rcParams['font.family'] = 'serif'\ncmfont = font_manager.FontProperties(fname=mpl.get_data_path() + '/fonts/ttf/cmr10.ttf')\nmpl.rcParams['font.serif'] = cmfont.get_name()\nmpl.rcParams['mathtext.fontset'] = 'cm'\nmpl.rcParams['axes.unicode_minus'] = False\nmpl.rcParams['axes.formatter.use_mathtext'] = True\n\ncolors = sns.color_palette('twilight', 12)\nlims = [(-2,2), (-2,2), (-2,2), (-65,65), (-65,65), (-65,65)] + [(-3,3), (-3,3), (1.25,5), (-50,50), (-50,50), (0,60)]\nfig, ax = plt.subplots(3, 4, figsize=(6, 2.5), sharey='col')\n# ax = ax.flatten()\nidx, jdx = 0, 0\nfor _, name in enumerate(names):\n    para = params[:, 1:, names.index(name)]\n    sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color='white', lw=5)  # density=True\n    sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color=colors[_], alpha=1, lw=1)  # density=True\n    ax[idx][jdx].set_title(name, x=0, y=0, color=colors[_], fontsize=10)\n    ax[idx][jdx].set_xlim(lims[_])\n\n    ax[idx][jdx].set_facecolor('none')\n    ax[idx][jdx].set_yticklabels([])\n    ax[idx][jdx].set_yticks([])\n    ax[idx][jdx].set_ylabel('')\n    if name in ['shear', 'buckle', 'shift', 'tilt', 'stretch', 'propeller']:\n        ax[idx][jdx].set_xticks([])\n    idx += 1\n    if idx == 3:\n        idx = 0\n        jdx += 1\n    if jdx == 4:\n        jdx = 0\n\n    if idx == 0 and jdx in [0, 1, 2, 3]:\n        ax[idx][jdx].set_xticklabels([])\n    if idx == 1 and jdx in [0, 1]:\n        ax[idx][jdx].set_xticklabels([])\n\nax[-1][0].set_xlabel('[nm]', fontsize=11)\nax[-1][1].set_xlabel('[degrees]', fontsize=11)\nax[-1][2].set_xlabel('[nm]', fontsize=11)\nax[-1][3].set_xlabel('[degrees]', fontsize=11)\nfig.tight_layout()\nfig.subplots_adjust(hspace=-.25)\n\nsns.despine(bottom=True, left=True)\nfig.text(0.25, 0.85, 'Pair Parameters', ha='center', fontsize=10)\nfig.text(0.75, 0.85, 'Step Parameters', ha='center', fontsize=10)\n</pre> # Example on how to plot KDE's of all parameters import matplotlib as mpl, matplotlib.font_manager as font_manager import seaborn as sns mpl.rcParams['font.family'] = 'serif' cmfont = font_manager.FontProperties(fname=mpl.get_data_path() + '/fonts/ttf/cmr10.ttf') mpl.rcParams['font.serif'] = cmfont.get_name() mpl.rcParams['mathtext.fontset'] = 'cm' mpl.rcParams['axes.unicode_minus'] = False mpl.rcParams['axes.formatter.use_mathtext'] = True  colors = sns.color_palette('twilight', 12) lims = [(-2,2), (-2,2), (-2,2), (-65,65), (-65,65), (-65,65)] + [(-3,3), (-3,3), (1.25,5), (-50,50), (-50,50), (0,60)] fig, ax = plt.subplots(3, 4, figsize=(6, 2.5), sharey='col') # ax = ax.flatten() idx, jdx = 0, 0 for _, name in enumerate(names):     para = params[:, 1:, names.index(name)]     sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color='white', lw=5)  # density=True     sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color=colors[_], alpha=1, lw=1)  # density=True     ax[idx][jdx].set_title(name, x=0, y=0, color=colors[_], fontsize=10)     ax[idx][jdx].set_xlim(lims[_])      ax[idx][jdx].set_facecolor('none')     ax[idx][jdx].set_yticklabels([])     ax[idx][jdx].set_yticks([])     ax[idx][jdx].set_ylabel('')     if name in ['shear', 'buckle', 'shift', 'tilt', 'stretch', 'propeller']:         ax[idx][jdx].set_xticks([])     idx += 1     if idx == 3:         idx = 0         jdx += 1     if jdx == 4:         jdx = 0      if idx == 0 and jdx in [0, 1, 2, 3]:         ax[idx][jdx].set_xticklabels([])     if idx == 1 and jdx in [0, 1]:         ax[idx][jdx].set_xticklabels([])  ax[-1][0].set_xlabel('[nm]', fontsize=11) ax[-1][1].set_xlabel('[degrees]', fontsize=11) ax[-1][2].set_xlabel('[nm]', fontsize=11) ax[-1][3].set_xlabel('[degrees]', fontsize=11) fig.tight_layout() fig.subplots_adjust(hspace=-.25)  sns.despine(bottom=True, left=True) fig.text(0.25, 0.85, 'Pair Parameters', ha='center', fontsize=10) fig.text(0.75, 0.85, 'Step Parameters', ha='center', fontsize=10) Out[8]: <pre>Text(0.75, 0.85, 'Step Parameters')</pre>"},{"location":"notebooks/3_analysis_tutorial/#analysis-tutorial","title":"Analysis Tutorial\u00b6","text":"<p>Welcome to the DNA analysis tutorial using the MDNA module. This notebook will demonstrate different techniques to analyze DNA structures, including simulations, parameter extractions, and visualization of dynamics. You'll learn to:</p> <ul> <li>Simulate DNA structures using OpenMM.</li> <li>Extract and analyze different structural parameters.</li> <li>Visualize these parameters to understand DNA behavior.</li> </ul>"},{"location":"notebooks/3_analysis_tutorial/#dna-simulation-with-openmm","title":"DNA Simulation with OpenMM\u00b6","text":"<p>Molecular Dynamics (MD) simulations are computational methods used to study the physical movements of atoms and molecules over time. By simulating the interactions and dynamics of molecular structures, MD provides insights into the structural, dynamic, and thermodynamic properties of biological molecules like DNA.</p>"},{"location":"notebooks/3_analysis_tutorial/#about-openmm","title":"About OpenMM\u00b6","text":"<p>OpenMM is a toolkit for molecular simulations, designed to be extremely flexible and highly efficient. It allows for the rapid development of algorithms and the construction of custom molecular dynamics applications. It is especially optimized for high-performance simulations, making it ideal for studies that require complex, large-scale computations.</p>"},{"location":"notebooks/3_analysis_tutorial/#simulation-process","title":"Simulation Process\u00b6","text":"<ol> <li><p>Initialization: We start by creating a DNA simulation from a given sequence. This involves setting up the initial conditions, such as the DNA sequence itself, simulation time, and whether the system should be solvated (surrounded by a solvent, typically water).</p> </li> <li><p>Centering Coordinates: To ensure that the DNA structure is properly oriented and centered in the simulation box, we adjust the coordinates. This is crucial for avoiding any boundary issues during the simulation.</p> </li> <li><p>Imaging Molecules: This step involves adjusting the positions of molecules relative to each other based on an anchor molecule. Typically, this helps in maintaining the integrity of the structure throughout the simulation, preventing it from drifting apart across periodic boundaries.</p> </li> <li><p>Superposition: Finally, the trajectory is superposed to a reference frame (usually the first frame) to eliminate any rotational and translational movements that are not intrinsic to the molecule's dynamics.</p> </li> </ol>"},{"location":"notebooks/3_analysis_tutorial/#note","title":"Note\u00b6","text":"<p>This simulation might take a while to run, depending on the complexity of the DNA sequence and the computational resources available. It's performed to understand the dynamic behavior of the DNA molecule in a simulated physiological environment. Alternatively, you might load your own MD trajectory containing a DNA structure for the purpose of this tutorial.</p>"},{"location":"notebooks/3_analysis_tutorial/#managing-dna-coordinates","title":"Managing DNA Coordinates\u00b6","text":"<p>Find a residue in the middle, anchor molecules, and adjust the DNA in the simulation box.</p>"},{"location":"notebooks/3_analysis_tutorial/#loading-and-analyzing-dna-structure","title":"Loading and Analyzing DNA Structure\u00b6","text":"<p>Load the trajectory, extract mean reference frames, and view base reference frames.</p>"},{"location":"notebooks/3_analysis_tutorial/#extracting-and-visualizing-rigid-base-parameters","title":"Extracting and Visualizing Rigid Base Parameters\u00b6","text":"<p>Show how to extract and parameters</p>"},{"location":"notebooks/3_analysis_tutorial/#advanced-visualization-of-dna-parameters","title":"Advanced Visualization of DNA Parameters\u00b6","text":"<p>Use statistical visualization to understand distributions of DNA parameters.</p>"},{"location":"notebooks/4_filament_tutorial/","title":"DNA Along a Protein Filament","text":"In\u00a0[3]: Copied! <pre># Load necessary libraries and retrieve the trajectory object\nimport mdtraj as md\nimport numpy as np\nimport nglview as nv\nimport matplotlib.pyplot as plt\n\nfrom tqdm import tqdm\n\n# # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction\n# # import pymdna as mdna\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/examples/data/')\nfrom filament import *\n%load_ext autoreload\n%autoreload 2\n</pre> # Load necessary libraries and retrieve the trajectory object import mdtraj as md import numpy as np import nglview as nv import matplotlib.pyplot as plt  from tqdm import tqdm  # # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction # # import pymdna as mdna import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna   sys.path.append('/Users/thor/surfdrive/Projects/pymdna/examples/data/') from filament import * %load_ext autoreload %autoreload 2 In\u00a0[5]: Copied! <pre># Load H-NS s1s1 dimers\nloc_dimers = '/Users/thor/surfdrive/Data/h-ns/dimer/0_s1s1/drytrajs/'\nshort_trajs = [md.load(loc_dimers+f'dry_{i}.xtc',top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]\n# start_open = md.load(loc_dimers+f'dry_open.xtc',top=loc_dimers+f'dry_open.pdb').remove_solvent()\n# start_closed = md.load(loc_dimers+f'dry_closed.xtc',top=loc_dimers+f'dry_closed.pdb').remove_solvent()\n# s1s1 = md.join([start_open,start_closed,md.join(short_trajs)])\ns1s1 = md.join(short_trajs)\n\n# Load H-NS s2s2 dimers\nloc_dimers = '/Users/thor/surfdrive/Data/h-ns/dimer/1_s2s2/drytrajs/'\nshort_trajs = [md.load(loc_dimers+f'dry_{i}.xtc',top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]\ns2s2 = md.join(short_trajs)\n\n# Load H-NS dbd to DNA complex\nloc_dbd  = '/Users/thor/surfdrive/Data/h-ns/NAR/md/0_highaff/FI/drytrajs/'\ntraj = [md.load(loc_dbd+f'dry_{i}.xtc',top=loc_dbd+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]\ndna_complex = md.join(traj)\n\n# Define segments of the protein\nn = 2 # Overlap of residues between segments\n\nsegments = {'s1':np.arange(0,41+n),\n            'h3':np.arange(41-n,53+n),\n            's2':np.arange(53-n,82+n),\n            'l2':np.arange(82-n,95+n),\n            'dbd':np.arange(95-n,137)}\n\n# Site map contains a dictionary with the (sub)trajectories of different sites of the protein catergorized from the s1s1 and s2s2 dimers\nmapper = SiteMapper(s1s1, s2s2, segments=segments, k=100)\nsite_map = mapper.get_site_map()\nsite_map['complex'] = dna_complex\n</pre> # Load H-NS s1s1 dimers loc_dimers = '/Users/thor/surfdrive/Data/h-ns/dimer/0_s1s1/drytrajs/' short_trajs = [md.load(loc_dimers+f'dry_{i}.xtc',top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)] # start_open = md.load(loc_dimers+f'dry_open.xtc',top=loc_dimers+f'dry_open.pdb').remove_solvent() # start_closed = md.load(loc_dimers+f'dry_closed.xtc',top=loc_dimers+f'dry_closed.pdb').remove_solvent() # s1s1 = md.join([start_open,start_closed,md.join(short_trajs)]) s1s1 = md.join(short_trajs)  # Load H-NS s2s2 dimers loc_dimers = '/Users/thor/surfdrive/Data/h-ns/dimer/1_s2s2/drytrajs/' short_trajs = [md.load(loc_dimers+f'dry_{i}.xtc',top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)] s2s2 = md.join(short_trajs)  # Load H-NS dbd to DNA complex loc_dbd  = '/Users/thor/surfdrive/Data/h-ns/NAR/md/0_highaff/FI/drytrajs/' traj = [md.load(loc_dbd+f'dry_{i}.xtc',top=loc_dbd+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)] dna_complex = md.join(traj)  # Define segments of the protein n = 2 # Overlap of residues between segments  segments = {'s1':np.arange(0,41+n),             'h3':np.arange(41-n,53+n),             's2':np.arange(53-n,82+n),             'l2':np.arange(82-n,95+n),             'dbd':np.arange(95-n,137)}  # Site map contains a dictionary with the (sub)trajectories of different sites of the protein catergorized from the s1s1 and s2s2 dimers mapper = SiteMapper(s1s1, s2s2, segments=segments, k=100) site_map = mapper.get_site_map() site_map['complex'] = dna_complex In\u00a0[6]: Copied! <pre>#  Paramers to make filament\nn_dimers = 6\nchains_to_dna = [0,4,7,11]\nsave = True\n\n# Initialize class to assemble the filament\nassembler = Assembler(site_map=site_map)\n\n# Add dimers\nprint(f'Assembling {n_dimers} H-NS dimers:')\nfor idx in tqdm(range(n_dimers)):\n    assembler.add_dimer(segment='fixed',verbose=True)  \n\n# Add DNA oligo's\nn_dna = len(chains_to_dna)\nif n_dna &gt; 0:\n    print(f\"Assembling {n_dna} DNA oligo's:\")\n    for chainid in tqdm(chains_to_dna):\n        assembler.add_dna(chainid=chainid)\n\n\n# Retrieve the trajectory from the assembled complex\ntraj = assembler.get_traj()\n</pre> #  Paramers to make filament n_dimers = 6 chains_to_dna = [0,4,7,11] save = True  # Initialize class to assemble the filament assembler = Assembler(site_map=site_map)  # Add dimers print(f'Assembling {n_dimers} H-NS dimers:') for idx in tqdm(range(n_dimers)):     assembler.add_dimer(segment='fixed',verbose=True)    # Add DNA oligo's n_dna = len(chains_to_dna) if n_dna &gt; 0:     print(f\"Assembling {n_dna} DNA oligo's:\")     for chainid in tqdm(chains_to_dna):         assembler.add_dna(chainid=chainid)   # Retrieve the trajectory from the assembled complex traj = assembler.get_traj()  <pre>Assembling 6 H-NS dimers:\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:10&lt;00:00,  1.77s/it]\n</pre> <pre>Assembling 4 DNA oligo's:\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:02&lt;00:00,  1.90it/s]\n</pre> <p>Identify chains associated with DNA based on residue names typical for DNA nucleotides</p> In\u00a0[7]: Copied! <pre>DNA_residue_names = ['DG','DC','DT','DA']\nDNA_chainids = []\nfor chain in traj.top.chains:\n    for res in chain._residues:\n        if str(res.name) in DNA_residue_names:\n            DNA_chainids.append(res.chain.index)\nDNA_chainids = np.unique(DNA_chainids)\nDNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)])\n</pre> DNA_residue_names = ['DG','DC','DT','DA'] DNA_chainids = [] for chain in traj.top.chains:     for res in chain._residues:         if str(res.name) in DNA_residue_names:             DNA_chainids.append(res.chain.index) DNA_chainids = np.unique(DNA_chainids) DNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)])  <p>Calculate specific control points based on the center of mass and other structural features of identified DNA segments This follows the previously described scientific model for assembling H-NS filaments</p> In\u00a0[10]: Copied! <pre>COM_primes = []\nidx = 0\nfor chainids in DNA_chainids:\n    nuc = mdna.load(traj, chainids=chainids)\n    frames = nuc.get_frames()\n\n    # Adding control points based on the specific arrangements in the filament model\n    if idx == 0:\n        COM_primes.append(frames[0][0][0] - np.array([3, -1, 0]))\n        COM_primes.append(frames[0][0][0])\n    elif idx == 3:\n        COM_primes.append(frames[-1][0][0] + np.array([0, -2, 0]))\n        COM_primes.append(frames[-1][0][0] + np.array([10, -3, 0]))\n    else:\n        COM_primes.append(frames[6][0][0])\n    idx += 1\n\nCOM_primes = np.array(COM_primes)\npoints = COM_primes\n</pre> COM_primes = [] idx = 0 for chainids in DNA_chainids:     nuc = mdna.load(traj, chainids=chainids)     frames = nuc.get_frames()      # Adding control points based on the specific arrangements in the filament model     if idx == 0:         COM_primes.append(frames[0][0][0] - np.array([3, -1, 0]))         COM_primes.append(frames[0][0][0])     elif idx == 3:         COM_primes.append(frames[-1][0][0] + np.array([0, -2, 0]))         COM_primes.append(frames[-1][0][0] + np.array([10, -3, 0]))     else:         COM_primes.append(frames[6][0][0])     idx += 1  COM_primes = np.array(COM_primes) points = COM_primes  In\u00a0[\u00a0]: Copied! <pre>dna = mdna.make(control_points=points)\ndna.draw()\n</pre> dna = mdna.make(control_points=points) dna.draw() <p>Save result</p> In\u00a0[12]: Copied! <pre># Save the structures for further analysis\ndna_traj = dna.get_traj()\nprotein = traj.atom_slice(traj.top.select('protein'))\nprotein.save('./lateral_filament_unoptimized_noDNA.pdb')\nnew_traj = dna_traj.stack(protein)\nnew_traj.save('./lateral_filament_unoptimized.pdb')\n\n# Visualize the final combined structure\nview = nv.show_mdtraj(new_traj)\nview\n</pre> # Save the structures for further analysis dna_traj = dna.get_traj() protein = traj.atom_slice(traj.top.select('protein')) protein.save('./lateral_filament_unoptimized_noDNA.pdb') new_traj = dna_traj.stack(protein) new_traj.save('./lateral_filament_unoptimized.pdb')  # Visualize the final combined structure view = nv.show_mdtraj(new_traj) view <pre>Random sequence: TGAGTCATGTTCGTAAAGACATTTGATACGTGGGGGAAAGGGGATGCCGGTAGATCTCACGTAGACTCCATGCAGTAGCCTTAGGGCATGCATGATCTACGCCAGCAGTAACTGGTCACGGGGATGCCAGGAGGCGTTTATATAATCAGAGGTCTTGTGTCATAGGCAGAGGCAAGAGATCCTGAACTCCAGAGTTAGCTCGGGCTTGCTAA \n\n</pre> <pre>NGLWidget()</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/4_filament_tutorial/#dna-along-a-protein-filament","title":"DNA Along a Protein Filament\u00b6","text":"<p>This tutorial demonstrates how to construct DNA structures along a protein filament, specifically focusing on the lateral H-NS filament assembly process. This technique involves modeling interactions between DNA and protein structures, providing a method to visualize complex biological assemblies.</p>"},{"location":"notebooks/4_filament_tutorial/#scientific-context","title":"Scientific Context:\u00b6","text":"<ul> <li>The process starts with a H-NS decamer homodimer, which serves as the initial protein scaffold.</li> <li>Four DNA Binding Domains (DBD) are fitted with 12 bp DNA strands using the H-NS DNA complex structures from previous studies (PDB: 1HNS).</li> <li>The reference frames of the 4 DNA oligomers are then used as control points to generate new DNA strands spanning the complete H-NS filament.</li> </ul>"},{"location":"notebooks/4_filament_tutorial/#objective","title":"Objective:\u00b6","text":"<ul> <li>Highlight the capability of the <code>.make()</code> function to create DNA structures by using anchor points of specific domains as control points.</li> <li>Demonstrate the flexibility of structure generation where the protein filament serves as a scaffold, enabling the generation of a DNA configuration along a reference structure.</li> </ul>"},{"location":"notebooks/4_filament_tutorial/#steps-covered","title":"Steps Covered:\u00b6","text":"<ul> <li>Retrieve and process the trajectory object to identify DNA chains.</li> <li>Calculate control points based on the reference frames of identified DNA segments and the scientific model.</li> <li>Generate DNA along these control points and integrate with the protein structure.</li> <li>Visualize and save the new combined structure.</li> </ul>"},{"location":"notebooks/4_filament_tutorial/#load-md-data","title":"Load MD data\u00b6","text":""},{"location":"notebooks/4_filament_tutorial/#construct-h-ns-filament","title":"Construct H-NS filament\u00b6","text":""},{"location":"notebooks/4_filament_tutorial/#analyze-filament","title":"Analyze filament\u00b6","text":""},{"location":"notebooks/4_filament_tutorial/#generate-dna-along-filement","title":"Generate DNA along filement\u00b6","text":"<p>Generate the DNA along defined control points and integrate with the protein structure This step visualizes the flexibility and utility of the .make() function in creating specified DNA shapes</p>"},{"location":"notebooks/5_extension_tutorial/","title":"Adding Linker DNA","text":"In\u00a0[2]: Copied! <pre>import mdtraj as md\nimport nglview as nv\n# # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction\n# # import pymdna as mdna\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n%load_ext autoreload\n%autoreload 2\n\n\n# Load PDB file\npdb = md.load('./pdbs/1kx5.pdb')\nview = nv.show_mdtraj(pdb)\nview\n</pre> import mdtraj as md import nglview as nv # # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction # # import pymdna as mdna import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna  %load_ext autoreload %autoreload 2   # Load PDB file pdb = md.load('./pdbs/1kx5.pdb') view = nv.show_mdtraj(pdb) view <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> <pre>NGLWidget()</pre> In\u00a0[3]: Copied! <pre># Load DNA part from traj object\ndna = mdna.load(pdb)\ndna.describe()\n\n# Add random linker DNA in forward and reverse direction. Note the exvol_rad parameter set to zero, because due to the wrapping of around the core protein, the exvol beads overlap. This is not allowed in the current implementation of the MC algorithm.\ndna.extend(n_bp=36, exvol_rad=0)\ndna.extend(n_bp=36, exvol_rad=0, forward=False)\n\n# Visualize the extended DNA\ndna.draw()\n</pre> # Load DNA part from traj object dna = mdna.load(pdb) dna.describe()  # Add random linker DNA in forward and reverse direction. Note the exvol_rad parameter set to zero, because due to the wrapping of around the core protein, the exvol beads overlap. This is not allowed in the current implementation of the MC algorithm. dna.extend(n_bp=36, exvol_rad=0) dna.extend(n_bp=36, exvol_rad=0, forward=False)  # Visualize the extended DNA dna.draw() <pre>DNA structure with 147 base pairs\nSequence: ATCAATATCCACCTGCAGATACTACCAAAAGTGTATTTGGAAACTGCTCCATCAAAAGGCATGTTCAGCTGGAATCCAGCTGAACATGCCTTTTGATGGAGCAGTTTCCAAATACACTTTTGGTAGTATCTGCAGGTGGATATTGAT\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 16755 atoms, 4416 residues, and unitcells&gt;\nFrames:  (147, 1, 4, 3)\nRandom sequence: GGAGCTCGCGTATTATGTCGGTTTGTGGAATTTAGA \n\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 0 \ntemperature = 300\nCircular: False\n</pre> In\u00a0[\u00a0]: Copied! <pre># Stack extended DNA and protein back together\nprotein = pdb.atom_slice(pdb.top.select('not chainid 0 1'))\ndna_traj = dna.get_traj()\nextended_traj = dna_traj.stack(protein)\n\nview = nv.show_mdtraj(extended_traj)\nview\n</pre> # Stack extended DNA and protein back together protein = pdb.atom_slice(pdb.top.select('not chainid 0 1')) dna_traj = dna.get_traj() extended_traj = dna_traj.stack(protein)  view = nv.show_mdtraj(extended_traj) view In\u00a0[\u00a0]: Copied! <pre># Save extended traj\nextended_traj.save_pdb('./pdbs/1kx5_extended.pdb')\n</pre> # Save extended traj extended_traj.save_pdb('./pdbs/1kx5_extended.pdb') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/5_extension_tutorial/#adding-linker-dna","title":"Adding Linker DNA\u00b6","text":"<p>This tutorial demonstrates how to extend DNA sequences from a loaded structure and integrate the extended DNA with protein components. This process is useful for creating complex models for simulations or visualization, aiding in the study of DNA-protein interactions.</p>"},{"location":"notebooks/5_extension_tutorial/#steps-covered","title":"Steps Covered:\u00b6","text":"<ul> <li>Load and visualize the initial PDB structure.</li> <li>Isolate and extend the DNA component.</li> <li>Combine the extended DNA with the protein structure.</li> <li>Save the modified structure for further analysis.</li> </ul>"},{"location":"notebooks/5_extension_tutorial/#loading-and-visualizing-initial-structures","title":"Loading and Visualizing Initial Structures\u00b6","text":"<p>Start by loading a PDB file and visualize it to confirm the structure's integrity.</p>"},{"location":"notebooks/5_extension_tutorial/#extending-the-dna-structure","title":"Extending the DNA Structure\u00b6","text":"<p>Isolate the DNA part, describe its current state, and then extend it at both ends.</p>"},{"location":"notebooks/5_extension_tutorial/#integration-with-protein-structure","title":"Integration with Protein Structure\u00b6","text":"<p>Isolate the protein part of the structure, combine it with the extended DNA, and save the new structure.</p>"},{"location":"notebooks/6_connection_tutorial/","title":"Connecting Two DNA Strands","text":"In\u00a0[8]: Copied! <pre>import mdtraj as md\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport nglview as nv\n\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n%load_ext autoreload\n%autoreload 2\n\n# Load the structure\ntraj = md.load('./pdbs/8srp.pdb')\nprotein = traj.atom_slice(traj.top.select('protein'))\nview = nv.show_mdtraj(traj)\n\nview\n</pre> import mdtraj as md import numpy as np import matplotlib.pyplot as plt import nglview as nv  import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna  %load_ext autoreload %autoreload 2  # Load the structure traj = md.load('./pdbs/8srp.pdb') protein = traj.atom_slice(traj.top.select('protein')) view = nv.show_mdtraj(traj)  view <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> <pre>/Users/thor/miniforge3/envs/mdna/lib/python3.12/site-packages/mdtraj/formats/pdb/pdbfile.py:200: UserWarning: Unlikely unit cell vectors detected in PDB file likely resulting from a dummy CRYST1 record. Discarding unit cell vectors.\n  warnings.warn('Unlikely unit cell vectors detected in PDB file likely '\n</pre> <pre>NGLWidget()</pre> In\u00a0[9]: Copied! <pre>DNA_residue_names = ['DG','DC','DT','DA']\nDNA_chainids = []\nfor chain in traj.top.chains:\n    for res in chain._residues:\n         if str(res.name) in DNA_residue_names:\n            DNA_chainids.append(res.chain.index)\nDNA_chainids = np.unique(DNA_chainids)\nDNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)])\n</pre> DNA_residue_names = ['DG','DC','DT','DA'] DNA_chainids = [] for chain in traj.top.chains:     for res in chain._residues:          if str(res.name) in DNA_residue_names:             DNA_chainids.append(res.chain.index) DNA_chainids = np.unique(DNA_chainids) DNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)]) In\u00a0[10]: Copied! <pre>dna_a = mdna.load(traj=traj, chainids=DNA_chainids[0])\ndna_b = mdna.load(traj=traj, chainids=DNA_chainids[1])\n\n# Get frames to calculate control points\nframes_a = dna_a.get_frames()\nframes_b = dna_b.get_frames()\nstart = np.squeeze(frames_a[-1])[0]\nend = np.squeeze(frames_b[0])[0]\n\n# Calculate incremental positions for smoother curves\nstart_increment = start + np.array([0.5, 0, 3])\nend_increment = end + np.array([-0.5, 0, 3])\ncenter_of_mass = (start + end) / 2\ncenter_of_mass += np.array([0, 0, 1]) * 20\ncontrol_points = np.array([start, start_increment, center_of_mass, end_increment, end])\n\n# Draw initial strands and control points\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\ndna_a.draw(ax=ax, triads=True, color_lead='blue')\ndna_b.draw(ax=ax, triads=True, color_lead='red')\nax.plot(control_points[:,0], control_points[:,1], control_points[:,2], marker='o', color='g', linestyle='-', linewidth=2, markersize=12)\n</pre> dna_a = mdna.load(traj=traj, chainids=DNA_chainids[0]) dna_b = mdna.load(traj=traj, chainids=DNA_chainids[1])  # Get frames to calculate control points frames_a = dna_a.get_frames() frames_b = dna_b.get_frames() start = np.squeeze(frames_a[-1])[0] end = np.squeeze(frames_b[0])[0]  # Calculate incremental positions for smoother curves start_increment = start + np.array([0.5, 0, 3]) end_increment = end + np.array([-0.5, 0, 3]) center_of_mass = (start + end) / 2 center_of_mass += np.array([0, 0, 1]) * 20 control_points = np.array([start, start_increment, center_of_mass, end_increment, end])  # Draw initial strands and control points fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(111, projection='3d') dna_a.draw(ax=ax, triads=True, color_lead='blue') dna_b.draw(ax=ax, triads=True, color_lead='red') ax.plot(control_points[:,0], control_points[:,1], control_points[:,2], marker='o', color='g', linestyle='-', linewidth=2, markersize=12)   Out[10]: <pre>[&lt;mpl_toolkits.mplot3d.art3d.Line3D at 0x28efbc740&gt;]</pre> <p>Now the control point shave been defined we can make the loop.</p> In\u00a0[11]: Copied! <pre># Connect the strands\ndna_c = mdna.connect(dna_a, dna_b, control_points=control_points)\ndna_c.draw(ax=ax)\n</pre> # Connect the strands dna_c = mdna.connect(dna_a, dna_b, control_points=control_points) dna_c.draw(ax=ax) <pre>Optimal BP: 26, Twist Difference per BP: 0.176 degrees\nOptimal number of base pairs: 26\nRandom sequence: TGTTCTGAGCCACGTTCCCTCGACCGGACTTTAAGTGGGTCAGTCTTTTATAACCTGAGGTAAGAAGTAGAGCGTACTAGTGATGTAAGTGCAAACGAGCGTGGGGGAGACATATCGCACG \n\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 0.0 \ntemperature = 300\nCircular: False\n</pre> In\u00a0[12]: Copied! <pre># Combine DNA and protein trajectories\ndna_traj = dna_c.get_traj()\nconnected_traj = protein.stack(dna_traj)\nview = nv.show_mdtraj(connected_traj)\nview\n</pre> # Combine DNA and protein trajectories dna_traj = dna_c.get_traj() connected_traj = protein.stack(dna_traj) view = nv.show_mdtraj(connected_traj) view   <pre>NGLWidget()</pre> In\u00a0[13]: Copied! <pre># Save the combined structure\nconnected_traj.save('./pdbs/8srp_connected.pdb')\n</pre> # Save the combined structure connected_traj.save('./pdbs/8srp_connected.pdb')"},{"location":"notebooks/6_connection_tutorial/#connecting-two-dna-strands","title":"Connecting Two DNA Strands\u00b6","text":"<p>This tutorial demonstrates how to identify and connect two separate DNA strands from a loaded structure, and integrate the connected DNA with protein components. This process is essential for creating comprehensive models for visualization and analysis.</p>"},{"location":"notebooks/6_connection_tutorial/#steps-covered","title":"Steps Covered:\u00b6","text":"<ul> <li>Load and identify DNA strands in a structure containing proteins.</li> <li>Calculate and visualize control points for connecting DNA strands.</li> <li>Connect the DNA strands and integrate the result with the protein structure.</li> <li>Visualize and save the new combined structure.</li> </ul>"},{"location":"notebooks/6_connection_tutorial/#loading-the-structure-and-identifying-dna-strands","title":"Loading the Structure and Identifying DNA Strands\u00b6","text":"<p>Load a PDB file containing both DNA and protein components and identify DNA strands based on residue names.</p>"},{"location":"notebooks/6_connection_tutorial/#identifying-dna-chains","title":"Identifying DNA Chains\u00b6","text":"<p>Extract the indices of DNA chains based on common residue names for nucleotides.</p>"},{"location":"notebooks/6_connection_tutorial/#connecting-dna-strands","title":"Connecting DNA Strands\u00b6","text":"<p>Load the DNA strands, calculate control points for connection, and visualize the initial and connected states.</p>"},{"location":"notebooks/6_connection_tutorial/#visualization-and-saving-the-connected-structure","title":"Visualization and Saving the Connected Structure\u00b6","text":"<p>Combine the connected DNA with the protein structure and visualize the complete assembly.</p>"},{"location":"notebooks/7_sequence_library/","title":"The Sequence Library","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport nglview as nv\n\nimport copy\nimport nglview as nv\nimport random\nfrom Bio.SVDSuperimposer import SVDSuperimposer\n\n\n# # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction\n# import pymdna as mdna\nimport sys\nsys.path.append('/Users/thor/surfdrive/Projects/pymdna/')\nimport pymdna as mdna \n%load_ext autoreload\n%autoreload 2\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import nglview as nv  import copy import nglview as nv import random from Bio.SVDSuperimposer import SVDSuperimposer   # # Path: pymdna/__init__.py, prototype of the package and atomic is not properly referenced in the package at genertors.py now I just explicitly define the path loction # import pymdna as mdna import sys sys.path.append('/Users/thor/surfdrive/Projects/pymdna/') import pymdna as mdna  %load_ext autoreload %autoreload 2 In\u00a0[\u00a0]: Copied! <pre># Complemetary base pairs\nbase_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z','CM':'G','AH':'T','GM':'C'}\n        \n# Load reference bases from the atomic data        \nreference_bases = {base: md.load_hdf5(mdna.utils.get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in base_pair_map.keys()}\nbases = list(reference_bases.values())\n\n# Define grid to place the bases\norder = [['A', 'T', 'G', 'C'],\n        ['AH', 'U', 'GM', 'CM'], \n         ['B', 'S', 'P', 'Z'], \n         ['E', 'D','L', 'M']]\n\n\n# Initialize the trajectory with the first base\ntraj = reference_bases[order[0][0]]\n\n# Spacing parameters (in angstroms, adjust as needed)\nhorizontal_spacing = 1.2  # Spacing between bases within a row\nvertical_spacing = 1.5    # Spacing between rows\n\n# Base positions tracking\ny_position = 0  # Start at the top-most row and work downwards\n\nfor row in order:\n    x_position = 0  # Reset x position for each new row\n    for i, base in enumerate(row,1):\n        if i == 0 and row == order[0]:\n            # Already initialized with the first base\n            continue\n        # Move base in x and y direction\n        reference_bases[base].xyz[0] = reference_bases[base].xyz[0] + np.array([-x_position, y_position, 0])\n        # Stack the base to the trajectory\n        traj = traj.stack(reference_bases[base])\n        # Increment x position for the next base in the row\n        x_position += horizontal_spacing\n    # Decrement y position for the next row to position it below the current one\n    y_position -= vertical_spacing\n</pre> # Complemetary base pairs base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z','CM':'G','AH':'T','GM':'C'}          # Load reference bases from the atomic data         reference_bases = {base: md.load_hdf5(mdna.utils.get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in base_pair_map.keys()} bases = list(reference_bases.values())  # Define grid to place the bases order = [['A', 'T', 'G', 'C'],         ['AH', 'U', 'GM', 'CM'],           ['B', 'S', 'P', 'Z'],           ['E', 'D','L', 'M']]   # Initialize the trajectory with the first base traj = reference_bases[order[0][0]]  # Spacing parameters (in angstroms, adjust as needed) horizontal_spacing = 1.2  # Spacing between bases within a row vertical_spacing = 1.5    # Spacing between rows  # Base positions tracking y_position = 0  # Start at the top-most row and work downwards  for row in order:     x_position = 0  # Reset x position for each new row     for i, base in enumerate(row,1):         if i == 0 and row == order[0]:             # Already initialized with the first base             continue         # Move base in x and y direction         reference_bases[base].xyz[0] = reference_bases[base].xyz[0] + np.array([-x_position, y_position, 0])         # Stack the base to the trajectory         traj = traj.stack(reference_bases[base])         # Increment x position for the next base in the row         x_position += horizontal_spacing     # Decrement y position for the next row to position it below the current one     y_position -= vertical_spacing <p>Visualize the bases</p> In\u00a0[\u00a0]: Copied! <pre>subtraj = traj.atom_slice(traj.top.select('not element H'))\n# subtraj.save_pdb('all_bases.pdb')\n# subtraj.save_hdf5('all_bases.h5')\nview = nv.show_mdtraj(subtraj)    \nview.clear()\nview.add_representation('licorice', selection='all')\nview\n</pre> subtraj = traj.atom_slice(traj.top.select('not element H')) # subtraj.save_pdb('all_bases.pdb') # subtraj.save_hdf5('all_bases.h5') view = nv.show_mdtraj(subtraj)     view.clear() view.add_representation('licorice', selection='all') view In\u00a0[\u00a0]: Copied! <pre>def get_base_vectors(res):\n       \"\"\"Compute base vectors from reference base.\"\"\"\n       ref_base = mdna.ReferenceBase(res)\n       return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n\ndef get_rot_mat_trans(x,y):\n    # load super imposer\n    sup = SVDSuperimposer()\n\n    # Set the coords, y will be rotated and translated on x\n    sup.set(x, y)\n\n    # Do the leastsquared fit\n    sup.run()\n\n    # Get the rms\n    rms = sup.get_rms()\n\n    # Get rotation (right multiplying!) and the translation\n    rot, tran = sup.get_rotran()\n    return rot, tran\n\n# Function to calculate positions from origin and vectors\ndef calculate_positions(triad):\n    \n    origin = triad[0]\n    vectors = triad[1:]\n    # Each row in vectors is added to the origin to get the end position\n    end_positions = origin + vectors\n    # Combine the origin with these end positions\n    positions = np.vstack([origin, end_positions])\n    return positions\n\n\ndef align_to_ref(traj, ref =  np.array([[0,0,0.0],[1,0,0],[0,1,0],[0,0,1]])):\n    vectors = get_base_vectors(traj)\n    positions = calculate_positions(vectors[0])\n    ref_position =  calculate_positions(ref)\n    rot, tran = get_rot_mat_trans(ref_position,positions)\n    new_xyz = np.dot(traj.xyz[0], rot) + tran\n    traj.xyz[0] = new_xyz\n    return traj\n</pre>  def get_base_vectors(res):        \"\"\"Compute base vectors from reference base.\"\"\"        ref_base = mdna.ReferenceBase(res)        return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)  def get_rot_mat_trans(x,y):     # load super imposer     sup = SVDSuperimposer()      # Set the coords, y will be rotated and translated on x     sup.set(x, y)      # Do the leastsquared fit     sup.run()      # Get the rms     rms = sup.get_rms()      # Get rotation (right multiplying!) and the translation     rot, tran = sup.get_rotran()     return rot, tran  # Function to calculate positions from origin and vectors def calculate_positions(triad):          origin = triad[0]     vectors = triad[1:]     # Each row in vectors is added to the origin to get the end position     end_positions = origin + vectors     # Combine the origin with these end positions     positions = np.vstack([origin, end_positions])     return positions   def align_to_ref(traj, ref =  np.array([[0,0,0.0],[1,0,0],[0,1,0],[0,0,1]])):     vectors = get_base_vectors(traj)     positions = calculate_positions(vectors[0])     ref_position =  calculate_positions(ref)     rot, tran = get_rot_mat_trans(ref_position,positions)     new_xyz = np.dot(traj.xyz[0], rot) + tran     traj.xyz[0] = new_xyz     return traj In\u00a0[\u00a0]: Copied! <pre># Create a DNA sequence with a methylated base\ndna = mdna.make('GCGCG')\ndna.methylate(CpG=True)\ntraj = dna.get_traj()\n\n# Select the methylated base\nmeth = traj.atom_slice(traj.top.select('resid 1'))\n\n# Align the methylated base to the reference frame\nmeth = align_to_ref(meth)\n\n# Save the methylated base\nmeth.save('./pdbs/BDNA_CM.pdb')\nmeth.save('./pdbs/BDNA_CM.h5')\n\n# Show the methylated base\nview = nv.show_mdtraj(meth)\nview.clear()\nview.add_ball_and_stick()\nview\n</pre>  # Create a DNA sequence with a methylated base dna = mdna.make('GCGCG') dna.methylate(CpG=True) traj = dna.get_traj()  # Select the methylated base meth = traj.atom_slice(traj.top.select('resid 1'))  # Align the methylated base to the reference frame meth = align_to_ref(meth)  # Save the methylated base meth.save('./pdbs/BDNA_CM.pdb') meth.save('./pdbs/BDNA_CM.h5')  # Show the methylated base view = nv.show_mdtraj(meth) view.clear() view.add_ball_and_stick() view In\u00a0[\u00a0]: Copied! <pre>def point_mutation(sequence, position=None, new_nucleotide=None):\n    if position is None:\n        position = random.randint(0, len(sequence) - 1)\n    if new_nucleotide is None:\n        nucleotides = ['A', 'T', 'C', 'G']\n        new_nucleotide = random.choice([n for n in nucleotides if n != sequence[position]])\n    \n    mutated_sequence = list(sequence)\n    mutated_sequence[position] = new_nucleotide\n    return ''.join(mutated_sequence)\n\ndef radiate_system(dna, new_sequence, complementary=True, chainids=[0,1], verbose=False):\n\n    pdb = copy.deepcopy(dna.get_traj())   \n    if verbose:\n        print('--- current stat of the system ---')\n    s = dna.sequence\n    if len(s) != len(new_sequence):\n        raise ValueError('The length of the new sequence does not match the length of the current sequence')\n    if verbose:\n        print(len(s),s)\n        print(''.join(s))\n    mutations = mdna.get_mutations(s,new_sequence)\n    if verbose:\n        print(f'start mutation ---- {mutations} ----')    \n    # dna = pdb.atom_slice(pdb.top.select(f'chainid {chainids[0]} {chainids[1]}'))\n    # if verbose:\n    #     for c in dna.top.chains:\n    #         print(c.index, c._residues)\n\n    dna.mutate(mutations,complementary=complementary)\n    mutant_sequence = dna.sequence\n    if verbose:\n        print(mutant_sequence)\n        print(''.join(mutant_sequence))\n    new_traj = dna.get_traj()\n    if verbose:\n        for c in new_traj.top.chains:\n            print(c.index, c._residues)\n        print('--- end radiation ---')\n    return new_traj\n</pre> def point_mutation(sequence, position=None, new_nucleotide=None):     if position is None:         position = random.randint(0, len(sequence) - 1)     if new_nucleotide is None:         nucleotides = ['A', 'T', 'C', 'G']         new_nucleotide = random.choice([n for n in nucleotides if n != sequence[position]])          mutated_sequence = list(sequence)     mutated_sequence[position] = new_nucleotide     return ''.join(mutated_sequence)  def radiate_system(dna, new_sequence, complementary=True, chainids=[0,1], verbose=False):      pdb = copy.deepcopy(dna.get_traj())        if verbose:         print('--- current stat of the system ---')     s = dna.sequence     if len(s) != len(new_sequence):         raise ValueError('The length of the new sequence does not match the length of the current sequence')     if verbose:         print(len(s),s)         print(''.join(s))     mutations = mdna.get_mutations(s,new_sequence)     if verbose:         print(f'start mutation ---- {mutations} ----')         # dna = pdb.atom_slice(pdb.top.select(f'chainid {chainids[0]} {chainids[1]}'))     # if verbose:     #     for c in dna.top.chains:     #         print(c.index, c._residues)      dna.mutate(mutations,complementary=complementary)     mutant_sequence = dna.sequence     if verbose:         print(mutant_sequence)         print(''.join(mutant_sequence))     new_traj = dna.get_traj()     if verbose:         for c in new_traj.top.chains:             print(c.index, c._residues)         print('--- end radiation ---')     return new_traj In\u00a0[\u00a0]: Copied! <pre># Example usage\nsave = False\ndna = mdna.make('GCGCG')\npoint_mutations = np.unique([point_mutation(dna.sequence) for _ in range(100)])\n\nfor i, new_sequence in enumerate(point_mutations):\n    mutant = radiate_system(dna, list(new_sequence))\n    print(new_sequence,f'saved as point_mutant_{i}.pdb')\n    if save:\n        mutant.save(f'./pdbs/point_mutant_{i}.pdb')\n</pre> # Example usage save = False dna = mdna.make('GCGCG') point_mutations = np.unique([point_mutation(dna.sequence) for _ in range(100)])  for i, new_sequence in enumerate(point_mutations):     mutant = radiate_system(dna, list(new_sequence))     print(new_sequence,f'saved as point_mutant_{i}.pdb')     if save:         mutant.save(f'./pdbs/point_mutant_{i}.pdb')  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/7_sequence_library/#the-sequence-library","title":"The Sequence Library\u00b6","text":"<p>In addition to the ...</p>"},{"location":"notebooks/7_sequence_library/#how-to-add-a-base-to-the-sequence-library","title":"How to add a base to the sequence library\u00b6","text":"<p>Here we show how to align a DNA nucleobase to a specific reference frame. We chose the default reference frame at the origin with the base vectors [1,0,0], [0,1,0], [0,0,1]. This can be useful if you want to add a custom nucleobase to the sequence libary. For this we need to isolate the base and add it to the sequence library (./atomic/) and add the pdb/h5 to the reference list in geometry.py <code>NUCLEOBASE_DICT</code> which contains all the atoms that belong to the nucleobas part as well as in the modify. Mutate.mutate <code>base_pair_map</code> which defines the complementary base partner. Here we show an example using a methylated base, but you can use any sequence you want. Just select the residue that you want to isolate.</p>"},{"location":"notebooks/7_sequence_library/#point-mutations","title":"Point mutations\u00b6","text":""},{"location":"tutorials/tutorial-noncanonical/","title":"Modifying DNA Structures with Non-Canonical Nucleobases","text":"<p>The <code>mdna</code> module not only allows you to work with canonical DNA bases\u2014adenine (A), thymine (T), guanine (G), and cytosine (C)\u2014but also supports a variety of non-canonical and synthetic nucleobases. This functionality is especially powerful for researchers interested in exploring DNA sequences beyond the natural genetic code.</p>"},{"location":"tutorials/tutorial-noncanonical/#complementary-base-pairing-map","title":"Complementary Base Pairing Map","text":"<p>The complementary map includes both canonical and non-canonical bases, providing flexibility in designing sequences:</p> <pre><code>complementary_map = {\n    'A':'T', 'T':'A', 'G':'C', 'C':'G',\n    'U':'A', 'D':'G', 'E':'T', 'L':'M',\n    'M':'L', 'B':'S', 'S':'B', 'Z':'P',\n    'P':'Z'\n}\n</code></pre>"},{"location":"tutorials/tutorial-noncanonical/#overview-of-non-canonical-bases","title":"Overview of Non-Canonical Bases","text":"<ol> <li> <p>Uracil (U):     Represents RNA incorporation into DNA, pairing with adenine (A).</p> </li> <li> <p>tC (D):     A tricyclic cytosine analogue, another fluorescent base known for its unique photophysical properties, pairs with guanine (G)~\\cite{wilhelmsson2003photophysical}.</p> </li> <li> <p>2-Aminopurine (E):     A fluorescent base analogue of adenine, used in studies requiring stable fluorescence, pairs with thymine (T)~\\cite{ward1969fluorescence}.</p> </li> <li> <p>Hydrophobic Base Pair (L and M):     The hydrophobic pair, d5SICS (L) and dNaM (M), are examples of unnatural base pairs that maintain stability without hydrogen bonding, expanding the range of base pairing~\\cite{malyshev2014semi}.</p> </li> <li> <p>Hachimoji Bases (B-S and P-Z):     These bases belong to the Hachimoji DNA system, which introduces four synthetic nucleotides that form orthogonal pairs: B pairs with S, and P pairs with Z. This system adds a new dimension of complexity to DNA structure and function~\\cite{hoshika2019hachimoji}.</p> </li> </ol>"},{"location":"tutorials/tutorial-noncanonical/#mutation-and-customization","title":"Mutation and Customization","text":"<p>The <code>mutate()</code> function in mdna allows you to introduce these non-canonical bases into your DNA sequences. This capability enables the design of complex sequences for specific applications, such as studies involving fluorescence, hydrophobic interactions, or synthetic genetic systems. Example of Non-Canonical Mutation</p> <pre><code># Load a DNA sequence with canonical bases\ndna = mdna.make(sequence='AGCGATATAGA')\n\n# Mutate the first base to a non-canonical base 'L' and the last base to 'P'\ndna.mutate({0: 'L', dna.n_bp: 'P'}, complementary=False)\n\n# Describe the modified DNA structure to confirm changes\ndna.describe()\n</code></pre>"},{"location":"tutorials/tutorials-analyse/","title":"Analyse","text":""},{"location":"tutorials/tutorials-analyse/#analyzing-dna-structures-rigid-base-parameters-and-visualization","title":"Analyzing DNA Structures: Rigid Base Parameters and Visualization","text":"<p>In this section, we will analyze the DNA structure using rigid base parameters, which provide detailed information about the geometric properties of each base pair and base pair step. These parameters include shifts, tilts, rolls, and twists that describe the relative positioning and orientation of the bases within the DNA helix. The analysis will help us understand the structural dynamics and stability of DNA under various conditions.</p>"},{"location":"tutorials/tutorials-analyse/#overview-of-rigid-base-parameters","title":"Overview of Rigid Base Parameters","text":"<p>Rigid base parameters are crucial for understanding DNA's mechanical properties. They describe the geometry of each base pair and the relative orientation between consecutive base pairs. These parameters are divided into two main categories:</p>"},{"location":"tutorials/tutorials-analyse/#base-pair-parameters","title":"Base Pair Parameters:","text":"<ul> <li>Shear, Stretch, Stagger: Describe the displacement of one base relative to the other within a base pair.</li> <li>Buckle, Propeller, Opening: Describe the angular deformation within a base pair.</li> </ul>"},{"location":"tutorials/tutorials-analyse/#base-pair-step-parameters","title":"Base Pair Step Parameters:","text":"<ul> <li>Shift, Slide, Rise: Describe the relative displacement between two consecutive base pairs.</li> <li>Tilt, Roll, Twist: Describe the angular relationship between two consecutive base pairs.</li> </ul>"},{"location":"tutorials/tutorials-analyse/#example-analyzing-dna-with-rigid-base-parameters","title":"Example: Analyzing DNA with Rigid Base Parameters","text":"<p>First, we load a pre-existing DNA structure from a trajectory file. For this example, assume the files are stored in an anonymized path.</p> <pre><code>import pymdna as mdna\n\n# Load the DNA structure from the trajectory and topology files\ndna = mdna.load(filename='/path_to_data/dry_0.xtc', top='/path_to_data/dry_0.pdb')\n\n# Describe the DNA structure\ndna.describe()\n</code></pre>"},{"location":"tutorials/tutorials-analyse/#visualizing-rigid-base-parameters","title":"Visualizing Rigid Base Parameters","text":"<p>We can plot the rigid base parameters to analyze the structural features of the DNA. This visualization includes confidence intervals for each parameter to indicate the range of possible variations.</p> <pre><code># Plot per base pair with confidence interval\nrigid = dna.get_rigid_parameters()\n_ = rigid.plot_parameters()\n</code></pre> <p>In the code block above, <code>plot_parameters()</code> generates plots for each rigid base parameter across the DNA sequence, with confidence intervals that provide insight into the variability and reliability of these measurements. These plots are crucial for identifying regions of the DNA that might have unusual or significant structural deviations.</p>"},{"location":"tutorials/tutorials-analyse/#distribution-of-rigid-base-parameters","title":"Distribution of Rigid Base Parameters","text":"<p>The distribution of each parameter is plotted below to provide insight into the variability and typical values for this DNA structure.</p> <pre><code># Plot distribution per parameter\n\nparams, names = rigid.get_parameters()  \n\nimport matplotlib as mpl, matplotlib.font_manager as font_manager\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nmpl.rcParams['font.family'] = 'serif'\ncmfont = font_manager.FontProperties(fname=mpl.get_data_path() + '/fonts/ttf/cmr10.ttf')\nmpl.rcParams['font.serif'] = cmfont.get_name()\nmpl.rcParams['mathtext.fontset'] = 'cm'\nmpl.rcParams['axes.unicode_minus'] = False\nmpl.rcParams['axes.formatter.use_mathtext'] = True\n\ncolors = sns.color_palette(\"twilight\", 12)\nlims = [(-2,2),(-2,2),(-2,2),(-65,65),(-65,65),(-65,65)] + [(-3,3),(-3,3),(1.25,5),(-50,50),(-50,50),(0,60)]\nfig, ax = plt.subplots(3, 4, figsize=(6, 2.5), sharey='col')\nidx, jdx = 0, 0\n\nfor _, name in enumerate(names):\n    para = params[:, 1:, names.index(name)]\n    sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color='white', lw=5)\n    sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color=colors[_], alpha=1, lw=1)\n    ax[idx][jdx].set_title(name, x=0, y=0, color=colors[_], fontsize=10)\n    ax[idx][jdx].set_xlim(lims[_])\n\n    ax[idx][jdx].set_facecolor('none')\n    ax[idx][jdx].set_yticklabels([])\n    ax[idx][jdx].set_yticks([])\n    ax[idx][jdx].set_ylabel('')\n\n    if name in ['shear', 'buckle', 'shift', 'tilt', 'stretch', 'propeller']:\n        ax[idx][jdx].set_xticks([])\n\n    idx += 1\n    if idx == 3:\n        idx = 0\n        jdx += 1\n    if jdx == 4:\n        jdx = 0\n\n    if idx == 0 and jdx in [0, 1, 2, 3]:\n        ax[idx][jdx].set_xticklabels([])\n    if idx == 1 and jdx in [0, 1]:\n        ax[idx][jdx].set_xticklabels([])\n\nax[-1][0].set_xlabel('[nm]', fontsize=11)\nax[-1][1].set_xlabel('[degrees]', fontsize=11)\nax[-1][2].set_xlabel('[nm]', fontsize=11)\nax[-1][3].set_xlabel('[degrees]', fontsize=11)\nfig.tight_layout()\nfig.subplots_adjust(hspace=-.25)\n\nsns.despine(bottom=True, left=True)\n</code></pre> <p>In this section, we visualize the distributions of each rigid base parameter across the entire DNA sequence. By plotting the kernel density estimates (KDE) for each parameter, we can observe the typical values, variability, and any potential outliers. The customized appearance of the plots ensures that they are clear and suitable for presentation or publication.</p>"},{"location":"tutorials/tutorials-build/","title":"Build","text":""},{"location":"tutorials/tutorials-build/#advanced-dna-structure-generation-and-manipulation-with-mdna","title":"Advanced DNA Structure Generation and Manipulation with mdna","text":"<p>In this section, we'll explore more advanced functionalities of the <code>mdna</code> module, focusing on generating various DNA structures, modifying their topological properties, and using custom shapes. These tools allow you to create complex DNA configurations for detailed structural analysis.</p>"},{"location":"tutorials/tutorials-build/#1-basic-dna-creation","title":"1. Basic DNA Creation","text":"<p>You can create a DNA structure with no initial sequence, which will output a placeholder sequence ('DDD').</p> <pre><code># Build DNA with nothing, will output DDD sequence\ndna = mdna.make()\ndna.describe()\n</code></pre> <p>Alternatively, you can provide a specific sequence or define the number of base pairs (n_bp) to generate a random sequence.</p> <pre><code># Or provide a sequence\ndna = mdna.make(sequence='GCGCGCGCGC')\ndna.describe()\n\n# Or provide a number of basepairs, resulting in a random sequence\ndna = mdna.make(n_bp=10)\ndna.describe()\n</code></pre>"},{"location":"tutorials/tutorials-build/#2-circular-dna-and-topology-manipulation","title":"2. Circular DNA and Topology Manipulation","text":"<p>The <code>mdna</code> module allows the creation of circular DNA (minicircles) and the manipulation of their topological properties, such as the linking number (Lk).</p> <pre><code># Or make a minicircle DNA in circular form\ndna = mdna.make(n_bp=200, circular=True)\nprint('Lk, Wr, Tw', dna.get_linking_number())\ndna.draw()\n\n# Lets also minimize the DNA configuration\ndna.minimize()\n\n# See the final configuration\ndna.draw()\n\n# or save it to a file\ndna.save('minimized_nbp_200_closed.pdb')\n</code></pre> <p>You can also change the linking number by under- or overwinding the DNA using the <code>dLk</code> parameter.</p> <pre><code># Also change the linking number by under or overwinding the DNA using the dLk parameter\ndna = mdna.make(n_bp=200, circular=True, dLk=8)\ndna.describe()\ndna.get_linking_number()\n\n# Minimize the DNA configuration, note to equilibrate the writhe use equilibrate_writhe=True, otherwise the Lk will not be conserved\ndna.minimize(equilibrate_writhe=True)\ndna.get_linking_number()\n</code></pre>"},{"location":"tutorials/tutorials-build/#3-using-custom-shapes","title":"3. Using Custom Shapes","text":"<p>You can create DNA structures that follow custom shapes using the <code>Shape</code> class. For instance, you can generate DNA in the shape of a helix or define a completely custom path using control points.</p> <pre><code># We can also use custom shapes using the Shape class\ncontrol_points = mdna.Shapes.helix(height=3, pitch=5, radius=7, num_turns=4)\ndna = mdna.make(n_bp=300, control_points=control_points)\ndna.draw()\n\n# Or use the control points to define a custom shape\ncontrol_points = np.array([[0,0,0],[30,10,-10],[50,10,20],[3,4,30]])\ndna = mdna.make(n_bp=100, control_points=control_points, sequence=['A']*100)\ndna.draw()\ndna.describe()\ndna.sequence\n</code></pre>"},{"location":"tutorials/tutorials-build/#4-extending-dna","title":"4. Extending DNA","text":"<p>The <code>extend</code> function allows you to add additional bases to an existing DNA structure, either in the forward or reverse direction.</p> <pre><code># We can also extend our DNA \ndna.extend(sequence=['G']*120)\n\n# Or extend it in the opposite direction\ndna.extend(sequence=['C']*120, forward=False)\ndna.draw()\n</code></pre>"},{"location":"tutorials/tutorials-build/#5-connecting-dna-strands","title":"5. Connecting DNA Strands","text":"<p>You can generate two separate strands of DNA and connect them to form a continuous double helix. The <code>connect</code> function optimizes the connection to minimize the twist between the strands.</p> <pre><code># Lets generate two strands of DNA and displace the second one away from the first one\ndna0 = mdna.make(sequence='AAAAAAAAA', control_points=mdna.Shapes.line(1))\ndna1 = mdna.make(sequence='GGGGGGGGG', control_points=mdna.Shapes.line(1) + np.array([4,0,-5]))\n\n# Now we can connect the two strands, the function will find the optimal number of basepairs to connect the two strands to minimize the twist \ndna2 = mdna.connect(dna0, dna1)\ndna2.draw()\ndna2.describe()\n</code></pre>"},{"location":"tutorials/tutorials-build/#6-visualization","title":"6. Visualization","text":"<p>For advanced visualization, you can use <code>nglview</code> to visualize the Monte Carlo minimized configuration of the DNA structure.</p> <pre><code># visualize using nglview MC minimization\nview = nv.show_mdtraj(dna2.get_MC_traj())\nview\n</code></pre> <p>This concludes the advanced tutorial on generating, manipulating, and visualizing DNA structures with the <code>mdna</code> module. These examples illustrate the flexibility and power of the module in creating detailed and customized DNA configurations for a wide range of research applications.</p>"},{"location":"tutorials/tutorials-introduction/","title":"Tutorial: Generating and Analyzing DNA Structures with mdna","text":"<p>This tutorial will guide you through the process of generating DNA structures, analyzing them, and performing various modifications using the mdna module. We'll cover the following key aspects:</p> <pre><code>- Loading DNA Structures\n- Generating DNA Sequences\n- Analyzing DNA Structures\n- Modifying DNA Structures\n- Visualizing DNA\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#loading-dna-structures","title":"Loading DNA Structures","text":"<p>The mdna module allows you to load DNA structures from various sources, such as a trajectory file or directly from a sequence.</p> <p>Example: Loading from a Trajectory <pre><code>import pymdna as mdna\nimport mdtraj as md\n\n# Load a trajectory file\ntraj = md.load('/path_to_your/dna.pdb')\n\n# Load the DNA structure using the trajectory\ndna = mdna.load(traj=traj, chainids=[0, 1])\n</code></pre></p> <p>Example: Make the DNA structure directly from a sequence <pre><code>sequence = \"ATGCATGC\"\ndna = mdna.load(sequence=sequence)\n</code></pre></p>"},{"location":"tutorials/tutorials-modify/","title":"Tutorial: Generating and Analyzing DNA Structures with mdna","text":"<p>This tutorial will guide you through the process of generating DNA structures, analyzing them, and performing various modifications using the mdna module. We'll cover how to modify DNA Structures:</p> <ul> <li>Mutations</li> <li>Methylation</li> <li>Hoogsteen flips</li> </ul>"},{"location":"tutorials/tutorials-modify/#example-make-the-dna-structure-directly-from-a-sequence","title":"Example: Make the DNA structure directly from a sequence","text":"<pre><code>import pymdna as mdna\nimport mdtraj as md\n\nsequence = \"ATGCATGC\"\ndna = mdna.load(sequence=sequence)\n</code></pre>"},{"location":"tutorials/tutorials-modify/#modifying-dna-structures","title":"Modifying DNA Structures","text":"<p>The mdna module offers various functions to modify DNA structures, such as mutating bases, methylating sites, and performing Hoogsteen flips. Below are examples of how to perform these modifications.</p> <p>You can mutate specific bases in the DNA sequence. In the following example, the first base is mutated to a G, and the last base is mutated to a C.</p> <pre><code># Here we make a DNA with the following sequence\ndna = mdna.make(sequence='AGCGATATAGA')\n\n# Let's save the original structure\ntraj = dna.get_traj()\ntraj.save_pdb('dna_original.pdb')\n\n# Modify the DNA sequence\n# Mutate the first base to a G and the last base to a C\ndna.mutate({0: 'G', dna.n_bp : 'C'}, complementary=False)\n\n# Get information about the DNA and see the mutated sequence\ndna.describe()\n</code></pre> <p>Methylation can be applied to specific positions or all CpG sites. Below are examples of both approaches.</p> <pre><code># Methylate the 5th position, which is T (this will fail and is caught by the function)\ndna.methylate(methylations=[5])\n\n# Methylate all CpG sites\ndna.methylate(CpG=True)\n</code></pre> <p>You can perform a Hoogsteen flip on any base pair. In the example below, the 5th base pair is flipped by 180 degrees.</p> <pre><code># Flip the 5th base pair with a 180-degree rotation\ndna.flip(fliplist=[5], deg=180)\n</code></pre>"},{"location":"tutorials/tutorials-modify/#saving-the-modified-structure","title":"Saving the Modified Structure","text":"<p>After making modifications, you can save the modified DNA structure to a file.</p> <pre><code># Get trajectory of the modified DNA or save it as a pdb file\ntraj_mod = dna.get_traj()\ntraj_mod.save_pdb('dna_modified.pdb')\n</code></pre> <p>This concludes the tutorial on generating, analyzing, and modifying DNA structures using the mdna module. In the next tutorial, we will explore advanced visualization techniques for DNA structures.</p>"},{"location":"tutorials/tutorials-modify/#modifying-dna-structures-with-non-canonical-nucleobases","title":"Modifying DNA Structures with Non-Canonical Nucleobases","text":"<p>The <code>mdna</code> module not only allows you to work with canonical DNA bases\u2014adenine (A), thymine (T), guanine (G), and cytosine (C)\u2014but also supports a variety of non-canonical and synthetic nucleobases. This functionality is especially powerful for researchers interested in exploring DNA sequences beyond the natural genetic code.</p>"},{"location":"tutorials/tutorials-modify/#complementary-base-pairing-map","title":"Complementary Base Pairing Map","text":"<p>The complementary map includes both canonical and non-canonical bases, providing flexibility in designing sequences:</p> <pre><code>complementary_map = {\n    'A':'T', 'T':'A', 'G':'C', 'C':'G',\n    'U':'A', 'D':'G', 'E':'T', 'L':'M',\n    'M':'L', 'B':'S', 'S':'B', 'Z':'P',\n    'P':'Z'\n}\n</code></pre>"},{"location":"tutorials/tutorials-modify/#overview-of-non-canonical-bases","title":"Overview of Non-Canonical Bases","text":"<ol> <li> <p>Uracil (U):     Represents RNA incorporation into DNA, pairing with adenine (A).</p> </li> <li> <p>tC (D):     A tricyclic cytosine analogue, another fluorescent base known for its unique photophysical properties, pairs with guanine (G)~\\cite{wilhelmsson2003photophysical}.</p> </li> <li> <p>2-Aminopurine (E):     A fluorescent base analogue of adenine, used in studies requiring stable fluorescence, pairs with thymine (T)~\\cite{ward1969fluorescence}.</p> </li> <li> <p>Hydrophobic Base Pair (L and M):     The hydrophobic pair, d5SICS (L) and dNaM (M), are examples of unnatural base pairs that maintain stability without hydrogen bonding, expanding the range of base pairing~\\cite{malyshev2014semi}.</p> </li> <li> <p>Hachimoji Bases (B-S and P-Z):     These bases belong to the Hachimoji DNA system, which introduces four synthetic nucleotides that form orthogonal pairs: B pairs with S, and P pairs with Z. This system adds a new dimension of complexity to DNA structure and function~\\cite{hoshika2019hachimoji}.</p> </li> </ol>"},{"location":"tutorials/tutorials-modify/#mutation-and-customization","title":"Mutation and Customization","text":"<p>The <code>mutate()</code> function in mdna allows you to introduce these non-canonical bases into your DNA sequences. This capability enables the design of complex sequences for specific applications, such as studies involving fluorescence, hydrophobic interactions, or synthetic genetic systems. Example of Non-Canonical Mutation</p> <pre><code># Load a DNA sequence with canonical bases\ndna = mdna.make(sequence='AGCGATATAGA')\n\n# Mutate the first base to a non-canonical base 'L' and the last base to 'P'\ndna.mutate({0: 'L', dna.n_bp: 'P'}, complementary=False)\n\n# Describe the modified DNA structure to confirm changes\ndna.describe()\n</code></pre>"},{"location":"tutorials/tutorials-quickstart/","title":"Getting Started with MDNA","text":"<p>Welcome to the MDNA toolkit! This section will guide you through the basics of using MDNA to create and analyze DNA structures. By the end of this guide, you'll have written your first lines of code, generated a DNA structure, and performed basic analysis\u2014all with just a few simple steps.</p>"},{"location":"tutorials/tutorials-quickstart/#step-1-installation","title":"Step 1: Installation","text":"<p>Before you can start using MDNA, you need to install it. MDNA is a Python library, so you can install it using pip. Open your terminal and run the following command:</p> <pre><code>pip install mdna\n</code></pre> <p>or dircetly clone the github repository <pre><code>git clone --recurse-submodules -j8 git@github.com:heezch/pymdna.git\n</code></pre></p> <p>Once the installation is complete, you\u2019re ready to start coding.</p>"},{"location":"tutorials/tutorials-quickstart/#step-2-generating-a-dna-structure","title":"Step 2: Generating a DNA Structure","text":"<p>Let's dive right in by creating a simple DNA structure. We\u2019ll use MDNA to generate a double-stranded DNA with a custom sequence.</p> <pre><code>import pymdna as mdna\n\n# Generate a DNA structure from a given sequence\ndna = mdna.make(sequence=\"ATCGATCGGT\")\n\n# View basic information about the DNA structure\ndna.describe()\n\n# or quick draw the structure\ndna.draw()\n</code></pre>"},{"location":"tutorials/tutorials-quickstart/#step-3-minimizing-the-structure","title":"Step 3: Minimizing the Structure","text":"<p>Next, we\u2019ll optimize the structure to ensure it's physically realistic. This is done through energy minimization.</p> <pre><code># Minimize the energy of the DNA structure\ndna.minimize()\n</code></pre> <p>Note that by using the <code>minimize()</code> method the traj instance is updated internally. </p>"},{"location":"tutorials/tutorials-quickstart/#step-4-analyzing-the-structure","title":"Step 4: Analyzing the Structure","text":"<p>Now that we have a minimized DNA structure, let's perform some basic analysis. We\u2019ll calculate the rigid base parameters, which describe the relative positions of the base pairs.</p> <pre><code># Compute rigid base parameters\nrigid_params = dna.get_rigid_parameters()\n\n# Output the results\nprint(\"Rigid base parameters calculated:\", rigid_params.shape)\n</code></pre> <p>This step gives you a deeper understanding of the DNA\u2019s structural dynamics. The parameters calculated here are essential for more advanced studies, but don\u2019t worry\u2014just getting this far is a great start!</p>"},{"location":"tutorials/tutorials-quickstart/#conclusion-youve-done-it","title":"Conclusion: You've Done It!","text":"<p>Congratulations! You've just created, minimized, analyzed, and visualized a DNA structure using the MDNA toolkit. With these basic steps, you're well on your way to exploring the full capabilities of MDNA. Remember, the key to mastering this toolkit is practice\u2014try modifying the sequence, creating circular DNA, or analyzing different properties to see what happens.</p> <p>Now that you\u2019ve gotten started, you can dive deeper into more advanced features of MDNA. But for now, take a moment to appreciate what you've achieved. You've not only learned how to use a powerful scientific tool, but you've also taken your first steps into the world of molecular dynamics and DNA analysis.</p>"}]}