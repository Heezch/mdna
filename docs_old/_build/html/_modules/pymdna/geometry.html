<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymdna.geometry &#8212; mdna 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pymdna.geometry</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">md</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">quaternionic</span> <span class="k">as</span> <span class="nn">qt</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">RigidBody</span><span class="p">,</span> <span class="n">get_data_file_path</span><span class="p">,</span> <span class="n">get_sequence_letters</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span> 

<span class="n">NUCLEOBASE_DICT</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N9&#39;</span><span class="p">,</span> <span class="s1">&#39;C8&#39;</span><span class="p">,</span> <span class="s1">&#39;N7&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;N6&#39;</span><span class="p">,</span> <span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;O4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C7&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N9&#39;</span><span class="p">,</span> <span class="s1">&#39;C8&#39;</span><span class="p">,</span> <span class="s1">&#39;N7&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;O6&#39;</span><span class="p">,</span> <span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;N2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;N4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;O4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">,</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span><span class="s1">&#39;O2&#39;</span><span class="p">,</span><span class="s1">&#39;N3&#39;</span><span class="p">,</span><span class="s1">&#39;C4&#39;</span><span class="p">,</span><span class="s1">&#39;C6&#39;</span><span class="p">,</span><span class="s1">&#39;C14&#39;</span><span class="p">,</span><span class="s1">&#39;C13&#39;</span><span class="p">,</span><span class="s1">&#39;N5&#39;</span><span class="p">,</span><span class="s1">&#39;C11&#39;</span><span class="p">,</span><span class="s1">&#39;S12&#39;</span><span class="p">,</span><span class="s1">&#39;C7&#39;</span><span class="p">,</span><span class="s1">&#39;C8&#39;</span><span class="p">,</span><span class="s1">&#39;C9&#39;</span><span class="p">,</span><span class="s1">&#39;C10&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N9&#39;</span><span class="p">,</span> <span class="s1">&#39;C8&#39;</span><span class="p">,</span> <span class="s1">&#39;N7&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;N2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span><span class="s1">&#39;N1&#39;</span><span class="p">,</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span><span class="s1">&#39;C4&#39;</span><span class="p">,</span><span class="s1">&#39;C5&#39;</span><span class="p">,</span><span class="s1">&#39;C6&#39;</span><span class="p">,</span><span class="s1">&#39;C7&#39;</span><span class="p">,</span> <span class="s1">&#39;C8&#39;</span><span class="p">,</span><span class="s1">&#39;C9&#39;</span><span class="p">,</span><span class="s1">&#39;C10&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span><span class="s1">&#39;C4&#39;</span><span class="p">,</span><span class="s1">&#39;C5&#39;</span><span class="p">,</span><span class="s1">&#39;C6&#39;</span><span class="p">,</span><span class="s1">&#39;C20&#39;</span><span class="p">,</span><span class="s1">&#39;C21&#39;</span><span class="p">,</span><span class="s1">&#39;C22&#39;</span><span class="p">,</span><span class="s1">&#39;C23&#39;</span><span class="p">,</span><span class="s1">&#39;O37&#39;</span><span class="p">,</span><span class="s1">&#39;C38&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;N2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;N5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;O6&#39;</span><span class="p">,</span> <span class="s1">&#39;C7&#39;</span><span class="p">,</span> <span class="s1">&#39;C8&#39;</span><span class="p">,</span> <span class="s1">&#39;N9&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;N4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;ON1&#39;</span><span class="p">,</span> <span class="s1">&#39;ON2&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;C7&#39;</span><span class="p">,</span> <span class="s1">&#39;N2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;N5&#39;</span><span class="p">,</span> <span class="s1">&#39;O4&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;N9&#39;</span><span class="p">,</span> <span class="s1">&#39;C8&#39;</span><span class="p">,</span> <span class="s1">&#39;N7&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;N6&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">]}</span>

<div class="viewcode-block" id="ReferenceBase">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.ReferenceBase">[docs]</a>
<span class="k">class</span> <span class="nc">ReferenceBase</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="c1"># Determine base type (purine/pyrimidine/other)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_base_type</span><span class="p">()</span>
        <span class="c1"># Define the Tsukuba convention parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">141.478</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">54.418</span><span class="p">),</span> <span class="mf">0.4702</span>     
        <span class="c1"># Get coordinates of key atoms based on base type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C1_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span>
        <span class="c1"># Calculate base reference point and base vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_base_frame</span><span class="p">()</span>
        <span class="c1"># self.basis = np.array([self.b_D.T, self.b_L.T, self.b_N])</span>
    
    <span class="k">def</span> <span class="nf">_select_atom_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Select an atom by name returns shape (n_frames, 1, [x,y,z])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,[</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]],:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
<div class="viewcode-block" id="ReferenceBase.get_base_type">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.ReferenceBase.get_base_type">[docs]</a>
    <span class="k">def</span> <span class="nf">get_base_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Extracts all non-hydrogen atoms from the trajectory topology</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">symbol</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
    
        <span class="c1"># Check each base in the dictionary to see if all its atoms are present in the extracted atoms set</span>
        <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">base_atoms</span> <span class="ow">in</span> <span class="n">NUCLEOBASE_DICT</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">base_atoms</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">base</span>
        <span class="c1"># If no base matches, raise an error</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot determine the base type from the PDB file.&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="ReferenceBase.get_coordinates">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.ReferenceBase.get_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Get the coordinates of key atoms based on the base type</span>
        <span class="n">C1_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s1">&#39;&quot;C1</span><span class="se">\&#39;</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;U&#39;</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">]:</span><span class="c1"># &quot;pyrimidine&quot;</span>
            <span class="n">N_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;N1&quot;</span><span class="p">)</span>
            <span class="n">C_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;C2&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;G&#39;</span><span class="p">,</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;P&#39;</span><span class="p">]:</span><span class="c1"># &quot;purine&quot;:</span>
            <span class="n">N_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;N9&quot;</span><span class="p">)</span>
            <span class="n">C_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;C4&quot;</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]:</span> <span class="c1"># Hachi pyrimidine analogues</span>
            <span class="n">N_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;C1&quot;</span><span class="p">)</span>
            <span class="n">C_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;C2&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]:</span> <span class="c1"># UBPs hydrophobic</span>
            <span class="n">N_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;N1&quot;</span><span class="p">)</span>
            <span class="n">C_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;C5&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]:</span> <span class="c1"># UBPs hydrophilic</span>
            <span class="n">N_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;C1&quot;</span><span class="p">)</span>
            <span class="n">C_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_atom_by_name</span><span class="p">(</span><span class="s2">&quot;C6&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C1_coords</span><span class="p">,</span> <span class="n">N_coords</span><span class="p">,</span> <span class="n">C_coords</span></div>

    
    
<div class="viewcode-block" id="ReferenceBase.calculate_base_frame">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.ReferenceBase.calculate_base_frame">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_base_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Calculate normal vector using cross product of vectors formed by key atoms</span>
        <span class="c1">#  The coords have the shape (n,1,3)</span>
        <span class="n">b_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_coords</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">C1_coords</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_coords</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">C_coords</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b_N</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b_N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Normalize b_N to have unit length</span>

        <span class="c1"># Compute displacement vector N-C1&#39; </span>
        <span class="n">N_C1_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C1_coords</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_coords</span>  <span class="c1"># Pointing from N to C1&#39;</span>
        <span class="n">N_C1_vector</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">N_C1_vector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Rotate N-C1&#39; vector by angle tau_1 around b_N to get the direction for displacement</span>
        <span class="n">R_b_R</span> <span class="o">=</span> <span class="n">RigidBody</span><span class="o">.</span><span class="n">get_rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_1</span> <span class="o">*</span> <span class="n">b_N</span><span class="p">)</span>
       
        <span class="c1"># Displace N along this direction by a distance d to get b_R</span>
        <span class="n">b_R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_coords</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">R_b_R</span><span class="p">,</span> <span class="n">N_C1_vector</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
     
        <span class="c1"># Take a unit vector in the N-C1&#39; direction, rotate it around b_N by angle tau_2 to get b_L</span>
        <span class="n">R_b_L</span> <span class="o">=</span> <span class="n">RigidBody</span><span class="o">.</span><span class="n">get_rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_2</span> <span class="o">*</span> <span class="n">b_N</span><span class="p">)</span>
        <span class="n">b_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">R_b_L</span><span class="p">,</span> <span class="n">N_C1_vector</span><span class="p">)</span> 

        <span class="c1"># Calculate b_D using cross product of b_L and b_N</span>
        <span class="n">b_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b_L</span><span class="p">,</span> <span class="n">b_N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b_R</span><span class="p">,</span> <span class="n">b_D</span><span class="p">,</span> <span class="n">b_L</span><span class="p">,</span> <span class="n">b_N</span><span class="p">])</span></div>

        <span class="c1">#return np.array([b_R, -b_D, -b_L, -b_N])</span>

<div class="viewcode-block" id="ReferenceBase.plot_baseframe">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.ReferenceBase.plot_baseframe">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_baseframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Plot the DNA atoms</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">atoms_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>

        <span class="c1"># Plot the reference frame vectors</span>
        <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">b_L</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_L</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_L</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> 
                    <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">b_D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> 
                    <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">b_N</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_N</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_N</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> 
                    <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">fig</span><span class="p">:</span> 
            <span class="c1"># Make axes of equal length</span>
            <span class="n">max_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> 
                <span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> 
                <span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="n">mid_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">mid_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">mid_z</span> <span class="o">=</span> <span class="p">(</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">atoms_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">mid_x</span> <span class="o">-</span> <span class="n">max_range</span><span class="p">,</span> <span class="n">mid_x</span> <span class="o">+</span> <span class="n">max_range</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">mid_y</span> <span class="o">-</span> <span class="n">max_range</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">+</span> <span class="n">max_range</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">mid_z</span> <span class="o">-</span> <span class="n">max_range</span><span class="p">,</span> <span class="n">mid_z</span> <span class="o">+</span> <span class="n">max_range</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="NucleicFrames">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames">[docs]</a>
<span class="k">class</span> <span class="nc">NucleicFrames</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example Usage:</span>
<span class="sd">    </span>
<span class="sd">    loc = &#39;/Users/thor/surfdrive/Scripts/notebooks/HNS-sequence/WorkingDir/nolinker/data/md/0_highaff/FI/drytrajs/&#39;</span>
<span class="sd">    traj = md.load(loc+&#39;dry_10.xtc&#39;,top=loc+&#39;dry_10.pdb&#39;)</span>

<span class="sd">    dna = NucleicFrames(traj)</span>
<span class="sd">    params, names = dna.get_paramters()</span>
<span class="sd">    params.shape, names</span>

<span class="sd">    # Confidence intervals </span>
<span class="sd">    from scipy.stats import t</span>

<span class="sd">    fig, ax = plt.subplots(2,6,figsize=(12,4))</span>
<span class="sd">    fig.tight_layout()</span>
<span class="sd">    ax = ax.flatten()</span>
<span class="sd">    M = np.mean(params, axis=0)</span>
<span class="sd">    S = np.std(params, axis=0)</span>
<span class="sd">    n = params.shape[0]</span>
<span class="sd">    ci = t.ppf(0.975, df=n-1) * S / np.sqrt(n)</span>
<span class="sd">    x = np.arange(0, params.shape[1])</span>
<span class="sd">    for _, i in enumerate(M.T):</span>
<span class="sd">        if _ &gt;= 6:</span>
<span class="sd">            c1, c2 = &#39;red&#39;,&#39;coral&#39;</span>
<span class="sd">        else:</span>
<span class="sd">            c1, c2 = &#39;blue&#39;,&#39;cornflowerblue&#39;</span>
<span class="sd">        ax[_].plot(i[::-1], &#39;-o&#39;,color=c1)</span>
<span class="sd">        ax[_].fill_between(x, (i-ci[_])[::-1], (i+ci[_])[::-1], color=c2, alpha=0.2)</span>
<span class="sd">        ax[_].set_title(names[_])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span> <span class="n">chainids</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">frames_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_residues</span><span class="p">(</span><span class="n">chain_index</span><span class="o">=</span><span class="n">chainids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_residues</span><span class="p">(</span><span class="n">chain_index</span><span class="o">=</span><span class="n">chainids</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_reference_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_A</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reference_frames</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyse_frames</span><span class="p">()</span>

<div class="viewcode-block" id="NucleicFrames.get_residues">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chain_index</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get residues from specified chain.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chain_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">_chains</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Chain index out of range.&quot;</span><span class="p">)</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">_chains</span><span class="p">[</span><span class="n">chain_index</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">_residues</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">residues</span><span class="p">))</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">residues</span></div>


<div class="viewcode-block" id="NucleicFrames.load_reference_bases">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.load_reference_bases">[docs]</a>
    <span class="k">def</span> <span class="nf">load_reference_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load reference bases from local files.&quot;&quot;&quot;</span>
        <span class="c1"># Not used at the moment??</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
        <span class="c1">#return {f&#39;D{base}&#39;: md.load_pdb(get_data_file_path(f&#39;./atomic/NDB96_{base}.pdb&#39;)) for base in bases}</span>
        <span class="k">return</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;D</span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">load_hdf5</span><span class="p">(</span><span class="n">get_data_file_path</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;./atomic/bases/BDNA_</span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s1">.h5&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">}</span></div>


<div class="viewcode-block" id="NucleicFrames.get_base_vectors">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.get_base_vectors">[docs]</a>
    <span class="k">def</span> <span class="nf">get_base_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute base vectors from reference base.&quot;&quot;&quot;</span>
        <span class="n">ref_base</span> <span class="o">=</span> <span class="n">ReferenceBase</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ref_base</span><span class="o">.</span><span class="n">b_R</span><span class="p">,</span> <span class="n">ref_base</span><span class="o">.</span><span class="n">b_L</span><span class="p">,</span> <span class="n">ref_base</span><span class="o">.</span><span class="n">b_D</span><span class="p">,</span> <span class="n">ref_base</span><span class="o">.</span><span class="n">b_N</span><span class="p">])</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="NucleicFrames.get_reference_frames">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.get_reference_frames">[docs]</a>
    <span class="k">def</span> <span class="nf">get_reference_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get reference frames for each residue.&quot;&quot;&quot;</span>
        <span class="n">reference_frames</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Dictionary to store the base vectors for each residue</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_A</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_B</span><span class="p">:</span>
            <span class="n">res_traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">atom_slice</span><span class="p">([</span><span class="n">at</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
            <span class="n">base_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_base_vectors</span><span class="p">(</span><span class="n">res_traj</span><span class="p">)</span>
            <span class="n">reference_frames</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_vectors</span> <span class="c1"># Store the base vectors for the residue index (with shape (4, n_frames, 3))</span>
        <span class="k">return</span> <span class="n">reference_frames</span></div>


<div class="viewcode-block" id="NucleicFrames.reshape_input">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.reshape_input">[docs]</a>
    <span class="k">def</span> <span class="nf">reshape_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">input_A</span><span class="p">,</span><span class="n">input_B</span><span class="p">,</span><span class="n">is_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function reshapes the input to the correct format for the calculations. </span>
<span class="sd">        And splits the input into rotation matrices and origins for the calculations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        rotation_A/rotation_B : ndarray</span>
<span class="sd">            The rotation matrices of shape (n, 3, 3) for the first triad.</span>
<span class="sd">        origin_A/origin_B : ndarray</span>
<span class="sd">            The origins of shape (n, 3) for the first triad.</span>
<span class="sd">        original_shape : tuple</span>
<span class="sd">            The original shape of the input.&quot;&quot;&quot;</span>

        <span class="c1"># Store original shape</span>
        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">input_A</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Flatten frames to compute rotation matrices for each time step simultaneously</span>
        <span class="n">input_A_</span> <span class="o">=</span> <span class="n">input_A</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">original_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">original_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># shape (n, 4, 3)</span>
        <span class="n">input_B_</span> <span class="o">=</span> <span class="n">input_B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">original_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">original_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># shape (n, 4, 3)</span>

        <span class="c1"># Extract the triads without origin (rotation matrices)</span>
        <span class="n">rotation_A</span> <span class="o">=</span> <span class="n">input_A_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># shape (n, 3, 3)</span>
        <span class="n">rotation_B</span> <span class="o">=</span> <span class="n">input_B_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># shape (n, 3, 3)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_step</span><span class="p">:</span>
            <span class="c1"># flip (connecting the backbones) and the (baseplane normals).</span>
            <span class="c1"># so the second and third vector b_L, b_N</span>
            <span class="n">rotation_B</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
     
        <span class="c1"># Extract origins of triads</span>
        <span class="n">origin_A</span> <span class="o">=</span> <span class="n">input_A_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># shape (n, 3)</span>
        <span class="n">origin_B</span> <span class="o">=</span> <span class="n">input_B_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># shape (n, 3)</span>

        <span class="k">return</span> <span class="n">rotation_A</span><span class="p">,</span> <span class="n">rotation_B</span><span class="p">,</span> <span class="n">origin_A</span><span class="p">,</span> <span class="n">origin_B</span><span class="p">,</span> <span class="n">original_shape</span></div>



<div class="viewcode-block" id="NucleicFrames.compute_parameters">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.compute_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotation_A</span><span class="p">,</span> <span class="n">rotation_B</span><span class="p">,</span> <span class="n">origin_A</span><span class="p">,</span> <span class="n">origin_B</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the parameters between each base pair and mean reference frames.</span>
<span class="sd">        See chapter 2: Kinematics of rigid base and rigid base pair models of DNA</span>
<span class="sd">        Of Thesis: &quot;A DNA Coarse-Grain Rigid Base Model and Parameter Estimation from Molecular Dynamics Simulations&quot; by Daiva Petkevičiūtė</span>

<span class="sd">        Rotations contain rotation matrices of shape (n, 3, 3) and origins contain the origins of shape (n, 3).</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        rigid_parameters : ndarray</span>
<span class="sd">            The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.</span>
<span class="sd">        trans_mid : ndarray</span>
<span class="sd">            The mean translational vector of shape (n, 3) between the triads.</span>
<span class="sd">        rotation_mid : ndarray</span>
<span class="sd">            The mean rotation matrix of shape (n, 3, 3) between the triads.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Linear interpolation of translations</span>
        <span class="n">trans_mid</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">origin_A</span> <span class="o">+</span> <span class="n">origin_B</span><span class="p">)</span>
    
        <span class="c1"># Relative translation</span>
        <span class="n">trans_AB</span> <span class="o">=</span> <span class="n">origin_A</span> <span class="o">-</span> <span class="n">origin_B</span>

        <span class="c1"># Get relative rotation matrix of base pair</span>
        <span class="n">rotation_BA</span> <span class="o">=</span> <span class="n">rotation_B</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">rotation_A</span>  <span class="c1"># returns shape (n, 3, 3)</span>

        <span class="c1"># Get rotation angles based on  rotation matrices</span>
        <span class="n">rotation_angle_BA</span> <span class="o">=</span> <span class="n">RigidBody</span><span class="o">.</span><span class="n">extract_omega_values</span><span class="p">(</span><span class="n">rotation_BA</span><span class="p">)</span>

        <span class="c1"># Compute halfway rotation matrix and triad (mid frame)</span>
        <span class="n">rotation_halfway</span> <span class="o">=</span> <span class="n">RigidBody</span><span class="o">.</span><span class="n">get_rotation_matrix</span><span class="p">(</span><span class="n">rotation_angle_BA</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Get rotation matrix of base pair (aka mean rotation frame)</span>
        <span class="n">rotation_mid</span> <span class="o">=</span> <span class="n">rotation_B</span> <span class="o">@</span> <span class="n">rotation_halfway</span> 
        
        <span class="c1"># Get transaltional coordinate vector and convert to angstroms</span>
        <span class="n">translational_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span><span class="n">rotation_mid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">trans_AB</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>

        <span class="c1"># Get rotational parameters and convert to degrees</span>
        <span class="n">rotational_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">rotation_BA</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">rotation_angle_BA</span><span class="p">))</span>
                
        <span class="c1"># Merge translational and rotational parameters</span>
        <span class="n">rigid_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">translational_parameters</span><span class="p">,</span> <span class="n">rotational_parameters</span><span class="p">))</span>

        <span class="c1"># Return the parameters and the mean reference frame</span>
        <span class="k">return</span> <span class="n">rigid_parameters</span><span class="p">,</span> <span class="n">trans_mid</span><span class="p">,</span> <span class="n">rotation_mid</span></div>



<div class="viewcode-block" id="NucleicFrames.calculate_parameters">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.calculate_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">frames_A</span><span class="p">,</span> <span class="n">frames_B</span><span class="p">,</span> <span class="n">is_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the parameters between each base pair and mean reference frames.</span>
<span class="sd">        </span>
<span class="sd">        Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads.</span>
<span class="sd">        The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame.</span>
<span class="sd">        With the order of the vectors being: b_R, b_L, b_D, b_N.</span>
<span class="sd">        </span>
<span class="sd">        Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.</span>
<span class="sd">        mean_reference_frames : ndarray</span>
<span class="sd">            The mean reference frames of shape (n_frames, n_residues, 4, 3) representing the mean reference frame of each base pair.&quot;&quot;&quot;</span>

        <span class="c1"># Reshape frames</span>
        <span class="n">rotation_A</span><span class="p">,</span> <span class="n">rotation_B</span><span class="p">,</span> <span class="n">origin_A</span><span class="p">,</span> <span class="n">origin_B</span><span class="p">,</span> <span class="n">original_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_input</span><span class="p">(</span><span class="n">frames_A</span><span class="p">,</span><span class="n">frames_B</span><span class="p">,</span> <span class="n">is_step</span><span class="o">=</span><span class="n">is_step</span><span class="p">)</span>

        <span class="c1"># Compute parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_step</span><span class="p">:</span>
            <span class="c1"># Flip from row to column representation of the rotation matrices</span>
            <span class="n">rotation_A</span> <span class="o">=</span> <span class="n">rotation_A</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">rotation_B</span> <span class="o">=</span> <span class="n">rotation_B</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">mean_origin</span><span class="p">,</span> <span class="n">mean_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_parameters</span><span class="p">(</span><span class="n">rotation_A</span><span class="p">,</span> <span class="n">rotation_B</span><span class="p">,</span> <span class="n">origin_A</span><span class="p">,</span> <span class="n">origin_B</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Switch the input of the B and A triads to get the correct parameters</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">mean_origin</span><span class="p">,</span> <span class="n">mean_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_parameters</span><span class="p">(</span><span class="n">rotation_B</span><span class="p">,</span> <span class="n">rotation_A</span><span class="p">,</span> <span class="n">origin_B</span><span class="p">,</span> <span class="n">origin_A</span><span class="p">)</span>

        <span class="c1"># Reshape the parameters to the original shape</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Collect mean reference frames from mid frames of each base pair</span>
        <span class="n">mean_reference_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">mean_origin</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span><span class="n">mean_rotation</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_step</span><span class="p">:</span>
            <span class="c1"># Creating an array of zeros with shape (10000, 1, 6)</span>
            <span class="n">extra_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

            <span class="c1"># Concatenating the existing array and the extra column along the second axis</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">extra_column</span><span class="p">,</span><span class="n">params</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Return the parameters and the mean reference frames</span>
        <span class="k">return</span>  <span class="n">params</span><span class="p">,</span> <span class="n">mean_reference_frames</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_step</span> <span class="k">else</span> <span class="n">params</span></div>



<div class="viewcode-block" id="NucleicFrames.analyse_frames">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.analyse_frames">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyze the trajectory and compute parameters.&quot;&quot;&quot;</span>

        <span class="c1"># Get base reference frames for each residue</span>
        <span class="n">frames_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_A</span><span class="p">])</span>
        <span class="n">frames_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_B</span><span class="p">])</span>

        <span class="c1"># Compute parameters between each base pair and mean reference frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bp_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_reference_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_parameters</span><span class="p">(</span><span class="n">frames_A</span><span class="p">,</span> <span class="n">frames_B</span><span class="p">)</span>
        
        <span class="c1"># Extract mean reference frames for each neighboring base pair</span>
        <span class="n">B1_triads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_reference_frames</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># select all but the last frame</span>
        <span class="n">B2_triads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_reference_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># select all but the first frame</span>

        <span class="c1"># Compute parameters between each base pair and mean reference frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_parameters</span><span class="p">(</span><span class="n">B1_triads</span><span class="p">,</span> <span class="n">B2_triads</span><span class="p">,</span> <span class="n">is_step</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="NucleicFrames.get_parameters">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames.get_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the computed parameters of shape (n_frames, n_base_pairs, n_parameters)&quot;&quot;&quot;</span>
        <span class="n">step_parameter_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="s1">&#39;slide&#39;</span><span class="p">,</span> <span class="s1">&#39;rise&#39;</span><span class="p">,</span> <span class="s1">&#39;tilt&#39;</span><span class="p">,</span> <span class="s1">&#39;roll&#39;</span><span class="p">,</span> <span class="s1">&#39;twist&#39;</span><span class="p">]</span>
        <span class="n">base_parameter_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shear&#39;</span><span class="p">,</span> <span class="s1">&#39;stretch&#39;</span><span class="p">,</span> <span class="s1">&#39;stagger&#39;</span><span class="p">,</span> <span class="s1">&#39;buckle&#39;</span><span class="p">,</span> <span class="s1">&#39;propeller&#39;</span><span class="p">,</span> <span class="s1">&#39;opening&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">step</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">base</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_params</span><span class="p">,</span> <span class="n">step_parameter_names</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">step</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bp_params</span><span class="p">,</span> <span class="n">base_parameter_names</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">step</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">base</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">bp_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_params</span><span class="p">)),</span> <span class="n">base_parameter_names</span> <span class="o">+</span> <span class="n">step_parameter_names</span></div>
</div>

        
        

<div class="viewcode-block" id="NucleicFrames_quaternion">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion">[docs]</a>
<span class="k">class</span> <span class="nc">NucleicFrames_quaternion</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span><span class="n">chainids</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">euler</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cayley</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">angle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler</span> <span class="o">=</span> <span class="n">euler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cayley</span> <span class="o">=</span> <span class="n">cayley</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cayley</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">euler</span> <span class="o">=</span> <span class="kc">True</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_list</span> <span class="o">=</span> <span class="n">get_sequence_letters</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span><span class="n">leading_chain</span><span class="o">=</span><span class="n">chainids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_residues</span><span class="p">(</span><span class="n">chain_index</span><span class="o">=</span><span class="n">chainids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_residues</span><span class="p">(</span><span class="n">chain_index</span><span class="o">=</span><span class="n">chainids</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_base_reference_frames</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_quats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyze</span><span class="p">()</span>
        

    <span class="k">def</span> <span class="nf">_get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chain_index</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get residues from specified chain.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chain_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">_chains</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Chain index out of range.&quot;</span><span class="p">)</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">_chains</span><span class="p">[</span><span class="n">chain_index</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">_residues</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">residues</span><span class="p">))</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">residues</span>

    <span class="k">def</span> <span class="nf">_get_base_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute base vectors from reference base.&quot;&quot;&quot;</span>
        <span class="n">ref_base</span> <span class="o">=</span> <span class="n">ReferenceBase</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ref_base</span><span class="o">.</span><span class="n">b_R</span><span class="p">,</span> <span class="n">ref_base</span><span class="o">.</span><span class="n">b_L</span><span class="p">,</span> <span class="n">ref_base</span><span class="o">.</span><span class="n">b_D</span><span class="p">,</span> <span class="n">ref_base</span><span class="o">.</span><span class="n">b_N</span><span class="p">])</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
<div class="viewcode-block" id="NucleicFrames_quaternion.get_base_reference_frames">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.get_base_reference_frames">[docs]</a>
    <span class="k">def</span> <span class="nf">get_base_reference_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get reference frames for each residue.</span>

<span class="sd">            The MDtraj residue instance is the key to the  value which contains </span>
<span class="sd">            the reference point and base vectors for each frame (n_frames, 4, 3).</span>
<span class="sd">            The base vectors are ordered as follows: b_R, b_L, b_D, b_N.    </span>

<span class="sd">        Returns:</span>
<span class="sd">            reference_frames: Dictionary to store the base vectors for each residue.                   </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reference_frames</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Dictionary to store the base vectors for each residue</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_A</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_B</span><span class="p">:</span>
            <span class="n">res_traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">atom_slice</span><span class="p">([</span><span class="n">at</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
            <span class="n">base_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_vectors</span><span class="p">(</span><span class="n">res_traj</span><span class="p">)</span>
            <span class="n">reference_frames</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_vectors</span> <span class="c1"># Store the base vectors for the residue index (with shape (4, n_frames, 3))</span>
        <span class="k">return</span> <span class="n">reference_frames</span></div>

    
    
<div class="viewcode-block" id="NucleicFrames_quaternion.convert_base_frame">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.convert_base_frame">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_base_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">anti</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a base pair frame to a translation and quaternion representation.</span>
<span class="sd">        Args:</span>
<span class="sd">            frame: a 4x4 matrix representing the base pair frame where the rotations are stored row wise</span>
<span class="sd">        </span>
<span class="sd">            Unflips the quaternion if necessary when dealing with time series data. </span>
<span class="sd">        </span>
<span class="sd">        returns: a tuple of (translations, quaternion)&quot;&quot;&quot;</span>

        <span class="c1"># flip (connecting the backbones) and the (baseplane normals) (2,3)  vector b_L, b_N</span>
        <span class="k">if</span> <span class="n">anti</span><span class="p">:</span>
            <span class="n">frame</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Get the translation and rotation from the base pair frame</span>
        <span class="n">translations</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># extract translations</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># extract rotation matrices as column vectors</span>

        <span class="c1"># Convert the rotation matrices to quaternions</span>
        <span class="n">quaternion</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">from_rotation_matrix</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
        <span class="c1">#quaternion = quaternion.to_minimal_rotation(range(quaternion.shape[0]))</span>
        <span class="c1"># quaternion = qt.array([[np.abs(q.w),q.x, q.y, q.z] for q in quaternion])</span>
        <span class="c1"># print(quaternion.shape,quaternion[0])</span>
        <span class="c1"># # Check if the quaternion needs to be unflipped when dealing with time series</span>
        <span class="c1"># if quaternion.shape[0] &gt; 1:</span>
        <span class="c1">#     #quaternion = qt.unflip_rotors(quaternion)</span>
        <span class="c1">#     quaternion = quaternion.to_minimal_rotation(range(quaternion.shape[0]),iterations=100)</span>
            
      <span class="c1"># Return the translation and quaternion</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">translations</span><span class="p">,</span> <span class="n">quaternion</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="NucleicFrames_quaternion.process_chain">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.process_chain">[docs]</a>
    <span class="k">def</span> <span class="nf">process_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residues</span><span class="p">,</span> <span class="n">anti</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the chain and convert the base frames to translation and quaternion representations.&quot;&quot;&quot;</span>

        <span class="c1"># Preallocate numpy arrays for efficiency</span>
        <span class="n">translations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">quaternions</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>

        <span class="c1"># Loop through the residues and convert the base frames to translation and quaternion representations</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">residues</span><span class="p">):</span>
            <span class="n">translations</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">quaternions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_base_frame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_frames</span><span class="p">[</span><span class="n">res</span><span class="p">]),</span><span class="n">anti</span><span class="o">=</span><span class="n">anti</span><span class="p">)</span>

        <span class="c1"># Flatten the arrays to stack all residues after one another</span>
        <span class="k">return</span> <span class="n">translations</span><span class="p">,</span> <span class="n">quaternions</span></div>





<div class="viewcode-block" id="NucleicFrames_quaternion.compute_parameters_">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_parameters_">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_parameters_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">translations_A</span><span class="p">,</span> <span class="n">quaternions_A</span><span class="p">,</span> <span class="n">translations_B</span><span class="p">,</span> <span class="n">quaternions_B</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the rigid body parameters between two frames.&quot;&quot;&quot;</span>
        
        <span class="c1"># Linear interpolation of translations</span>
        <span class="n">trans_mid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">translations_A</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">translations_B</span>

        <span class="c1"># Slerp (spherical linear interpolation) for quaternion</span>
        <span class="c1"># Note that output slerp(q1, q2, 1) may be different from q2. (slerp(q1, q2, 0) is always equal to q1.)</span>
        <span class="n">quat_mid</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">slerp</span><span class="p">(</span><span class="n">quaternions_A</span><span class="p">,</span> <span class="n">quaternions_B</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># Convert quaternion to rotation matrix</span>
        <span class="n">rotation_mid</span> <span class="o">=</span> <span class="n">quat_mid</span><span class="o">.</span><span class="n">to_rotation_matrix</span>  

        <span class="c1"># Compute the relative translation</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">translations_A</span> <span class="o">-</span> <span class="n">translations_B</span>

        <span class="c1"># Get translational coordinate vector and convert to angstroms</span>
        <span class="n">translational_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">rotation_mid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">translation</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>

        <span class="c1"># Get the elative rotation matrix</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">quaternions_B</span><span class="o">.</span><span class="n">inverse</span> <span class="o">*</span> <span class="n">quaternions_A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_angle</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler</span><span class="p">:</span>
            <span class="c1"># https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html</span>
            <span class="c1"># We have to be careful because the gimbal lock problem can occur when the pitch angle is close to +/-90 degrees,</span>
            <span class="c1"># or the yaw and roll axes of rotation are aligned with each other in the world coordinate system, and therefore produce the same effect.</span>
            <span class="c1"># See link above for more details on how to mitigate this problem.</span>
            <span class="c1"># Maybe also have another look at: https://amu.hal.science/hal-03848730/document</span>
            <span class="c1"># Title: Quaternion to Euler angles conversion: a direct, general and computationally efficient method from 2022</span>
            <span class="n">pitch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="n">yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">w</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="n">roll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">z</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">w</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="c1"># # </span>
            <span class="c1"># # # Initialize yaw and roll with default values that will apply when no specific condition is met</span>
            <span class="c1"># yaw = np.zeros_like(pitch)</span>
            <span class="c1"># roll = np.zeros_like(pitch)</span>

            <span class="c1"># # Condition for pitch = pi/2</span>
            <span class="c1"># mask_pi_2 = pitch == np.pi/2</span>
            <span class="c1"># yaw[mask_pi_2] = -np.arctan2(A.x[mask_pi_2],A.w[mask_pi_2])</span>
            <span class="c1"># roll[mask_pi_2] = 0.0</span>

            <span class="c1"># # Condition for pitch = -pi/2</span>
            <span class="c1"># mask_neg_pi_2 = pitch == -np.pi/2</span>
            <span class="c1"># yaw[mask_neg_pi_2] = np.arctan2(A.x[mask_neg_pi_2],A.w[mask_neg_pi_2])</span>
            <span class="c1"># roll[mask_neg_pi_2] = 0.0</span>

            <span class="c1"># # Default condition (where neither pi/2 nor -pi/2 conditions are met)</span>
            <span class="c1"># mask_else = ~(mask_pi_2 | mask_neg_pi_2)</span>
            <span class="c1"># yaw[mask_else] = np.arctan2(2.0*(A.y[mask_else]*A.z[mask_else] + A.w[mask_else]*A.x[mask_else]),</span>
            <span class="c1">#                             A.w[mask_else]**2 - A.x[mask_else]**2 - A.y[mask_else]**2 + A.z[mask_else]**2)</span>
            <span class="c1"># roll[mask_else] = np.arctan2(2.0*(A.x[mask_else]*A.y[mask_else] + A.w[mask_else]*A.z[mask_else]),</span>
            <span class="c1">#                             A.w[mask_else]**2 + A.x[mask_else]**2 - A.y[mask_else]**2 - A.z[mask_else]**2)</span>
        
                
            <span class="n">rotational_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">yaw</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">roll</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get axis angle representation of the relative rotation matrix</span>
            <span class="c1"># Each vector represents the axis of the rotation, with norm equal to the angle of the rotation in radians.</span>
            <span class="n">rotational_parameters</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to_axis_angle</span> <span class="c1"># unfortunately this results in angle wraps.</span>

        <span class="c1"># Stack the translational and rotational parameters and convert the latter to degrees</span>
        <span class="n">rigid_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">translational_parameters</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">rotational_parameters</span><span class="p">)))</span>

        <span class="c1"># Return the rigid body parameters and the mid/halfway transformation</span>
        <span class="k">return</span> <span class="n">rigid_parameters</span><span class="p">,</span> <span class="n">trans_mid</span><span class="p">,</span> <span class="n">quat_mid</span> <span class="c1"># qt.unflip_rotors(quat_mid)#, quat_mid</span></div>

    
<div class="viewcode-block" id="NucleicFrames_quaternion.compute_angle">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_angle">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">quaternion</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">quaternion</span><span class="o">.</span><span class="n">w</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span>    
        <span class="k">return</span> <span class="n">w</span></div>

    
<div class="viewcode-block" id="NucleicFrames_quaternion.compute_angle_">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_angle_">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_angle_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">z</span>

        <span class="c1"># Initialize angle and axis arrays</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Handle cases where w is close to 1 or -1</span>
        <span class="n">close_to_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">close_to_neg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Handle small angles</span>
        <span class="n">small_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">close_to_1</span><span class="p">]))</span>
        <span class="n">angle</span><span class="p">[</span><span class="n">close_to_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">small_angle</span>
        <span class="n">axis</span><span class="p">[</span><span class="n">close_to_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">close_to_1</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>

        <span class="c1"># Handle angles close to 360 degrees</span>
        <span class="n">large_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">close_to_neg1</span><span class="p">]))</span>
        <span class="n">angle</span><span class="p">[</span><span class="n">close_to_neg1</span><span class="p">]</span> <span class="o">=</span> <span class="n">large_angle</span>
        <span class="n">axis</span><span class="p">[</span><span class="n">close_to_neg1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">close_to_neg1</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>

        <span class="c1"># Regular cases</span>
        <span class="n">normal_case</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">close_to_1</span> <span class="o">|</span> <span class="n">close_to_neg1</span><span class="p">)</span>
        <span class="n">angle</span><span class="p">[</span><span class="n">normal_case</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">normal_case</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">normal_case</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">small_s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mf">1e-8</span>
        <span class="n">normal_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">))[</span><span class="n">normal_case</span><span class="p">]</span>

        <span class="c1"># Safe division</span>
        <span class="n">axis</span><span class="p">[</span><span class="n">normal_case</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">normal_case</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span> <span class="o">/</span> <span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">axis</span><span class="p">[</span><span class="n">normal_indices</span><span class="p">[</span><span class="n">small_s</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># Default axis for very small s</span>

        <span class="c1"># Normalize all axes</span>
        <span class="n">axis_norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">valid_norms</span> <span class="o">=</span> <span class="n">axis_norms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># Avoid division by zero</span>
        <span class="n">axis</span><span class="p">[</span><span class="n">valid_norms</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="n">valid_norms</span><span class="p">]</span> <span class="o">/</span> <span class="n">axis_norms</span><span class="p">[</span><span class="n">valid_norms</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">angle</span></div>

    
<div class="viewcode-block" id="NucleicFrames_quaternion.compute_relative_rotation">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_relative_rotation">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_relative_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">quaternions_A</span><span class="p">,</span> <span class="n">quaternions_B</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">quaternions_A</span><span class="p">))</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">quaternions_B</span><span class="p">))</span>
        <span class="n">q1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">q1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">q1</span><span class="o">.</span><span class="n">inverse</span> <span class="o">*</span> <span class="n">q0</span></div>


<div class="viewcode-block" id="NucleicFrames_quaternion.compute_midframe">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_midframe">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_midframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quaterions_A</span><span class="p">,</span> <span class="n">quaterions_B</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">quaterions_A</span><span class="p">))</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">quaterions_B</span><span class="p">))</span>
        <span class="n">q0</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">q0</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">qt</span><span class="o">.</span><span class="n">slerp</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span></div>

    
        <span class="c1"># public void set(Quat4d q1) {</span>
    <span class="c1">#     double test = q1.x*q1.y + q1.z*q1.w;</span>
    <span class="c1">#     if (test &gt; 0.499) { // singularity at north pole</span>
    <span class="c1">#         heading = 2 * atan2(q1.x,q1.w);</span>
    <span class="c1">#         attitude = Math.PI/2;</span>
    <span class="c1">#         bank = 0;</span>
    <span class="c1">#         return;</span>
    <span class="c1">#     }</span>
    <span class="c1">#     if (test &lt; -0.499) { // singularity at south pole</span>
    <span class="c1">#         heading = -2 * atan2(q1.x,q1.w);</span>
    <span class="c1">#         attitude = - Math.PI/2;</span>
    <span class="c1">#         bank = 0;</span>
    <span class="c1">#         return;</span>
    <span class="c1">#     }</span>
    <span class="c1">#     double sqx = q1.x*q1.x;</span>
    <span class="c1">#     double sqy = q1.y*q1.y;</span>
    <span class="c1">#     double sqz = q1.z*q1.z;</span>
    <span class="c1">#     heading = atan2(2*q1.y*q1.w-2*q1.x*q1.z , 1 - 2*sqy - 2*sqz);</span>
    <span class="c1">#     attitude = asin(2*test);</span>
    <span class="c1">#     bank = atan2(2*q1.x*q1.w-2*q1.y*q1.z , 1 - 2*sqx - 2*sqz)</span>

<div class="viewcode-block" id="NucleicFrames_quaternion.compute_euler">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_euler">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_euler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">q</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">w</span>
        <span class="n">north_mask</span> <span class="o">=</span> <span class="n">test</span> <span class="o">&gt;</span> <span class="mf">0.499</span> <span class="c1"># singularity at north pole</span>
        <span class="n">south_mask</span> <span class="o">=</span> <span class="n">test</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.499</span> <span class="c1"># singularity at south pole</span>
        <span class="n">mask_else</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">north_mask</span> <span class="o">|</span> <span class="n">south_mask</span><span class="p">)</span>

        <span class="n">heading</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="n">attitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="n">bank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>

        <span class="n">heading</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span> <span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">attitude</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">test</span><span class="p">[</span><span class="n">mask_else</span><span class="p">])</span>
        <span class="n">bank</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span> <span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">mask_else</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">heading</span><span class="p">[</span><span class="n">north_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">north_mask</span><span class="p">],</span><span class="n">q</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">north_mask</span><span class="p">])</span>
        <span class="n">attitude</span><span class="p">[</span><span class="n">north_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">bank</span><span class="p">[</span><span class="n">north_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">heading</span><span class="p">[</span><span class="n">south_mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">south_mask</span><span class="p">],</span><span class="n">q</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">south_mask</span><span class="p">])</span>
        <span class="n">attitude</span><span class="p">[</span><span class="n">south_mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">bank</span><span class="p">[</span><span class="n">south_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">bank</span><span class="p">,</span><span class="n">heading</span><span class="p">,</span><span class="n">attitude</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>



            <span class="c1">#       # Condition for pitch = pi/2</span>
            <span class="c1"># mask_pi_2 = pitch == np.pi/2</span>
            <span class="c1"># yaw[mask_pi_2] = -np.arctan2(A.x[mask_pi_2],A.w[mask_pi_2])</span>
            <span class="c1"># roll[mask_pi_2] = 0.0</span>

            <span class="c1"># # Condition for pitch = -pi/2</span>
            <span class="c1"># mask_neg_pi_2 = pitch == -np.pi/2</span>
            <span class="c1"># yaw[mask_neg_pi_2] = np.arctan2(A.x[mask_neg_pi_2],A.w[mask_neg_pi_2])</span>
            <span class="c1"># roll[mask_neg_pi_2] = 0.0</span>

            <span class="c1"># # Default condition (where neither pi/2 nor -pi/2 conditions are met)</span>
            <span class="c1"># mask_else = ~(mask_pi_2 | mask_neg_pi_2)</span>
            <span class="c1"># yaw[mask_else] = np.arctan2(2.0*(A.y[mask_else]*A.z[mask_else] + A.w[mask_else]*A.x[mask_else]),</span>
            <span class="c1">#                             A.w[mask_else]**2 - A.x[mask_else]**2 - A.y[mask_else]**2 + A.z[mask_else]**2)</span>
            <span class="c1"># roll[mask_else] = np.arctan2(2.0*(A.x[mask_else]*A.y[mask_else] + A.w[mask_else]*A.z[mask_else]),</span>
            <span class="c1">#                             A.w[mask_else]**2 + A.x[mask_else]**2 - A.y[mask_else]**2 - A.z[mask_else]**2)</span>

            <span class="c1"># rotational_parameters = np.vstack((yaw, pitch, roll)).swapaxes(0,1)</span>

    <span class="k">def</span> <span class="nf">compute_axis_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">quaternion</span><span class="p">):</span>
        <span class="c1"># Get the axis of rotation and the angle of rotation</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">quaternion</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">quaternion</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#+ epsilon</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">quaternion</span><span class="o">.</span><span class="n">vector</span> <span class="o">/</span> <span class="n">norms</span>


        <span class="c1"># Compute dot products between consecutive frames, skipping the first frame.</span>
        <span class="c1"># axis[:-1] is from 0 to n-2, axis[1:] is from 1 to n-1, hence pairs consecutive frames.</span>
        <span class="n">dot_products</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Evaluate the conditions.</span>
        <span class="c1"># Check where the dot product is less than zero and angle of current frame is greater than pi/2.</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot_products</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Update axis where condition is True.</span>
        <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">condition</span><span class="p">]</span>

        <span class="c1"># Update angles where condition is True.</span>
        <span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">condition</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">axis</span> <span class="o">*</span> <span class="n">angle</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


<div class="viewcode-block" id="NucleicFrames_quaternion.compute_axis_angle">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_axis_angle">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_axis_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">quaternion</span><span class="p">):</span>
        <span class="c1"># Get the axis of rotation and the angle of rotation</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">quaternion</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">quaternion</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#+ epsilon</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">quaternion</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">/</span> <span class="n">norms</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">axis</span><span class="p">[</span><span class="n">_</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">axis</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">v</span>
                <span class="n">angle</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">angle</span><span class="p">[</span><span class="n">_</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">axis</span> <span class="o">*</span> <span class="n">angle</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>


<div class="viewcode-block" id="NucleicFrames_quaternion.compute_parameters">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.compute_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">translations_A</span><span class="p">,</span> <span class="n">quaternions_A</span><span class="p">,</span> <span class="n">translations_B</span><span class="p">,</span> <span class="n">quaternions_B</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the rigid body parameters between two frames.&quot;&quot;&quot;</span>
        <span class="c1">#dot = np.dot(quaternions_A, quaternions_B)</span>
        
        <span class="n">dot_products</span> <span class="o">=</span> <span class="p">(</span><span class="n">quaternions_A</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">quaternions_B</span><span class="o">.</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">quaternions_A</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">quaternions_B</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">quaternions_A</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">quaternions_B</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">quaternions_A</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">quaternions_B</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">dot_products</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">quaternions_A</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">quaternions_A</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Get the relative rotation matrix</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">quaternions_B</span><span class="o">.</span><span class="n">inverse</span> <span class="o">*</span> <span class="n">quaternions_A</span>
       
        <span class="c1">#A = quaternions_B.inverse*quaternions_A</span>
        <span class="c1">#A = self.compute_relative_rotation(quaternions_A, quaternions_B, mask)</span>

        <span class="c1"># Slerp (spherical linear interpolation) for quaternion</span>
        <span class="c1"># Note that output slerp(q1, q2, 1) may be different from q2. (slerp(q1, q2, 0) is always equal to q1.)</span>
        <span class="n">quat_mid</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">slerp</span><span class="p">(</span><span class="n">quaternions_A</span><span class="p">,</span> <span class="n">quaternions_B</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
    
        <span class="c1"># Linear interpolation of translations</span>
        <span class="n">trans_mid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">translations_A</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">translations_B</span>
    
        <span class="c1"># Convert quaternion to rotation matrix</span>
        <span class="n">rotation_mid</span> <span class="o">=</span> <span class="n">quat_mid</span><span class="o">.</span><span class="n">to_rotation_matrix</span>  
  
        <span class="c1"># Compute the relative translation</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">translations_A</span> <span class="o">-</span> <span class="n">translations_B</span>

        <span class="c1"># Get translational coordinate vector and convert to angstroms</span>
        <span class="n">translational_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">rotation_mid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">translation</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>

        <span class="c1"># translational_parameters  = quat_mid.rotate(translation)</span>
        <span class="c1"># translational_parameters = translation * quat_mid.inverse</span>
        <span class="c1">#print(translational_parameters.shape,translation.shape, quat_mid.shape)   </span>
        <span class="c1"># # Get the elative rotation matrix</span>
        <span class="c1"># A = quaternions_B.inverse * quaternions_A</span>
        <span class="c1"># self.angles.append(self.compute_angle(A))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler</span><span class="p">:</span>
            <span class="c1"># https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html</span>
            <span class="c1"># We have to be careful because the gimbal lock problem can occur when the pitch angle is close to +/-90 degrees,</span>
            <span class="c1"># or the yaw and roll axes of rotation are aligned with each other in the world coordinate system, and therefore produce the same effect.</span>
            <span class="c1"># See link above for more details on how to mitigate this problem.</span>
            <span class="c1"># Maybe also have another look at: https://amu.hal.science/hal-03848730/document</span>
            <span class="c1"># Title: Quaternion to Euler angles conversion: a direct, general and computationally efficient method from 2022</span>
            <span class="c1"># pitch = np.arcsin(2.0*(A.w*A.y - A.x*A.z))</span>
 
            <span class="c1"># # yaw = np.arctan2(2.0*(A.y*A.z + A.w*A.x), A.w*A.w - A.x*A.x - A.y*A.y + A.z*A.z)</span>
            <span class="c1"># # roll = np.arctan2(2.0*(A.x*A.y + A.w*A.z), A.w*A.w + A.x*A.x - A.y*A.y - A.z*A.z)</span>
            <span class="c1"># # </span>
            <span class="c1"># # # Initialize yaw and roll with default values that will apply when no specific condition is met</span>
            <span class="c1"># yaw = np.zeros_like(pitch)</span>
            <span class="c1"># roll = np.zeros_like(pitch)</span>

            <span class="c1"># # Condition for pitch = pi/2</span>
            <span class="c1"># mask_pi_2 = pitch == np.pi/2</span>
            <span class="c1"># yaw[mask_pi_2] = -np.arctan2(A.x[mask_pi_2],A.w[mask_pi_2])</span>
            <span class="c1"># roll[mask_pi_2] = 0.0</span>

            <span class="c1"># # Condition for pitch = -pi/2</span>
            <span class="c1"># mask_neg_pi_2 = pitch == -np.pi/2</span>
            <span class="c1"># yaw[mask_neg_pi_2] = np.arctan2(A.x[mask_neg_pi_2],A.w[mask_neg_pi_2])</span>
            <span class="c1"># roll[mask_neg_pi_2] = 0.0</span>

            <span class="c1"># # Default condition (where neither pi/2 nor -pi/2 conditions are met)</span>
            <span class="c1"># mask_else = ~(mask_pi_2 | mask_neg_pi_2)</span>
            <span class="c1"># yaw[mask_else] = np.arctan2(2.0*(A.y[mask_else]*A.z[mask_else] + A.w[mask_else]*A.x[mask_else]),</span>
            <span class="c1">#                             A.w[mask_else]**2 - A.x[mask_else]**2 - A.y[mask_else]**2 + A.z[mask_else]**2)</span>
            <span class="c1"># roll[mask_else] = np.arctan2(2.0*(A.x[mask_else]*A.y[mask_else] + A.w[mask_else]*A.z[mask_else]),</span>
            <span class="c1">#                             A.w[mask_else]**2 + A.x[mask_else]**2 - A.y[mask_else]**2 - A.z[mask_else]**2)</span>

            <span class="c1"># rotational_parameters = np.vstack((yaw, pitch, roll)).swapaxes(0,1)</span>
            <span class="n">rotational_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_euler</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>   
            <span class="c1"># heading = np.arctan2(2*A.y*A.w-2*A.x*A.z , 1 - 2*A.y**2 - 2*A.z**2)</span>
            <span class="c1"># attitude = np.arcsin(2*A.x*A.y + 2*A.z*A.w)</span>
            <span class="c1"># bank = np.arctan2(2*A.x*A.w-2*A.y*A.z , 1 - 2*A.x**2 - 2*A.z**2)</span>
            <span class="c1"># rotational_parameters = np.vstack((bank,heading,attitude )).swapaxes(0,1)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cayley</span><span class="p">:</span>
            <span class="c1"># rot_A = quaternions_A.to_rotation_matrix # shape n_frames, 3, 3</span>
            <span class="c1"># rot_B = quaternions_B.to_rotation_matrix # shape n_frames, 3, 3</span>
            
            <span class="c1"># # Compute the relative rotation matrix for each frame</span>
            <span class="c1"># # Note: .T must be applied to each matrix in rot_B; assuming it&#39;s handled within the loop or vectorization</span>
            <span class="c1"># A = np.einsum(&#39;nij,njk-&gt;nik&#39;, rot_B.transpose((0, 2, 1)), rot_A)  # shape n_frames, 3, 3</span>
            <span class="c1"># Calculate the trace of each matrix A across the frames</span>
            <span class="n">trace_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nii-&gt;n&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">to_rotation_matrix</span><span class="p">)</span>  <span class="c1"># Sum over diagonal elements for each frame</span>

            <span class="c1"># Compute the Cayley-Klein parameters for all frames at once</span>
            <span class="n">rotational_parameters</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">A</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">A</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">trace_A</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Adding 1 to each element of trace_A and reshaping for broadcasting</span>


        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">:</span>
            <span class="c1"># Get axis angle representation of the relative rotation matrix</span>
            <span class="c1"># Each vector represents the axis of the rotation, with norm equal to the angle of the rotation in radians.</span>
            <span class="c1">#rotational_parameters = A.to_axis_angle # unfortunately this results in angle wraps.</span>
            <span class="n">rotational_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_axis_angle</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="c1"># Stack the translational and rotational parameters and convert the latter to degrees</span>
        <span class="n">rigid_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">translational_parameters</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">rotational_parameters</span><span class="p">)))</span>

        <span class="c1"># Return the rigid body parameters and the mid/halfway transformation</span>
        <span class="k">return</span> <span class="n">rigid_parameters</span><span class="p">,</span> <span class="n">trans_mid</span><span class="p">,</span> <span class="n">quat_mid</span><span class="c1">#, qt.unflip_rotors(quat_mid)#, quat_mid</span></div>


<div class="viewcode-block" id="NucleicFrames_quaternion.analyze">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.analyze">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyze the trajectory and compute the pair and step parameters.&quot;&quot;&quot;</span>

        <span class="c1"># Initialize arrays for the pair and step parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

        <span class="c1"># Initialize arrays for the translation and quaternion representations of the step frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quat</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
    
        <span class="c1"># Process the leading chain</span>
        <span class="n">translations_A</span><span class="p">,</span> <span class="n">quaternions_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_A</span><span class="p">)</span>
        <span class="c1"># Process the lagging chain</span>
        <span class="n">translations_B</span><span class="p">,</span> <span class="n">quaternions_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_B</span><span class="p">,</span> <span class="n">anti</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quats_A</span> <span class="o">=</span> <span class="n">quaternions_A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quats_B</span> <span class="o">=</span> <span class="n">quaternions_B</span>
        <span class="c1"># Compute the pair parameters and get the halfway transformation</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">translations_A</span><span class="p">,</span> <span class="n">quaternions_A</span><span class="p">,</span> <span class="n">translations_B</span><span class="p">,</span> <span class="n">quaternions_B</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pair_parameters</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">quat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_parameters</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="c1"># compute step paramters</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step_parameters</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">quat</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">quat</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>



<div class="viewcode-block" id="NucleicFrames_quaternion.get_parameters">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.get_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">pair</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the computed parameters of shape (n_base_pairs, n_frames, n_parameters)&quot;&quot;&quot;</span>
        <span class="n">step_parameter_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="s1">&#39;slide&#39;</span><span class="p">,</span> <span class="s1">&#39;rise&#39;</span><span class="p">,</span> <span class="s1">&#39;tilt&#39;</span><span class="p">,</span> <span class="s1">&#39;roll&#39;</span><span class="p">,</span> <span class="s1">&#39;twist&#39;</span><span class="p">]</span>
        <span class="n">base_parameter_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shear&#39;</span><span class="p">,</span> <span class="s1">&#39;stretch&#39;</span><span class="p">,</span> <span class="s1">&#39;stagger&#39;</span><span class="p">,</span> <span class="s1">&#39;buckle&#39;</span><span class="p">,</span> <span class="s1">&#39;propeller&#39;</span><span class="p">,</span> <span class="s1">&#39;opening&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">step</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pair</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_parameters</span><span class="p">,</span> <span class="n">step_parameter_names</span>
        <span class="k">elif</span> <span class="n">pair</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">step</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_parameters</span><span class="p">,</span> <span class="n">base_parameter_names</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">step</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pair</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_parameters</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">base_parameter_names</span> <span class="o">+</span> <span class="n">step_parameter_names</span></div>

        








<div class="viewcode-block" id="NucleicFrames_quaternion.analyze_vec">
<a class="viewcode-back" href="../../pymdna.html#pymdna.geometry.NucleicFrames_quaternion.analyze_vec">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the base frames and convert them to translation and quaternion representations.&quot;&quot;&quot;</span>

        <span class="c1"># Process the leading chain</span>
        <span class="n">translations_A</span><span class="p">,</span> <span class="n">quaternions_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_A</span><span class="p">)</span>
        <span class="n">translations_A</span> <span class="o">=</span> <span class="n">translations_A</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">quaternions_A</span> <span class="o">=</span> <span class="n">quaternions_A</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Process the lagging chain</span>
        <span class="n">translations_B</span><span class="p">,</span> <span class="n">quaternions_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_B</span><span class="p">,</span> <span class="n">anti</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">translations_B</span> <span class="o">=</span> <span class="n">translations_B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">quaternions_B</span> <span class="o">=</span> <span class="n">quaternions_B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Flip the B chain quaternion (connecting the backbones) and the (baseplane normals) (2,3)  vector b_L, b_N</span>
        <span class="c1">#quaternions_B = quaternions_B * qt.array([0, 1, 0, 0])</span>
        
        <span class="c1"># Compute the rigid body parameters and the mid/halfway transformation</span>
        <span class="n">pair_parameters</span><span class="p">,</span> <span class="n">trans_step</span><span class="p">,</span> <span class="n">quat_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_parameters</span><span class="p">(</span><span class="n">translations_A</span><span class="p">,</span> <span class="n">quaternions_A</span><span class="p">,</span> <span class="n">translations_B</span><span class="p">,</span> <span class="n">quaternions_B</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_parameters</span> <span class="o">=</span> <span class="n">pair_parameters</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># reshape output and input for the step parameters computation</span>
        <span class="n">trans_step</span> <span class="o">=</span> <span class="n">trans_step</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">quat_step</span> <span class="o">=</span> <span class="n">quat_step</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="c1">#.swapaxes(0,1)</span>
        <span class="c1">#quat_step = qt.unflip_rotors(quat_step,axis=1)</span>
        
        <span class="c1"># if quat_step.shape[1] &gt; 1:</span>
        <span class="c1">#     for q in quat_step:</span>
        <span class="c1">#         qt.unflip_rotors(q, inplace=True)</span>
        <span class="c1">#     # quat_step = qt.unflip_rotors(quat_step)</span>
        
        <span class="n">t_step_a</span> <span class="o">=</span> <span class="n">trans_step</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">,]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">t_step_b</span> <span class="o">=</span> <span class="n">trans_step</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:,]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">q_step_a</span> <span class="o">=</span> <span class="n">quat_step</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">,]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">q_step_b</span> <span class="o">=</span> <span class="n">quat_step</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:,]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Compute the step parameters and store them in the step_parameters attribute</span>
        <span class="n">step_parameters</span><span class="p">,</span>  <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_parameters</span><span class="p">(</span><span class="n">t_step_b</span><span class="p">,</span> <span class="n">q_step_b</span><span class="p">,</span> <span class="n">t_step_a</span><span class="p">,</span> <span class="n">q_step_a</span><span class="p">)</span>
        <span class="n">extra_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">step_parameters</span> <span class="o">=</span> <span class="n">step_parameters</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">extra_column</span><span class="p">,</span><span class="n">step_parameters</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>
</div>



    <span class="c1"># def compute_step_parameters(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Process the step transformations and convert them to translation and quaternion representations.&quot;&quot;&quot;</span>

    <span class="c1">#     # trans_step_0 = self.trans_step[:-1]</span>
    <span class="c1">#     # quat_step_0 = self.quat_step[:-1]</span>

    <span class="c1">#     # trans_step_1 = self.trans_step[1:]</span>
    <span class="c1">#     # quat_step_1 = self.quat_step[1:]</span>

    <span class="c1">#     step_parameters,  _, _ = self.compute_parameters(self.trans_step[1:], self.quat_step[1:], self.trans_step[:-1], self.quat_step[:-1])</span>
    <span class="c1">#     step_parameters = step_parameters.reshape(self.traj.n_frames, self.n_bp-1, 6)</span>
    <span class="c1">#     # add empty column of zeros to the step parameters</span>
    <span class="c1">#     extra_column = np.zeros((step_parameters.shape[0], 1, 6))</span>
    <span class="c1">#     self.step_parameters = np.concatenate((extra_column,step_parameters), axis=1)</span>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">mdna</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">pymdna</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../pymdna.html">pymdna</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Thor van Heesch.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>