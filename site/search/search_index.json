{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Software module for DNA structure generation and analysis","text":"<p>A Python toolkit for generation and analysis of double-stranded DNA structures.</p>"},{"location":"#what-is-mdna","title":"What is MDNA?","text":"<p>MDNA enables the construction of arbitrarily shaped DNA using spline-based mapping, supports canonical and non-canonical nucleotides, and integrates Monte Carlo relaxation to obtain physically consistent configurations. In addition, it implements rigid base parameter analysis and linking number calculations, and exports directly to MDTraj and OpenMM compatible trajectories for molecular dynamics workflows.</p>"},{"location":"#example-gallery","title":"Example Gallery","text":"<p>Three examples that highlight the building of biomolecular assemblies with MDNA: extension of DNA structures, using proteins as scaffold to generate DNA structure, and connecting two DNA strands to form a DNA loop. Molecular representations are visualized with Mol* Viewer.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import mdna\n\n# Generate a 100-bp DNA minicircle\ndna = mdna.make(n_bp=100, circular=True)\n\n# Relax the structure\ndna.minimize()\n\n# Compute rigid base parameters\nparams, names = dna.get_parameters()\n\n# Export to PDB\ndna.save_pdb('minicircle.pdb')\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Arbitrary DNA shapes via spline control points</li> <li>Sequence-driven construction with canonical and non-canonical bases (hachimoji, fluorescent, hydrophobic UBPs)</li> <li>Hoogsteen base flipping and methylation editing</li> <li>Circular DNA generation with linking number control (\\(\\Delta Lk\\))</li> <li>Monte Carlo relaxation for physically consistent configurations</li> <li>Rigid base parameter analysis: shear, stretch, stagger, buckle, propeller, opening, shift, slide, rise, tilt, roll, twist</li> <li>MDTraj interoperability for seamless MD workflows</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"Section Description Getting Started Install MDNA and generate your first DNA in 5 minutes User Guide Task-oriented guides: Build \u00b7 Modify \u00b7 Analyse Concepts Architecture, splines, rigid base formalism Jupyter Notebooks Interactive tutorials from basic to advanced API Reference Complete reference for all classes and functions"},{"location":"#citation","title":"Citation","text":"<p>Link to the publication</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This project is supported by the NWO Klein grant.</p>"},{"location":"index-notebooks/","title":"Juypter Notebooks","text":"<p>Basic Notebooks:</p> <ul> <li>Structure Generation</li> <li>Draw DNA Structures</li> <li>Modify DNA Structures</li> <li>Analyse DNA Structures</li> </ul> <p>Advanced Notebooks:</p> <ul> <li>DNA Along H-NS Filament</li> <li>Add Linker DNA to Nucleosome</li> <li>Add DNA Loop to bridging protein</li> <li>How to add base to Sequence Library</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for all public classes and functions in the <code>mdna</code> package.</p>"},{"location":"api/#top-level-functions","title":"Top-Level Functions","text":"<p>These are available directly via <code>import mdna</code>:</p> Function Description <code>make()</code> Generate DNA from sequence and/or shape <code>load()</code> Load DNA from trajectory, frames, or sequence <code>connect()</code> Join two DNA structures <code>compute_rigid_parameters()</code> Compute rigid base parameters from a trajectory <code>sequence_to_pdb()</code> Generate PDB file directly from sequence <code>sequence_to_md()</code> Generate and simulate DNA with OpenMM"},{"location":"api/#core-classes","title":"Core Classes","text":"Class Description <code>Nucleic</code> Central DNA structure object (sequence + frames + trajectory) <code>Shapes</code> Factory for predefined DNA shape control points"},{"location":"api/#geometry-analysis","title":"Geometry &amp; Analysis","text":"Class Description <code>NucleicFrames</code> Rigid base parameter computation from trajectories <code>ReferenceBase</code> Single nucleobase reference frame fitting <code>GrooveAnalysis</code> DNA groove width computation <code>TorsionAnalysis</code> Backbone torsion angle computation"},{"location":"api/#build-internals","title":"Build Internals","text":"Class Description <code>SplineFrames</code> Spline interpolation and frame generation <code>SequenceGenerator</code> DNA topology construction from sequence <code>StructureGenerator</code> Atomic coordinate placement into frames"},{"location":"api/#relaxation","title":"Relaxation","text":"Class Description <code>Minimizer</code> Monte Carlo energy minimization"},{"location":"api/analysis/","title":"Analysis Classes","text":"<p>Classes for groove width and torsion angle analysis.</p>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis","title":"<code>mdna.analysis.GrooveAnalysis</code>","text":"<p>Compute minor and major groove widths from a DNA trajectory.</p> <p>Extracts phosphorus-atom positions from the two DNA strands, fits cubic splines through them, and measures inter-strand distances to derive groove widths for every frame.</p> <p>Attributes:</p> Name Type Description <code>minor_widths</code> <code>ndarray</code> <p>Minor-groove widths, shape <code>(n_frames, n_points)</code>.</p> <code>major_widths</code> <code>ndarray</code> <p>Major-groove widths, shape <code>(n_frames, n_points)</code>.</p> <code>sequence</code> <code>list[str]</code> <p>Sense-strand sequence letters.</p> <code>base_pairs</code> <code>list[str]</code> <p>Base-pair labels (e.g. <code>['G-C', 'A-T', ...]</code>).</p> Example <pre><code>import mdtraj as md\ntraj = md.load('trajectory.xtc', top='topology.pdb')\ngrooves = GrooveAnalysis(traj)\nfig, ax = plt.subplots()\ngrooves.plot_groove_widths(ax=ax)\n</code></pre> Source code in <code>mdna/analysis.py</code> <pre><code>class GrooveAnalysis:\n    \"\"\"Compute minor and major groove widths from a DNA trajectory.\n\n    Extracts phosphorus-atom positions from the two DNA strands, fits cubic\n    splines through them, and measures inter-strand distances to derive\n    groove widths for every frame.\n\n    Attributes:\n        minor_widths (numpy.ndarray): Minor-groove widths, shape ``(n_frames, n_points)``.\n        major_widths (numpy.ndarray): Major-groove widths, shape ``(n_frames, n_points)``.\n        sequence (list[str]): Sense-strand sequence letters.\n        base_pairs (list[str]): Base-pair labels (e.g. ``['G-C', 'A-T', ...]``).\n\n    Example:\n        ```python\n        import mdtraj as md\n        traj = md.load('trajectory.xtc', top='topology.pdb')\n        grooves = GrooveAnalysis(traj)\n        fig, ax = plt.subplots()\n        grooves.plot_groove_widths(ax=ax)\n        ```\n    \"\"\"\n\n    def __init__(self, raw_traj, points=None, parallel=joblib_available):\n        \"\"\"Initialize groove analysis.\n\n        Args:\n            raw_traj (md.Trajectory): Trajectory containing at least two DNA chains.\n            points (int, optional): Number of spline interpolation points.\n                Defaults to ``(n_bp - 1) * 4``.\n            parallel (bool): Use joblib for parallel computation when available.\n        \"\"\"\n\n        self.use_parallel = parallel\n        self.points = points\n        self.sequence = get_sequence_letters(raw_traj)\n        self.base_pairs = get_base_pair_letters(raw_traj)\n        self.get_phosphors_only_traj(raw_traj) \n\n        self.nbp = len(self.DNA_traj.top._residues)//2\n\n        # Fit cubic spline curves based on phosphor atoms in strands\n        if self.points:\n            pass\n        else:\n            self.points = (self.nbp-1)*4\n\n        self.fit_cubic_spline()\n        self.compute_groove_widths()\n\n    def describe(self):\n        \"\"\"Print a summary of the DNA trajectory (base-pair count and frames).\"\"\"\n        print(f'Your DNA has {self.nbp} base pairs and contains {self.DNA_traj.n_frames} frames.')\n\n    def get_phosphors_only_traj(self, raw_traj):\n        \"\"\"Extract phosphorus-only sub-trajectories for each strand.\n\n        Populates :attr:`DNA_traj`, :attr:`phos_traj`, :attr:`strand_A`,\n        and :attr:`strand_B`.\n\n        Args:\n            raw_traj (md.Trajectory): Full trajectory.\n        \"\"\"\n\n        # Assuming first two chains are the DNA strands\n        DNA_indices = [i.index for c in raw_traj.top._chains[:2] for i in c.atoms]\n        self.DNA_traj = raw_traj.atom_slice(DNA_indices)\n\n         # Select only phosphor atoms\n        phos_indices = self.DNA_traj.top.select('name P')\n        self.phos_traj = self.DNA_traj.atom_slice(phos_indices).center_coordinates()\n\n        # Make new topology of chains\n        phos_chain_A = self.phos_traj.topology._chains[0]\n        phos_chain_B = self.phos_traj.topology._chains[1]\n\n        # Split phos traj in two seperate traj for each strand\n        self.strand_A = self.phos_traj.atom_slice([i.index for i in phos_chain_A.atoms])\n        self.strand_B = self.phos_traj.atom_slice([i.index for i in phos_chain_B.atoms])\n\n    def fit_cubic_spline(self):\n        \"\"\"Fit cubic splines through phosphorus positions and compute inter-strand distances.\n\n        Populates :attr:`pairs`, :attr:`distances`, and :attr:`distance_matrices`.\n        \"\"\"\n\n        # fit cubic spline curve\n        curves_A = self.fit_curves(self.strand_A, self.points)\n        curves_B = self.fit_curves(self.strand_B, self.points)\n\n        # reshape back to trajectory xyz format\n        a_curve_xyz = curves_A.T.swapaxes(1,2)\n        b_curve_xyz = curves_B.T.swapaxes(1,2)\n\n        # convert curves to xyz format\n        curves = np.hstack((a_curve_xyz,b_curve_xyz))\n\n        # Retrieve \"predicted points/particles\"\n        n_points = curves.shape[1]\n        points_strand_A = range(0,(int((n_points/2))))\n        points_strand_B = range((int((n_points/2))),(int((n_points))))\n\n        # Generate pairs between the two strands\n        #self.pairs = list(itertools.product(points_strand_A, points_strand_B))\n        self.pairs = [(point_A, point_B) for point_A in points_strand_A for point_B in points_strand_B]\n\n        # Calculate pair distances\n        self.distances = _compute_distance(curves, self.pairs)\n\n        # Reshape pair distances to n x n matrix and account for vdWaals radii of P atoms\n        s = self.distances.shape\n        self.distance_matrices = self.distances.reshape(s[0],len(points_strand_A),len(points_strand_B))[::-1,:,::-1] - 0.58\n\n\n    def fit_curves(self, traj, points):\n        \"\"\"Interpolate atom positions with a cubic spline.\n\n        Args:\n            traj (md.Trajectory): Single-strand phosphorus trajectory.\n            points (int): Number of interpolation points.\n\n        Returns:\n            coordinates (numpy.ndarray): Interpolated coordinates.\n        \"\"\"\n\n        # make curve with shape[n_particles, xyz, time]\n        xyz = traj.xyz.T.swapaxes(0,1)\n        n_particles = len(xyz)\n        particle_list = list(range(0,n_particles))\n\n        # initialize predictor based on # of actual particles\n        predictor = CubicSpline(particle_list,xyz)\n\n        # points of curve to interpolate the particles \n        return predictor(np.linspace(0,len(xyz),points))\n\n    @staticmethod\n    def find_first_local_minimum(arr):\n        \"\"\"Return the first local minimum in *arr*, or ``NaN`` if none exists.\n\n        Args:\n            arr (numpy.ndarray): 1-D array of values.\n\n        Returns:\n            minimum (float): First local minimum value.\n        \"\"\"\n        for i in range(1, len(arr) - 1):\n            if arr[i] &lt; arr[i - 1] and arr[i] &lt; arr[i + 1]:\n                return arr[i]  # Return the first local minimum found\n        return np.NaN  # Return None if no local minimum is found\n\n    @staticmethod\n    def split_array(array):\n        \"\"\"Split an anti-diagonal slice into minor and major halves.\n\n        Args:\n            array (numpy.ndarray): Anti-diagonal slice.\n\n        Returns:\n            halves (tuple[numpy.ndarray, numpy.ndarray]): ``(minor_half, major_half)``.\n        \"\"\"\n        # Compute the midpoint of the array\n        midpoint = len(array) // 2\n\n        # If the length of the array is odd, exclude the middle element. \n        # If it's even, split the array into two equal halves.\n        # Return the two halves that correspond to lower and upper triangles of the distance matrix\n        # Reverse the first array because the order of the anti diagonal's in the opposite direction of backone/trailing diagonal\n        return array[:midpoint][::-1], array[midpoint + len(array) % 2:]\n\n    @staticmethod\n    def get_anti_diagonal_slices(matrix):\n        \"\"\"Extract all anti-diagonal slices from a square matrix.\n\n        Args:\n            matrix (numpy.ndarray): Square distance matrix.\n\n        Returns:\n            slices (list[numpy.ndarray]): Anti-diagonal slices.\n        \"\"\"\n        n = matrix.shape[0] # Get the size of the matrix and skip the first and last anti diagonal\n        return [np.diagonal(np.flipud(matrix), offset) for offset in range(-(n - 2), n - 2)]\n\n\n    def get_minor_major_widths(self, distance_matrix):\n        \"\"\"Compute minor and major groove widths from one distance matrix.\n\n        Args:\n            distance_matrix (numpy.ndarray): Inter-strand distance matrix for a single frame.\n\n        Returns:\n            widths (tuple[list[float], list[float]]): ``(minor_widths, major_widths)``.\n        \"\"\"\n\n        # Split the distance matrix into anti diagonal slices\n        diagonal_slices = self.get_anti_diagonal_slices(distance_matrix)\n\n        minor_widths, major_widths = [],[]\n        for slice_ in diagonal_slices:\n            minor, major = self.split_array(slice_)\n            major_widths.append(self.find_first_local_minimum(major))  # Find local minimum in the major slice and add it to the list\n            minor_widths.append(self.find_first_local_minimum(minor))  # Find local minimum in the minor slice and add it to the list \n\n        return minor_widths, major_widths\n\n    def compute_groove_widths(self):\n        \"\"\"Compute groove widths for all frames (parallel or sequential).\n\n        Populates :attr:`minor_widths` and :attr:`major_widths`.\n        \"\"\"\n        if self.use_parallel:\n            # Parallelize the computation and subtract 0.58 to account for the vdw radius of the phosphorus atoms\n            results = Parallel(n_jobs=-1)(delayed(self.get_minor_major_widths)(distance_matrix) for distance_matrix in self.distance_matrices)\n        else:\n            # Compute sequentially\n            results = [self.get_minor_major_widths(distance_matrix) for distance_matrix in self.distance_matrices]\n\n        minor_widths_batch, major_widths_batch = zip(*results)\n        self.minor_widths = np.array(minor_widths_batch)\n        self.major_widths = np.array(major_widths_batch)\n\n\n    def plot_width(self, ax, groove, color=None, std=True, ls='-', lw=0.5):\n        \"\"\"Plot mean groove width with optional standard-deviation shading.\n\n        Args:\n            ax (matplotlib.axes.Axes): Target axes.\n            groove (numpy.ndarray): Groove-width array, shape ``(n_frames, n_points)``.\n            color (str, optional): Line colour.\n            std (bool): If True, shade the \u00b11\u03c3 region.\n            ls (str): Line style.\n            lw (float): Line width.\n        \"\"\"\n        # Suppress warnings for mean of empty slice\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=RuntimeWarning)    \n            # Calculate the mean and standard deviation of major widths\n            mean = np.nanmean(groove, axis=0)\n            stds = np.nanstd(groove, axis=0)\n\n        ax.plot(mean,color=color,ls=ls,lw=lw)\n        if std:\n            # Fill the area around the mean for widths\n            ax.fill_between(range(len(mean)), mean - stds, mean + stds, alpha=0.25,color=color,ls='-',lw=lw)\n\n    def plot_groove_widths(self, minor=True, major=True, std=True, color='k', c_minor=None, lw=0.5, c_major=None, ax=None, base_labels=True, ls='-'):\n        \"\"\"Plot minor and/or major groove widths.\n\n        Args:\n            minor (bool): Plot minor groove widths.\n            major (bool): Plot major groove widths.\n            std (bool): Show standard-deviation shading.\n            color (str): Fallback colour when *c_minor*/*c_major* are not set.\n            c_minor (str, optional): Minor-groove colour.\n            c_major (str, optional): Major-groove colour.\n            lw (float): Line width.\n            ax (matplotlib.axes.Axes, optional): Target axes.  A new figure\n                is created if ``None``.\n            base_labels (bool): Label the x-axis with base-pair identifiers.\n            ls (str): Line style.\n\n        Returns:\n            result (tuple | None): ``(fig, ax)`` when *ax* was ``None``.\n        \"\"\"\n\n        # Create a figure and axes for plotting\n        if ax is None:\n            no_ax = True\n            _, ax = plt.subplots()\n        else:\n            no_ax = False\n\n        # If c_minor or c_major are not provided, use the general color\n        if c_minor is None:\n            c_minor = color\n        if c_major is None:\n            c_major = color\n        if (minor and major) and (c_minor == c_major):\n            c_minor = 'cornflowerblue'\n            c_major = 'coral'\n\n        if minor:\n            self.plot_width(ax, self.minor_widths, std=std, color=c_minor,ls=ls,lw=lw)\n        if major:\n            self.plot_width(ax, self.major_widths, std=std, color=c_major,ls=ls,lw=lw)\n\n        if base_labels:\n            ax.set_xticks(np.linspace(0,len(self.major_widths[0]),len(self.base_pairs)).astype(float))\n            ax.set_xticklabels(self.base_pairs,rotation=90)\n\n        if no_ax:\n            return _, ax\n\n    def calculate_groove_depths(self):\n        # Having defined a groove width by a minimal distance at some point along the nucleic acid fragment,\n        # we have to calculate the corresponding groove depth. \n\n        # At a base pair level, this is defined as the distance from the centre of \n        # the backbone-to-backbone width vector to the mid-point of a vector defining the corresponding base pair. \n        # This vector is constructed using the C8 atom of purines and the C6 atom of pyrimidines \n\n        # For groove depths half-way between base pair levels,\n        # we use the average of the corresponding base pair vector mid-points. \n        pass\n\n    def calculate_groove_depths(self):\n\n        # Calculate the C8 and C6 atom positions of purines and pyrimidines\n        c8_indices = self.DNA_traj.top.select('name C8')\n        c6_indices = self.DNA_traj.top.select('name C6')\n        c8_positions = self.DNA_traj.xyz[:, c8_indices]\n        c6_positions = self.DNA_traj.xyz[:, c6_indices]\n\n        # Calculate mid-points of vectors defining base pairs\n        base_pair_mid_points = 0.5 * (c8_positions + c6_positions)\n\n        # Calculate backbone-to-backbone width vector centres\n        backbone_width_vector_centres = 0.5 * (self.strand_A.xyz + self.strand_B.xyz)\n\n        # Calculate groove depths at base pair level\n        groove_depths_base_pair_level = np.linalg.norm(base_pair_mid_points - backbone_width_vector_centres, axis=-1)\n\n        # For groove depths half-way between base pair levels, we use the average of the corresponding base pair vector mid-points\n        groove_depths_half_way = 0.5 * (groove_depths_base_pair_level[:-1] + groove_depths_base_pair_level[1:])\n\n        return groove_depths_base_pair_level, groove_depths_half_way\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.__init__","title":"<code>__init__(raw_traj, points=None, parallel=joblib_available)</code>","text":"<p>Initialize groove analysis.</p> <p>Parameters:</p> Name Type Description Default <code>raw_traj</code> <code>Trajectory</code> <p>Trajectory containing at least two DNA chains.</p> required <code>points</code> <code>int</code> <p>Number of spline interpolation points. Defaults to <code>(n_bp - 1) * 4</code>.</p> <code>None</code> <code>parallel</code> <code>bool</code> <p>Use joblib for parallel computation when available.</p> <code>joblib_available</code> Source code in <code>mdna/analysis.py</code> <pre><code>def __init__(self, raw_traj, points=None, parallel=joblib_available):\n    \"\"\"Initialize groove analysis.\n\n    Args:\n        raw_traj (md.Trajectory): Trajectory containing at least two DNA chains.\n        points (int, optional): Number of spline interpolation points.\n            Defaults to ``(n_bp - 1) * 4``.\n        parallel (bool): Use joblib for parallel computation when available.\n    \"\"\"\n\n    self.use_parallel = parallel\n    self.points = points\n    self.sequence = get_sequence_letters(raw_traj)\n    self.base_pairs = get_base_pair_letters(raw_traj)\n    self.get_phosphors_only_traj(raw_traj) \n\n    self.nbp = len(self.DNA_traj.top._residues)//2\n\n    # Fit cubic spline curves based on phosphor atoms in strands\n    if self.points:\n        pass\n    else:\n        self.points = (self.nbp-1)*4\n\n    self.fit_cubic_spline()\n    self.compute_groove_widths()\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.compute_groove_widths","title":"<code>compute_groove_widths()</code>","text":"<p>Compute groove widths for all frames (parallel or sequential).</p> <p>Populates :attr:<code>minor_widths</code> and :attr:<code>major_widths</code>.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def compute_groove_widths(self):\n    \"\"\"Compute groove widths for all frames (parallel or sequential).\n\n    Populates :attr:`minor_widths` and :attr:`major_widths`.\n    \"\"\"\n    if self.use_parallel:\n        # Parallelize the computation and subtract 0.58 to account for the vdw radius of the phosphorus atoms\n        results = Parallel(n_jobs=-1)(delayed(self.get_minor_major_widths)(distance_matrix) for distance_matrix in self.distance_matrices)\n    else:\n        # Compute sequentially\n        results = [self.get_minor_major_widths(distance_matrix) for distance_matrix in self.distance_matrices]\n\n    minor_widths_batch, major_widths_batch = zip(*results)\n    self.minor_widths = np.array(minor_widths_batch)\n    self.major_widths = np.array(major_widths_batch)\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.describe","title":"<code>describe()</code>","text":"<p>Print a summary of the DNA trajectory (base-pair count and frames).</p> Source code in <code>mdna/analysis.py</code> <pre><code>def describe(self):\n    \"\"\"Print a summary of the DNA trajectory (base-pair count and frames).\"\"\"\n    print(f'Your DNA has {self.nbp} base pairs and contains {self.DNA_traj.n_frames} frames.')\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.find_first_local_minimum","title":"<code>find_first_local_minimum(arr)</code>  <code>staticmethod</code>","text":"<p>Return the first local minimum in arr, or <code>NaN</code> if none exists.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>1-D array of values.</p> required <p>Returns:</p> Name Type Description <code>minimum</code> <code>float</code> <p>First local minimum value.</p> Source code in <code>mdna/analysis.py</code> <pre><code>@staticmethod\ndef find_first_local_minimum(arr):\n    \"\"\"Return the first local minimum in *arr*, or ``NaN`` if none exists.\n\n    Args:\n        arr (numpy.ndarray): 1-D array of values.\n\n    Returns:\n        minimum (float): First local minimum value.\n    \"\"\"\n    for i in range(1, len(arr) - 1):\n        if arr[i] &lt; arr[i - 1] and arr[i] &lt; arr[i + 1]:\n            return arr[i]  # Return the first local minimum found\n    return np.NaN  # Return None if no local minimum is found\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.fit_cubic_spline","title":"<code>fit_cubic_spline()</code>","text":"<p>Fit cubic splines through phosphorus positions and compute inter-strand distances.</p> <p>Populates :attr:<code>pairs</code>, :attr:<code>distances</code>, and :attr:<code>distance_matrices</code>.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def fit_cubic_spline(self):\n    \"\"\"Fit cubic splines through phosphorus positions and compute inter-strand distances.\n\n    Populates :attr:`pairs`, :attr:`distances`, and :attr:`distance_matrices`.\n    \"\"\"\n\n    # fit cubic spline curve\n    curves_A = self.fit_curves(self.strand_A, self.points)\n    curves_B = self.fit_curves(self.strand_B, self.points)\n\n    # reshape back to trajectory xyz format\n    a_curve_xyz = curves_A.T.swapaxes(1,2)\n    b_curve_xyz = curves_B.T.swapaxes(1,2)\n\n    # convert curves to xyz format\n    curves = np.hstack((a_curve_xyz,b_curve_xyz))\n\n    # Retrieve \"predicted points/particles\"\n    n_points = curves.shape[1]\n    points_strand_A = range(0,(int((n_points/2))))\n    points_strand_B = range((int((n_points/2))),(int((n_points))))\n\n    # Generate pairs between the two strands\n    #self.pairs = list(itertools.product(points_strand_A, points_strand_B))\n    self.pairs = [(point_A, point_B) for point_A in points_strand_A for point_B in points_strand_B]\n\n    # Calculate pair distances\n    self.distances = _compute_distance(curves, self.pairs)\n\n    # Reshape pair distances to n x n matrix and account for vdWaals radii of P atoms\n    s = self.distances.shape\n    self.distance_matrices = self.distances.reshape(s[0],len(points_strand_A),len(points_strand_B))[::-1,:,::-1] - 0.58\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.fit_curves","title":"<code>fit_curves(traj, points)</code>","text":"<p>Interpolate atom positions with a cubic spline.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Trajectory</code> <p>Single-strand phosphorus trajectory.</p> required <code>points</code> <code>int</code> <p>Number of interpolation points.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>ndarray</code> <p>Interpolated coordinates.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def fit_curves(self, traj, points):\n    \"\"\"Interpolate atom positions with a cubic spline.\n\n    Args:\n        traj (md.Trajectory): Single-strand phosphorus trajectory.\n        points (int): Number of interpolation points.\n\n    Returns:\n        coordinates (numpy.ndarray): Interpolated coordinates.\n    \"\"\"\n\n    # make curve with shape[n_particles, xyz, time]\n    xyz = traj.xyz.T.swapaxes(0,1)\n    n_particles = len(xyz)\n    particle_list = list(range(0,n_particles))\n\n    # initialize predictor based on # of actual particles\n    predictor = CubicSpline(particle_list,xyz)\n\n    # points of curve to interpolate the particles \n    return predictor(np.linspace(0,len(xyz),points))\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.get_anti_diagonal_slices","title":"<code>get_anti_diagonal_slices(matrix)</code>  <code>staticmethod</code>","text":"<p>Extract all anti-diagonal slices from a square matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>Square distance matrix.</p> required <p>Returns:</p> Name Type Description <code>slices</code> <code>list[ndarray]</code> <p>Anti-diagonal slices.</p> Source code in <code>mdna/analysis.py</code> <pre><code>@staticmethod\ndef get_anti_diagonal_slices(matrix):\n    \"\"\"Extract all anti-diagonal slices from a square matrix.\n\n    Args:\n        matrix (numpy.ndarray): Square distance matrix.\n\n    Returns:\n        slices (list[numpy.ndarray]): Anti-diagonal slices.\n    \"\"\"\n    n = matrix.shape[0] # Get the size of the matrix and skip the first and last anti diagonal\n    return [np.diagonal(np.flipud(matrix), offset) for offset in range(-(n - 2), n - 2)]\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.get_minor_major_widths","title":"<code>get_minor_major_widths(distance_matrix)</code>","text":"<p>Compute minor and major groove widths from one distance matrix.</p> <p>Parameters:</p> Name Type Description Default <code>distance_matrix</code> <code>ndarray</code> <p>Inter-strand distance matrix for a single frame.</p> required <p>Returns:</p> Name Type Description <code>widths</code> <code>tuple[list[float], list[float]]</code> <p><code>(minor_widths, major_widths)</code>.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def get_minor_major_widths(self, distance_matrix):\n    \"\"\"Compute minor and major groove widths from one distance matrix.\n\n    Args:\n        distance_matrix (numpy.ndarray): Inter-strand distance matrix for a single frame.\n\n    Returns:\n        widths (tuple[list[float], list[float]]): ``(minor_widths, major_widths)``.\n    \"\"\"\n\n    # Split the distance matrix into anti diagonal slices\n    diagonal_slices = self.get_anti_diagonal_slices(distance_matrix)\n\n    minor_widths, major_widths = [],[]\n    for slice_ in diagonal_slices:\n        minor, major = self.split_array(slice_)\n        major_widths.append(self.find_first_local_minimum(major))  # Find local minimum in the major slice and add it to the list\n        minor_widths.append(self.find_first_local_minimum(minor))  # Find local minimum in the minor slice and add it to the list \n\n    return minor_widths, major_widths\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.get_phosphors_only_traj","title":"<code>get_phosphors_only_traj(raw_traj)</code>","text":"<p>Extract phosphorus-only sub-trajectories for each strand.</p> <p>Populates :attr:<code>DNA_traj</code>, :attr:<code>phos_traj</code>, :attr:<code>strand_A</code>, and :attr:<code>strand_B</code>.</p> <p>Parameters:</p> Name Type Description Default <code>raw_traj</code> <code>Trajectory</code> <p>Full trajectory.</p> required Source code in <code>mdna/analysis.py</code> <pre><code>def get_phosphors_only_traj(self, raw_traj):\n    \"\"\"Extract phosphorus-only sub-trajectories for each strand.\n\n    Populates :attr:`DNA_traj`, :attr:`phos_traj`, :attr:`strand_A`,\n    and :attr:`strand_B`.\n\n    Args:\n        raw_traj (md.Trajectory): Full trajectory.\n    \"\"\"\n\n    # Assuming first two chains are the DNA strands\n    DNA_indices = [i.index for c in raw_traj.top._chains[:2] for i in c.atoms]\n    self.DNA_traj = raw_traj.atom_slice(DNA_indices)\n\n     # Select only phosphor atoms\n    phos_indices = self.DNA_traj.top.select('name P')\n    self.phos_traj = self.DNA_traj.atom_slice(phos_indices).center_coordinates()\n\n    # Make new topology of chains\n    phos_chain_A = self.phos_traj.topology._chains[0]\n    phos_chain_B = self.phos_traj.topology._chains[1]\n\n    # Split phos traj in two seperate traj for each strand\n    self.strand_A = self.phos_traj.atom_slice([i.index for i in phos_chain_A.atoms])\n    self.strand_B = self.phos_traj.atom_slice([i.index for i in phos_chain_B.atoms])\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.plot_groove_widths","title":"<code>plot_groove_widths(minor=True, major=True, std=True, color='k', c_minor=None, lw=0.5, c_major=None, ax=None, base_labels=True, ls='-')</code>","text":"<p>Plot minor and/or major groove widths.</p> <p>Parameters:</p> Name Type Description Default <code>minor</code> <code>bool</code> <p>Plot minor groove widths.</p> <code>True</code> <code>major</code> <code>bool</code> <p>Plot major groove widths.</p> <code>True</code> <code>std</code> <code>bool</code> <p>Show standard-deviation shading.</p> <code>True</code> <code>color</code> <code>str</code> <p>Fallback colour when c_minor/c_major are not set.</p> <code>'k'</code> <code>c_minor</code> <code>str</code> <p>Minor-groove colour.</p> <code>None</code> <code>c_major</code> <code>str</code> <p>Major-groove colour.</p> <code>None</code> <code>lw</code> <code>float</code> <p>Line width.</p> <code>0.5</code> <code>ax</code> <code>Axes</code> <p>Target axes.  A new figure is created if <code>None</code>.</p> <code>None</code> <code>base_labels</code> <code>bool</code> <p>Label the x-axis with base-pair identifiers.</p> <code>True</code> <code>ls</code> <code>str</code> <p>Line style.</p> <code>'-'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>tuple | None</code> <p><code>(fig, ax)</code> when ax was <code>None</code>.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def plot_groove_widths(self, minor=True, major=True, std=True, color='k', c_minor=None, lw=0.5, c_major=None, ax=None, base_labels=True, ls='-'):\n    \"\"\"Plot minor and/or major groove widths.\n\n    Args:\n        minor (bool): Plot minor groove widths.\n        major (bool): Plot major groove widths.\n        std (bool): Show standard-deviation shading.\n        color (str): Fallback colour when *c_minor*/*c_major* are not set.\n        c_minor (str, optional): Minor-groove colour.\n        c_major (str, optional): Major-groove colour.\n        lw (float): Line width.\n        ax (matplotlib.axes.Axes, optional): Target axes.  A new figure\n            is created if ``None``.\n        base_labels (bool): Label the x-axis with base-pair identifiers.\n        ls (str): Line style.\n\n    Returns:\n        result (tuple | None): ``(fig, ax)`` when *ax* was ``None``.\n    \"\"\"\n\n    # Create a figure and axes for plotting\n    if ax is None:\n        no_ax = True\n        _, ax = plt.subplots()\n    else:\n        no_ax = False\n\n    # If c_minor or c_major are not provided, use the general color\n    if c_minor is None:\n        c_minor = color\n    if c_major is None:\n        c_major = color\n    if (minor and major) and (c_minor == c_major):\n        c_minor = 'cornflowerblue'\n        c_major = 'coral'\n\n    if minor:\n        self.plot_width(ax, self.minor_widths, std=std, color=c_minor,ls=ls,lw=lw)\n    if major:\n        self.plot_width(ax, self.major_widths, std=std, color=c_major,ls=ls,lw=lw)\n\n    if base_labels:\n        ax.set_xticks(np.linspace(0,len(self.major_widths[0]),len(self.base_pairs)).astype(float))\n        ax.set_xticklabels(self.base_pairs,rotation=90)\n\n    if no_ax:\n        return _, ax\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.plot_width","title":"<code>plot_width(ax, groove, color=None, std=True, ls='-', lw=0.5)</code>","text":"<p>Plot mean groove width with optional standard-deviation shading.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Target axes.</p> required <code>groove</code> <code>ndarray</code> <p>Groove-width array, shape <code>(n_frames, n_points)</code>.</p> required <code>color</code> <code>str</code> <p>Line colour.</p> <code>None</code> <code>std</code> <code>bool</code> <p>If True, shade the \u00b11\u03c3 region.</p> <code>True</code> <code>ls</code> <code>str</code> <p>Line style.</p> <code>'-'</code> <code>lw</code> <code>float</code> <p>Line width.</p> <code>0.5</code> Source code in <code>mdna/analysis.py</code> <pre><code>def plot_width(self, ax, groove, color=None, std=True, ls='-', lw=0.5):\n    \"\"\"Plot mean groove width with optional standard-deviation shading.\n\n    Args:\n        ax (matplotlib.axes.Axes): Target axes.\n        groove (numpy.ndarray): Groove-width array, shape ``(n_frames, n_points)``.\n        color (str, optional): Line colour.\n        std (bool): If True, shade the \u00b11\u03c3 region.\n        ls (str): Line style.\n        lw (float): Line width.\n    \"\"\"\n    # Suppress warnings for mean of empty slice\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)    \n        # Calculate the mean and standard deviation of major widths\n        mean = np.nanmean(groove, axis=0)\n        stds = np.nanstd(groove, axis=0)\n\n    ax.plot(mean,color=color,ls=ls,lw=lw)\n    if std:\n        # Fill the area around the mean for widths\n        ax.fill_between(range(len(mean)), mean - stds, mean + stds, alpha=0.25,color=color,ls='-',lw=lw)\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.GrooveAnalysis.split_array","title":"<code>split_array(array)</code>  <code>staticmethod</code>","text":"<p>Split an anti-diagonal slice into minor and major halves.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>Anti-diagonal slice.</p> required <p>Returns:</p> Name Type Description <code>halves</code> <code>tuple[ndarray, ndarray]</code> <p><code>(minor_half, major_half)</code>.</p> Source code in <code>mdna/analysis.py</code> <pre><code>@staticmethod\ndef split_array(array):\n    \"\"\"Split an anti-diagonal slice into minor and major halves.\n\n    Args:\n        array (numpy.ndarray): Anti-diagonal slice.\n\n    Returns:\n        halves (tuple[numpy.ndarray, numpy.ndarray]): ``(minor_half, major_half)``.\n    \"\"\"\n    # Compute the midpoint of the array\n    midpoint = len(array) // 2\n\n    # If the length of the array is odd, exclude the middle element. \n    # If it's even, split the array into two equal halves.\n    # Return the two halves that correspond to lower and upper triangles of the distance matrix\n    # Reverse the first array because the order of the anti diagonal's in the opposite direction of backone/trailing diagonal\n    return array[:midpoint][::-1], array[midpoint + len(array) % 2:]\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis","title":"<code>mdna.analysis.TorsionAnalysis</code>","text":"<p>Compute backbone torsion angles and BI/BII conformational states.</p> <p>Calculates the epsilon and zeta dihedral angles of the DNA backbone and classifies each base step as BI or BII based on the sign of epsilon \u2212 zeta.</p> <p>Attributes:</p> Name Type Description <code>epsilon</code> <code>ndarray</code> <p>Epsilon torsion angles, shape <code>(n_frames, n_steps)</code>.</p> <code>zeta</code> <code>ndarray</code> <p>Zeta torsion angles, shape <code>(n_frames, n_steps)</code>.</p> <code>B_state</code> <code>ndarray</code> <p>Fraction of BII per base step.</p> Example <pre><code>torsions = TorsionAnalysis(traj)\ntorsions.B_state  # BII fraction per base step\n</code></pre> Source code in <code>mdna/analysis.py</code> <pre><code>class TorsionAnalysis:\n    \"\"\"Compute backbone torsion angles and BI/BII conformational states.\n\n    Calculates the epsilon and zeta dihedral angles of the DNA backbone\n    and classifies each base step as BI or BII based on the sign of\n    epsilon \u2212 zeta.\n\n    Attributes:\n        epsilon (numpy.ndarray): Epsilon torsion angles, shape ``(n_frames, n_steps)``.\n        zeta (numpy.ndarray): Zeta torsion angles, shape ``(n_frames, n_steps)``.\n        B_state (numpy.ndarray): Fraction of BII per base step.\n\n    Example:\n        ```python\n        torsions = TorsionAnalysis(traj)\n        torsions.B_state  # BII fraction per base step\n        ```\n    \"\"\"\n\n    def __init__(self, traj, degrees=True, chain=0):\n        \"\"\"Initialize torsion analysis.\n\n        Args:\n            traj (md.Trajectory): DNA-containing trajectory.\n            degrees (bool): Report angles in degrees (default) or radians.\n            chain (int): Chain index to analyse (0 = sense, 1 = anti-sense).\n        \"\"\"\n        self.chain = chain\n        self.dna = self.load_trajectory_and_slice_dna(traj)\n        self.epsilon, self.zeta = self.compute_BI_BII(degrees=degrees)\n        self.B_state = self.get_B_state(self.epsilon - self.zeta)\n\n    def load_trajectory_and_slice_dna(self, traj):\n        \"\"\"Slice a trajectory to keep only canonical DNA residues.\n\n        Args:\n            traj (md.Trajectory): Input trajectory.\n\n        Returns:\n            dna (md.Trajectory): Sub-trajectory containing DG, DC, DA, and DT residues.\n        \"\"\"\n        dna = traj.atom_slice(traj.top.select('resname DG DC DA DT'))\n        return dna\n\n    def get_backbone_indices(self, chainid, ref_atoms):\n        \"\"\"Collect backbone atom objects matching *ref_atoms* from a chain.\n\n        Args:\n            chainid (int): Chain index.\n            ref_atoms (list[str]): Atom names to select (e.g. ``[\"C3'\", \"O3'\"]``).\n\n        Returns:\n            indices (list): Atom objects.\n        \"\"\"\n        indices = []\n        # find torsions based on the epsilon and zeta atoms\n        # finally map the torsions for all base steps \n        if chainid == 0:\n            residues = self.dna.top._chains[chainid].residues\n        else:\n            residues = self.dna.top._chains[chainid]._residues\n\n        for res in residues:\n            for at in res.atoms:\n                if at.name in ref_atoms:\n                    indices.append(at)\n        return indices\n\n    def get_torsions(self, indices, ref_atoms):\n        \"\"\"Group sequential atoms into torsion-angle quartets.\n\n        Args:\n            indices (list): Ordered backbone atom objects.\n            ref_atoms (list[str]): Reference atom-name pattern for one torsion.\n\n        Returns:\n            torsions (list[list]): Each element is a four-atom group defining one torsion.\n        \"\"\"\n        # Find the chunks based on ref_atoms\n        torsions = []\n        i = 0\n        while i &lt; len(indices):\n            ref = [at.name for at in indices[i:i+len(ref_atoms)]]\n            if ref == ref_atoms:\n                torsions.append(indices[i:i+len(ref_atoms)])\n                i += len(ref_atoms)\n            else:\n                i += 1\n        return torsions\n\n    def get_torsion_indices(self, chainid, ref_atoms):\n        \"\"\"Get torsion-angle atom groups for a chain.\n\n        Args:\n            chainid (int): Chain index.\n            ref_atoms (list[str]): Atom-name pattern.\n\n        Returns:\n            torsions (list[list]): Torsion atom groups.\n        \"\"\"\n        indices = self.get_backbone_indices(chainid, ref_atoms)\n        torsions = self.get_torsions(indices, ref_atoms)\n        return torsions\n\n    def convert_torsion_indices_to_atom_indices(self, torsion_indices):\n        \"\"\"Convert atom objects to integer indices for MDTraj.\n\n        Args:\n            torsion_indices (list[list]): Torsion atom-object groups.\n\n        Returns:\n            atom_indices (list[list[int]]): Integer atom indices.\n        \"\"\"\n        atom_indices = []\n        for torsion in torsion_indices:\n            atom_indices.append([at.index for at in torsion])\n        return atom_indices\n\n    def compute_BI_BII(self, degrees=True):\n        \"\"\"Compute epsilon and zeta backbone torsion angles.\n\n        Args:\n            degrees (bool): Return angles in degrees.\n\n        Returns:\n            angles (tuple[numpy.ndarray, numpy.ndarray]): ``(epsilon, zeta)`` arrays.\n        \"\"\"\n\n        epsilon_atoms = [\"C4'\",\"C3'\",\"O3'\",\"P\"] \n        zeta_atoms = [\"C3'\",\"O3'\",\"P\",\"O5'\"]\n\n        epsi_0 = self.get_torsion_indices(0, epsilon_atoms)\n        epsi_1 = self.get_torsion_indices(1, epsilon_atoms)\n        zeta_0 = self.get_torsion_indices(0, zeta_atoms)\n        zeta_1 = self.get_torsion_indices(1, zeta_atoms)\n\n        print(len(epsi_0), len(epsi_1), len(zeta_0), len(zeta_1))\n\n        # From here only the antisense strand is used\n        if self.chain == 1:\n            e_torsion_indices = self.convert_torsion_indices_to_atom_indices(epsi_1)\n            z_torsion_indices = self.convert_torsion_indices_to_atom_indices(zeta_1)\n        else:\n            e_torsion_indices = self.convert_torsion_indices_to_atom_indices(epsi_0)\n            z_torsion_indices = self.convert_torsion_indices_to_atom_indices(zeta_0)\n\n        epsi = md.compute_dihedrals(self.dna, e_torsion_indices)\n        zeta = md.compute_dihedrals(self.dna, z_torsion_indices)\n\n        if degrees:\n            epsi = np.degrees(epsi)\n            zeta = np.degrees(zeta)\n\n        print(epsi.shape, zeta.shape)\n        return epsi, zeta\n\n    def get_B_state(self, diff):\n        \"\"\"Classify each base step as BI (0) or BII (1) from epsilon\u2212zeta.\n\n        Args:\n            diff (numpy.ndarray): ``epsilon - zeta`` array.\n\n        Returns:\n            state (numpy.ndarray): BII fraction per base step.\n        \"\"\"\n        state = np.zeros_like(diff)\n        state[diff &lt; 0] = 0  # BI\n        state[diff &gt; 0] = 1  # BII\n        return np.round(np.sum(state,axis=0)/state.shape[0],2)\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.__init__","title":"<code>__init__(traj, degrees=True, chain=0)</code>","text":"<p>Initialize torsion analysis.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Trajectory</code> <p>DNA-containing trajectory.</p> required <code>degrees</code> <code>bool</code> <p>Report angles in degrees (default) or radians.</p> <code>True</code> <code>chain</code> <code>int</code> <p>Chain index to analyse (0 = sense, 1 = anti-sense).</p> <code>0</code> Source code in <code>mdna/analysis.py</code> <pre><code>def __init__(self, traj, degrees=True, chain=0):\n    \"\"\"Initialize torsion analysis.\n\n    Args:\n        traj (md.Trajectory): DNA-containing trajectory.\n        degrees (bool): Report angles in degrees (default) or radians.\n        chain (int): Chain index to analyse (0 = sense, 1 = anti-sense).\n    \"\"\"\n    self.chain = chain\n    self.dna = self.load_trajectory_and_slice_dna(traj)\n    self.epsilon, self.zeta = self.compute_BI_BII(degrees=degrees)\n    self.B_state = self.get_B_state(self.epsilon - self.zeta)\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.compute_BI_BII","title":"<code>compute_BI_BII(degrees=True)</code>","text":"<p>Compute epsilon and zeta backbone torsion angles.</p> <p>Parameters:</p> Name Type Description Default <code>degrees</code> <code>bool</code> <p>Return angles in degrees.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>angles</code> <code>tuple[ndarray, ndarray]</code> <p><code>(epsilon, zeta)</code> arrays.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def compute_BI_BII(self, degrees=True):\n    \"\"\"Compute epsilon and zeta backbone torsion angles.\n\n    Args:\n        degrees (bool): Return angles in degrees.\n\n    Returns:\n        angles (tuple[numpy.ndarray, numpy.ndarray]): ``(epsilon, zeta)`` arrays.\n    \"\"\"\n\n    epsilon_atoms = [\"C4'\",\"C3'\",\"O3'\",\"P\"] \n    zeta_atoms = [\"C3'\",\"O3'\",\"P\",\"O5'\"]\n\n    epsi_0 = self.get_torsion_indices(0, epsilon_atoms)\n    epsi_1 = self.get_torsion_indices(1, epsilon_atoms)\n    zeta_0 = self.get_torsion_indices(0, zeta_atoms)\n    zeta_1 = self.get_torsion_indices(1, zeta_atoms)\n\n    print(len(epsi_0), len(epsi_1), len(zeta_0), len(zeta_1))\n\n    # From here only the antisense strand is used\n    if self.chain == 1:\n        e_torsion_indices = self.convert_torsion_indices_to_atom_indices(epsi_1)\n        z_torsion_indices = self.convert_torsion_indices_to_atom_indices(zeta_1)\n    else:\n        e_torsion_indices = self.convert_torsion_indices_to_atom_indices(epsi_0)\n        z_torsion_indices = self.convert_torsion_indices_to_atom_indices(zeta_0)\n\n    epsi = md.compute_dihedrals(self.dna, e_torsion_indices)\n    zeta = md.compute_dihedrals(self.dna, z_torsion_indices)\n\n    if degrees:\n        epsi = np.degrees(epsi)\n        zeta = np.degrees(zeta)\n\n    print(epsi.shape, zeta.shape)\n    return epsi, zeta\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.convert_torsion_indices_to_atom_indices","title":"<code>convert_torsion_indices_to_atom_indices(torsion_indices)</code>","text":"<p>Convert atom objects to integer indices for MDTraj.</p> <p>Parameters:</p> Name Type Description Default <code>torsion_indices</code> <code>list[list]</code> <p>Torsion atom-object groups.</p> required <p>Returns:</p> Name Type Description <code>atom_indices</code> <code>list[list[int]]</code> <p>Integer atom indices.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def convert_torsion_indices_to_atom_indices(self, torsion_indices):\n    \"\"\"Convert atom objects to integer indices for MDTraj.\n\n    Args:\n        torsion_indices (list[list]): Torsion atom-object groups.\n\n    Returns:\n        atom_indices (list[list[int]]): Integer atom indices.\n    \"\"\"\n    atom_indices = []\n    for torsion in torsion_indices:\n        atom_indices.append([at.index for at in torsion])\n    return atom_indices\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.get_B_state","title":"<code>get_B_state(diff)</code>","text":"<p>Classify each base step as BI (0) or BII (1) from epsilon\u2212zeta.</p> <p>Parameters:</p> Name Type Description Default <code>diff</code> <code>ndarray</code> <p><code>epsilon - zeta</code> array.</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>ndarray</code> <p>BII fraction per base step.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def get_B_state(self, diff):\n    \"\"\"Classify each base step as BI (0) or BII (1) from epsilon\u2212zeta.\n\n    Args:\n        diff (numpy.ndarray): ``epsilon - zeta`` array.\n\n    Returns:\n        state (numpy.ndarray): BII fraction per base step.\n    \"\"\"\n    state = np.zeros_like(diff)\n    state[diff &lt; 0] = 0  # BI\n    state[diff &gt; 0] = 1  # BII\n    return np.round(np.sum(state,axis=0)/state.shape[0],2)\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.get_backbone_indices","title":"<code>get_backbone_indices(chainid, ref_atoms)</code>","text":"<p>Collect backbone atom objects matching ref_atoms from a chain.</p> <p>Parameters:</p> Name Type Description Default <code>chainid</code> <code>int</code> <p>Chain index.</p> required <code>ref_atoms</code> <code>list[str]</code> <p>Atom names to select (e.g. <code>[\"C3'\", \"O3'\"]</code>).</p> required <p>Returns:</p> Name Type Description <code>indices</code> <code>list</code> <p>Atom objects.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def get_backbone_indices(self, chainid, ref_atoms):\n    \"\"\"Collect backbone atom objects matching *ref_atoms* from a chain.\n\n    Args:\n        chainid (int): Chain index.\n        ref_atoms (list[str]): Atom names to select (e.g. ``[\"C3'\", \"O3'\"]``).\n\n    Returns:\n        indices (list): Atom objects.\n    \"\"\"\n    indices = []\n    # find torsions based on the epsilon and zeta atoms\n    # finally map the torsions for all base steps \n    if chainid == 0:\n        residues = self.dna.top._chains[chainid].residues\n    else:\n        residues = self.dna.top._chains[chainid]._residues\n\n    for res in residues:\n        for at in res.atoms:\n            if at.name in ref_atoms:\n                indices.append(at)\n    return indices\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.get_torsion_indices","title":"<code>get_torsion_indices(chainid, ref_atoms)</code>","text":"<p>Get torsion-angle atom groups for a chain.</p> <p>Parameters:</p> Name Type Description Default <code>chainid</code> <code>int</code> <p>Chain index.</p> required <code>ref_atoms</code> <code>list[str]</code> <p>Atom-name pattern.</p> required <p>Returns:</p> Name Type Description <code>torsions</code> <code>list[list]</code> <p>Torsion atom groups.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def get_torsion_indices(self, chainid, ref_atoms):\n    \"\"\"Get torsion-angle atom groups for a chain.\n\n    Args:\n        chainid (int): Chain index.\n        ref_atoms (list[str]): Atom-name pattern.\n\n    Returns:\n        torsions (list[list]): Torsion atom groups.\n    \"\"\"\n    indices = self.get_backbone_indices(chainid, ref_atoms)\n    torsions = self.get_torsions(indices, ref_atoms)\n    return torsions\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.get_torsions","title":"<code>get_torsions(indices, ref_atoms)</code>","text":"<p>Group sequential atoms into torsion-angle quartets.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>list</code> <p>Ordered backbone atom objects.</p> required <code>ref_atoms</code> <code>list[str]</code> <p>Reference atom-name pattern for one torsion.</p> required <p>Returns:</p> Name Type Description <code>torsions</code> <code>list[list]</code> <p>Each element is a four-atom group defining one torsion.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def get_torsions(self, indices, ref_atoms):\n    \"\"\"Group sequential atoms into torsion-angle quartets.\n\n    Args:\n        indices (list): Ordered backbone atom objects.\n        ref_atoms (list[str]): Reference atom-name pattern for one torsion.\n\n    Returns:\n        torsions (list[list]): Each element is a four-atom group defining one torsion.\n    \"\"\"\n    # Find the chunks based on ref_atoms\n    torsions = []\n    i = 0\n    while i &lt; len(indices):\n        ref = [at.name for at in indices[i:i+len(ref_atoms)]]\n        if ref == ref_atoms:\n            torsions.append(indices[i:i+len(ref_atoms)])\n            i += len(ref_atoms)\n        else:\n            i += 1\n    return torsions\n</code></pre>"},{"location":"api/analysis/#mdna.analysis.TorsionAnalysis.load_trajectory_and_slice_dna","title":"<code>load_trajectory_and_slice_dna(traj)</code>","text":"<p>Slice a trajectory to keep only canonical DNA residues.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Trajectory</code> <p>Input trajectory.</p> required <p>Returns:</p> Name Type Description <code>dna</code> <code>Trajectory</code> <p>Sub-trajectory containing DG, DC, DA, and DT residues.</p> Source code in <code>mdna/analysis.py</code> <pre><code>def load_trajectory_and_slice_dna(self, traj):\n    \"\"\"Slice a trajectory to keep only canonical DNA residues.\n\n    Args:\n        traj (md.Trajectory): Input trajectory.\n\n    Returns:\n        dna (md.Trajectory): Sub-trajectory containing DG, DC, DA, and DT residues.\n    \"\"\"\n    dna = traj.atom_slice(traj.top.select('resname DG DC DA DT'))\n    return dna\n</code></pre>"},{"location":"api/functions/","title":"Top-Level Functions","text":"<p>These functions are the main entry points to MDNA, available directly from <code>import mdna</code>.</p>"},{"location":"api/functions/#mdna.nucleic.make","title":"<code>mdna.nucleic.make(sequence=None, control_points=None, circular=False, closed=False, n_bp=None, dLk=None, bp_per_turn=10.5)</code>","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <code>bp_per_turn</code> <code>int</code> <p>Number of base pairs per turn of the DNA structure. (default: 10.5)</p> <code>10.5</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Decision matrix <ul> <li>No <code>control_points</code>, <code>sequence</code> provided: uses default shape (line/circle from <code>circular</code>) and sets <code>n_bp = len(sequence)</code>.</li> <li>No <code>control_points</code>, <code>n_bp</code> provided: uses default shape and generates a random sequence of length <code>n_bp</code>.</li> <li><code>control_points</code> provided, <code>sequence</code> and <code>n_bp</code> both omitted: infers <code>n_bp</code> from spline sampling, then generates a random sequence of that length.</li> <li><code>control_points</code> + <code>sequence</code>: scales spline to <code>len(sequence)</code>.</li> <li><code>control_points</code> + <code>n_bp</code>: scales spline to <code>n_bp</code> and generates a random sequence.</li> <li><code>sequence</code> + <code>n_bp</code>: both are accepted only when lengths match.</li> </ul> Additional behavior <ul> <li>For <code>control_points</code>-only input (<code>sequence=None</code>, <code>n_bp=None</code>), <code>n_bp</code> is inferred from the spline frame count (shape-dependent), not from the default dodecamer.</li> </ul> Validation rules <ul> <li><code>n_bp</code> must be positive when provided.</li> <li><code>control_points</code> must have shape <code>(n, 3)</code> with <code>n &gt;= 4</code>.</li> <li><code>closed</code> is deprecated and treated as an alias of <code>circular</code>.</li> </ul> Example <p>Generate a DNA structure from a sequence <pre><code>dna = make(sequence='CGCGAATTCGCG', control_points=None, circular=False, closed=False, n_bp=None, dLk=None)\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def make(sequence: str = None, control_points: np.ndarray = None, circular : bool = False, closed: bool = False, n_bp : int = None, dLk : int = None, bp_per_turn : int = 10.5):\n    \"\"\"Generate a DNA structure from a given DNA sequence and control points.\n\n    Args:\n        sequence (str, optional): DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)\n        control_points (ndarray, optional): Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)\n        closed (bool, optional): Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)\n        n_bp (int, optional): Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)\n        dLk (int, optional): Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)\n        bp_per_turn (int, optional): Number of base pairs per turn of the DNA structure. (default: 10.5)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Decision matrix:\n        - No `control_points`, `sequence` provided: uses default shape (line/circle from `circular`) and sets `n_bp = len(sequence)`.\n        - No `control_points`, `n_bp` provided: uses default shape and generates a random sequence of length `n_bp`.\n        - `control_points` provided, `sequence` and `n_bp` both omitted: infers `n_bp` from spline sampling, then generates a random sequence of that length.\n        - `control_points` + `sequence`: scales spline to `len(sequence)`.\n        - `control_points` + `n_bp`: scales spline to `n_bp` and generates a random sequence.\n        - `sequence` + `n_bp`: both are accepted only when lengths match.\n\n    Additional behavior:\n        - For `control_points`-only input (`sequence=None`, `n_bp=None`), `n_bp` is inferred from the spline frame count (shape-dependent), not from the default dodecamer.\n\n    Validation rules:\n        - `n_bp` must be positive when provided.\n        - `control_points` must have shape `(n, 3)` with `n &gt;= 4`.\n        - `closed` is deprecated and treated as an alias of `circular`.\n\n    Example:\n        Generate a DNA structure from a sequence\n        ```python\n        dna = make(sequence='CGCGAATTCGCG', control_points=None, circular=False, closed=False, n_bp=None, dLk=None)\n        ```\n    \"\"\"\n\n    # Backward compatibility: keep supporting `closed`, but funnel semantics into `circular`.\n    if closed:\n        warnings.warn(\n            \"The 'closed' argument is deprecated and will be removed in a future release. Use 'circular' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        circular = circular or closed\n\n    # Guard against invalid explicit base-pair counts early.\n    if n_bp is not None and n_bp &lt;= 0:\n        raise ValueError('n_bp should be a positive integer')\n\n    # If control points are provided without sequence/n_bp, infer n_bp from spline arc-length sampling.\n    infer_n_bp_from_control_points = False\n\n    if control_points is not None:\n        # Normalize and validate control-point geometry input.\n        control_points = np.asarray(control_points)\n        if control_points.ndim != 2 or control_points.shape[1] != 3:\n            raise ValueError('control_points should have shape (n, 3)')\n        if len(control_points) &lt; 4:\n            raise ValueError('Control points should contain at least 4 points [x, y, z]')\n        infer_n_bp_from_control_points = sequence is None and n_bp is None\n    elif circular:\n        # Default closed template when no custom shape is provided.\n        control_points = Shapes.circle(radius=1)\n    else:\n        # Default open template when no custom shape is provided.\n        control_points = Shapes.line(length=1)\n\n    if infer_n_bp_from_control_points:\n        # Build spline first to infer n_bp, then generate a matching random sequence.\n        spline = SplineFrames(control_points=control_points, n_bp=None, closed=circular, dLk=dLk, bp_per_turn=bp_per_turn)\n        sequence, n_bp = _check_input(sequence=None, n_bp=spline.n_bp)\n    else:\n        # Resolve sequence/n_bp first (including random/default generation), then scale spline accordingly.\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n        spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk, bp_per_turn=bp_per_turn)\n\n    return Nucleic(sequence=sequence, n_bp=n_bp, frames=spline.frames, chainids=[0, 1], circular=circular)\n</code></pre>"},{"location":"api/functions/#mdna.nucleic.load","title":"<code>mdna.nucleic.load(traj=None, frames=None, sequence=None, chainids=[0, 1], circular=None, filename=None, top=None, stride=None)</code>","text":"<p>Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>frames</code> <code>array</code> <p>Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>sequence</code> <code>str</code> <p>DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>chainids</code> <code>list</code> <p>Chain IDs of the DNA structure. (default: [0,1])</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)</p> <code>None</code> <code>filename</code> <code>str</code> <p>The filename or filenames of the trajectory. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>top</code> <code>str</code> <p>The topology file of the trajectory. (default: None)</p> <code>None</code> <code>stride</code> <code>int</code> <p>The stride of the trajectory. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li><code>filename</code> is resolved first to an MDtraj trajectory (optionally using <code>top</code> and <code>stride</code>).</li> <li>The resulting <code>traj</code> then takes precedence over <code>frames</code> and <code>sequence</code> when constructing <code>Nucleic</code>.</li> </ul> Example <p>Load a DNA structure from a trajectory <pre><code>traj = md.load('dna.pdb')\ndna = mdna.load(traj=traj, chainids=[0, 1])\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def load(traj=None, frames=None, sequence=None, chainids=[0,1], circular=None, filename=None, top=None, stride=None):\n    \"\"\"Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.\n\n    Args:\n        traj (object, optional): MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)\n        frames (np.array, optional): Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)\n        sequence (str, optional): DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)\n        chainids (list, optional): Chain IDs of the DNA structure. (default: [0,1])\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)\n        filename (str, optional): The filename or filenames of the trajectory. If provided, the traj and frames arguments are ignored. (default: None)\n        top (str, optional): The topology file of the trajectory. (default: None)\n        stride (int, optional): The stride of the trajectory. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - `filename` is resolved first to an MDtraj trajectory (optionally using `top` and `stride`).\n        - The resulting `traj` then takes precedence over `frames` and `sequence` when constructing `Nucleic`.\n\n    Example:\n        Load a DNA structure from a trajectory\n        ```python\n        traj = md.load('dna.pdb')\n        dna = mdna.load(traj=traj, chainids=[0, 1])\n        ```\n    \"\"\"\n    # Load the trajectory directly using MDtraj from a file\n    if filename is not None and top is None:\n        traj = md.load(filename_or_filenames=filename, stride=stride)\n    elif filename is not None and top is not None:\n        traj = md.load(filename_or_filenames=filename, top=top, stride=stride)\n\n    return Nucleic(sequence=sequence, n_bp=None, traj=traj, frames=frames, chainids=chainids, circular=None)\n</code></pre>"},{"location":"api/functions/#mdna.nucleic.connect","title":"<code>mdna.nucleic.connect(Nucleic0, Nucleic1, sequence=None, n_bp=None, leader=0, frame=-1, margin=1, minimize=True, exvol_rad=0.0, temperature=300, control_points=None, index=0)</code>","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str or List</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Notes <ul> <li>The minimization does not use excluded volume interactions by default.This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</li> </ul> Example <p>Connect two DNA structures <pre><code>dna = connect(Nucleic0, Nucleic1, margin=5)\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def connect(Nucleic0, Nucleic1, sequence: Union[str|List] = None, n_bp: int = None, leader: int = 0, frame: int = -1, margin: int = 1, minimize: bool = True, exvol_rad: float = 0.0, temperature: int = 300, control_points : np.ndarray = None, index : int = 0):  \n    \"\"\"Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.\n\n    The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure.\n    To connect the two strands, a straight line is interpolated between the two ends,\n    and the optimal number of base pairs is distributed to achieve a neutral twist.\n\n    Args:\n        Nucleic0 (Nucleic): First DNA structure to connect.\n        Nucleic1 (Nucleic): Second DNA structure to connect.\n        sequence (str or List, optional): DNA sequence of the connecting DNA strand. Default is None.\n        n_bp (int, optional): Number of base pairs of the connecting DNA strand. Default is None.\n        leader (int, optional): The leader of the DNA structure to connect. Default is 0.\n        frame (int, optional): The time frame to connect. Default is -1.\n        margin (int, optional): Number of base pairs to fix at the end. Default is 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure. Default is True.\n        exvol_rad (float, optional): Radius for excluded volume interactions during minimization. Default is 0.0.\n        temperature (int, optional): Temperature for minimization. Default is 300.\n\n    Returns:\n        Nucleic (object): DNA structure with the two DNA structures connected.\n\n    Raises:\n        ValueError: If either of the DNA structures is circular.\n\n    Notes:\n        - The minimization does not use excluded volume interactions by default.This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.\n\n    Example:\n        Connect two DNA structures\n        ```python\n        dna = connect(Nucleic0, Nucleic1, margin=5)\n        ```\n    \"\"\"\n    if Nucleic0.circular or Nucleic1.circular:\n        raise ValueError('Cannot connect circular DNA structures')\n\n    if (sequence is not None and n_bp is None) or (sequence is None and n_bp is not None) or (sequence is not None and n_bp is not None):\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    # Connect the two DNA structures\n    connector = Connector(Nucleic0, Nucleic1, sequence=sequence, n_bp=n_bp, leader=leader, frame=frame, margin=margin, control_points=control_points, index=index)\n    if minimize:\n        connector.connected_nuc.minimize(exvol_rad=exvol_rad, temperature=temperature, fixed=connector.fixed)\n    return connector.connected_nuc\n</code></pre>"},{"location":"api/functions/#mdna.nucleic.compute_rigid_parameters","title":"<code>mdna.nucleic.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=False)</code>","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <code>fit_reference</code> <code>bool</code> <p>Fit each base to canonical reference bases before frame extraction. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example <p>Compute the rigid base parameters of a DNA structure ```python traj = md.load('dna.pdb') rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1]) ````</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1], fit_reference=False):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n        fit_reference (bool, optional): Fit each base to canonical reference bases before\n            frame extraction. Default is False.\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        Compute the rigid base parameters of a DNA structure\n        ```python\n        traj = md.load('dna.pdb')\n        rigid_params = mdna.compute_rigid_parameters(traj, chainids=[0, 1])\n        ````\n    \"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids, fit_reference=fit_reference)\n</code></pre>"},{"location":"api/functions/#mdna.nucleic.sequence_to_pdb","title":"<code>mdna.nucleic.sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None, save_location='./')</code>","text":"<p>Generate a DNA structure from a DNA sequence code.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence code. Default is 'CGCGAATTCGCG'.</p> <code>'CGCGAATTCGCG'</code> <code>filename</code> <code>str</code> <p>The filename for the pdb output. Default is 'my_dna'.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Whether to save the pdb file. Default is True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The type of pdb DNA format. Default is 'GROMACS'.</p> <code>'GROMACS'</code> <code>shape</code> <code>ndarray</code> <p>Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Indicates if the structure is circular/closed. Default is False.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.</p> <code>None</code> <code>save_location</code> <code>str</code> <p>Location to save the trajectory. Default is './'.</p> <code>'./'</code> <p>Returns:</p> Type Description <code>Trajectory</code> <p>md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence is not provided.</p> Notes <ul> <li>The pdb file is saved in the current directory with the specified filename.</li> </ul> Example <p>Generate a DNA structure from a sequence <pre><code>traj = mdna.sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def sequence_to_pdb(sequence: str = 'CGCGAATTCGCG', filename: str = 'my_dna', save: bool = True, output: str = 'GROMACS', shape: np.ndarray = None, n_bp: int = None, circular: bool = False, dLk: int = None, save_location : str = './') -&gt; md.Trajectory:\n    \"\"\"Generate a DNA structure from a DNA sequence code.\n\n    Args:\n        sequence (str, optional): The DNA sequence code. Default is 'CGCGAATTCGCG'.\n        filename (str, optional): The filename for the pdb output. Default is 'my_dna'.\n        save (bool, optional): Whether to save the pdb file. Default is True.\n        output (str, optional): The type of pdb DNA format. Default is 'GROMACS'.\n        shape (np.ndarray, optional): Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.\n        n_bp (int, optional): Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.\n        circular (bool, optional): Indicates if the structure is circular/closed. Default is False.\n        dLk (int, optional): Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.\n        save_location (str, optional): Location to save the trajectory. Default is './'.\n\n    Returns:\n        md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).\n\n    Raises:\n        ValueError: If the sequence is not provided.\n\n    Notes:\n        - The pdb file is saved in the current directory with the specified filename.\n\n    Example:\n        Generate a DNA structure from a sequence\n        ```python\n        traj = mdna.sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)\n        ```\n    \"\"\"\n\n    # Check if the sequence is provided\n    if sequence is None:\n        raise ValueError(\"The sequence argument must be provided.\")\n\n    # TODO: Update with make function\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    # Linear strand of control points\n    if shape is None:\n        shape = Shapes.line(length=1)\n\n    # Convert the control points to a spline\n    spline = SplineFrames(control_points=shape, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    # Generate the DNA structure\n    generator = StructureGenerator(sequence=sequence, spline=spline, circular=circular)\n\n    # Edit the DNA structure to make it compatible with the AMBER force field\n    traj = generator.get_traj(remove_terminal_phosphates=(output == 'GROMACS'))\n\n    # Save the DNA structure as a pdb file\n    if save:\n        traj.save(f'{save_location}{filename}.pdb')\n\n    return traj\n</code></pre>"},{"location":"api/functions/#mdna.nucleic.sequence_to_md","title":"<code>mdna.nucleic.sequence_to_md(sequence=None, time=10, time_unit='picoseconds', temperature=310, solvated=False, filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None, save_location='./')</code>","text":"<p>Simulate DNA sequence using OpenMM.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code.</p> <code>None</code> <code>time</code> <code>int</code> <p>Simulation time.</p> <code>10</code> <code>time_unit</code> <code>str</code> <p>Time unit (picoseconds or nanoseconds).</p> <code>'picoseconds'</code> <code>temperature</code> <code>int</code> <p>Temperature in Kelvin.</p> <code>310</code> <code>solvated</code> <code>bool</code> <p>Solvate DNA with water and ions.</p> <code>False</code> <code>filename</code> <code>str</code> <p>Filename for pdb output.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Save the trajectory.</p> <code>True</code> <code>output</code> <code>str</code> <p>Output format for the trajectory (GROMACS or HDF5).</p> <code>'GROMACS'</code> <code>shape</code> <code>str</code> <p>Shape of the DNA structure (linear or circular).</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs in the DNA structure.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in linking number of the DNA structure.</p> <code>None</code> <code>save_location</code> <code>str</code> <p>Location to save the trajectory.</p> <code>'./'</code> <p>Returns:</p> Name Type Description <code>MDTraj</code> <code>object</code> <p>MDtraj trajectory object of DNA structure.</p> Notes <ul> <li>This function uses the OpenMM library to simulate the behavior of a DNA sequence.</li> <li>The simulation can be performed for a specified time period at a given temperature.</li> <li>The DNA structure can be solvated with water and ions.</li> <li>The trajectory of the simulation can be saved in either GROMACS or HDF5 format.</li> </ul> Example <p>Simulate a linear DNA structure for 100 picoseconds at 300 K <pre><code>trajectory = mdna.sequence_to_md(sequence='ATCGATA', time=100, time_unit='picoseconds', temperature=300, shape='linear')\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def sequence_to_md(sequence=None, time=10, time_unit='picoseconds',temperature=310, solvated=False,  filename='my_dna', save=True, output='GROMACS',shape=None,n_bp=None,circular=False,dLk=None,save_location='./'):\n    \"\"\"Simulate DNA sequence using OpenMM.\n\n        Args:\n            sequence (str): DNA sequence code.\n            time (int): Simulation time.\n            time_unit (str): Time unit (picoseconds or nanoseconds).\n            temperature (int): Temperature in Kelvin.\n            solvated (bool): Solvate DNA with water and ions.\n            filename (str): Filename for pdb output.\n            save (bool): Save the trajectory.\n            output (str): Output format for the trajectory (GROMACS or HDF5).\n            shape (str): Shape of the DNA structure (linear or circular).\n            n_bp (int): Number of base pairs in the DNA structure.\n            circular (bool): Flag indicating if the DNA structure is circular.\n            dLk (int): Change in linking number of the DNA structure.\n            save_location (str): Location to save the trajectory.\n\n        Returns:\n            MDTraj (object): MDtraj trajectory object of DNA structure.\n\n        Notes:\n            - This function uses the OpenMM library to simulate the behavior of a DNA sequence.\n            - The simulation can be performed for a specified time period at a given temperature.\n            - The DNA structure can be solvated with water and ions.\n            - The trajectory of the simulation can be saved in either GROMACS or HDF5 format.\n\n        Example:\n            Simulate a linear DNA structure for 100 picoseconds at 300 K\n            ```python\n            trajectory = mdna.sequence_to_md(sequence='ATCGATA', time=100, time_unit='picoseconds', temperature=300, shape='linear')\n            ```\n        \"\"\"\n\n    # TODO update with make function\n    try:\n        import openmm as mm\n        import openmm.app as app\n        import openmm.unit as unit\n        from mdtraj.reporters import HDF5Reporter\n        import mdtraj as md\n        openmm_available = True\n    except ImportError:\n        openmm_available = False\n        print(\"Openmm is not installed. You shall not pass.\")\n    if filename is None:\n        filename = sequence\n\n    pdb = sequence_to_pdb(sequence=sequence, filename=f'{save_location}{filename}', save=True, output='GROMACS',shape=shape,n_bp=n_bp,circular=circular,dLk=dLk)\n\n    if not openmm_available:\n        print('But here is your DNA structure')\n        return pdb\n    else:\n        if time_unit == 'picoseconds':\n            simulation_time = time * unit.picoseconds\n        elif time_unit == 'nanoseconds':\n            simulation_time = time * unit.nanoseconds\n        else:\n            raise ValueError(\"time_unit should be 'picoseconds' or 'nanoseconds'\")\n\n        time_step = 2 * unit.femtoseconds\n        temperature = temperature * unit.kelvin\n        steps = int(simulation_time / time_step)\n\n        print(f'Initialize DNA openMM simulation at {temperature._value} K for', simulation_time, 'time units')\n        topology = pdb.topology.to_openmm()\n        modeller = app.Modeller(topology, pdb.xyz[0])\n\n        forcefield = app.ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')\n        modeller.addHydrogens(forcefield)\n        if solvated:\n            print('Solvate DNA with padding of 1.0 nm and 0.1 M KCl')\n            modeller.addSolvent(forcefield, padding=1.0*unit.nanometers, ionicStrength=0.1*unit.molar, positiveIon='K+')\n\n        system = forcefield.createSystem(modeller.topology, nonbondedMethod=app.CutoffNonPeriodic)\n        integrator = mm.LangevinIntegrator(temperature, 1.0/unit.picoseconds, time_step)\n\n        simulation = app.Simulation(modeller.topology, system, integrator)\n        simulation.context.setPositions(modeller.positions)\n        simulation.reporters.append(HDF5Reporter(f'{save_location}{filename}'+'.h5', 100))\n        simulation.reporters.append(app.StateDataReporter(f'{save_location}/output_{filename}.csv', 100, step=True, potentialEnergy=True, temperature=True,speed=True))\n\n        print('Minimize energy')\n        simulation.minimizeEnergy()\n\n        print('Run simulation for', steps, 'steps')\n        simulation.step(steps)\n        simulation.reporters[0].close()\n        print('Simulation completed')\n        print('Saved trajectory as:', f'{save_location}{filename}'+'.h5')\n        traj = md.load_hdf5(f'{save_location}{filename}'+'.h5')\n        return traj\n</code></pre>"},{"location":"api/generators/","title":"Generators","text":"<p>Classes for constructing DNA topology and atomic coordinates from sequence and frames.</p>"},{"location":"api/generators/#mdna.generators.SequenceGenerator","title":"<code>mdna.generators.SequenceGenerator</code>","text":"<p>Build an MDTraj DNA trajectory and topology from a nucleotide sequence.</p> <p>Creates a double-stranded DNA structure using pre-loaded canonical and non-canonical base reference structures.  Each base is placed at a dummy position; the real coordinates are applied later by :class:<code>StructureGenerator</code>.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>str</code> <p>Sense-strand sequence.</p> <code>circular</code> <code>bool</code> <p>Whether the DNA is circular.</p> <code>traj</code> <code>Trajectory</code> <p>The generated trajectory with topology.</p> Example <pre><code>gen = SequenceGenerator(sequence='GCAATATATTGC', circular=False)\ngen.traj  # MDTraj Trajectory with dummy coordinates\n</code></pre> Source code in <code>mdna/generators.py</code> <pre><code>class SequenceGenerator:\n    \"\"\"Build an MDTraj DNA trajectory and topology from a nucleotide sequence.\n\n    Creates a double-stranded DNA structure using pre-loaded canonical and\n    non-canonical base reference structures.  Each base is placed at a\n    dummy position; the real coordinates are applied later by\n    :class:`StructureGenerator`.\n\n    Attributes:\n        sequence (str): Sense-strand sequence.\n        circular (bool): Whether the DNA is circular.\n        traj (md.Trajectory): The generated trajectory with topology.\n\n    Example:\n        ```python\n        gen = SequenceGenerator(sequence='GCAATATATTGC', circular=False)\n        gen.traj  # MDTraj Trajectory with dummy coordinates\n        ```\n    \"\"\"\n\n    def __init__(self, sequence=None, circular=False):\n        \"\"\"Initialize the sequence generator.\n\n        Args:\n            sequence (str, optional): DNA sequence code (sense strand).\n            circular (bool): If True, create a circular DNA topology.\n        \"\"\"\n        #self.base_pair_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C','P':'T','D':'C','H':'T'}\n        self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n        self.sequence = sequence\n        self.circular = circular\n        self.reference_bases = self._load_reference_bases()\n        self.traj = self._make_DNA()\n\n    def _load_reference_bases(self):\n        \"\"\"Loads reference bases from PDB files.\"\"\"\n        # import networkx as nx\n        # G = DNA.top.to_bondgraph()\n        # # check which nodes are not connected to any other node\n        # isolated_nodes = list(nx.isolates(G))\n        # print(isolated_nodes)\n        # # somhow Thymine phospho-oxyo's are not connected to anything\n\n        return  {base: md.load_hdf5(get_data_file_path(f'atomic/bases/BDNA_{base}.h5')) for base in self.base_pair_map.keys()}\n\n        #return {base: md.load_pdb(f'/Users/thor/surfdrive/Projects/mdna/mdna/atomic/BDNA_{base}.pdb') for base in self.base_pair_map.keys()}\n        #return {base: md.load_pdb(f'../mdna/atomic/BDNA_{base}.pdb') for base in self.base_pair_map.keys()}\n\n    def _make_DNA(self):\n        \"\"\"Create the combined DNA trajectory and topology.\n\n        Returns:\n            md.Trajectory: Trajectory with both sense and anti-sense chains.\n        \"\"\"\n        trajectory = self._create_trajectory()\n        topology = self._create_topology()\n        return md.Trajectory(trajectory, topology)\n\n    def _create_trajectory(self, translation=0.00001):\n        \"\"\"Create coordinate arrays for both strands.\n\n        Args:\n            translation (float): Small offset to avoid overlapping reference coordinates.\n\n        Returns:\n            numpy.ndarray: Concatenated coordinates for all atoms.\n        \"\"\"\n        trajectory_coords = []\n\n        # Sense chain coordinates are added first starting from index 0 to N-1 sequence length\n        trajectory_coords.extend(self._get_chain_coordinates(self.sequence, translation))\n\n        # Antisense chain coordinates are added next, coordinates are flipped, starting from N sequence length to N*2-1\n        # Here the first base, N, is the complement of first base in the sense strand, this might not be ideal (have to check what is done in the literature)\n        antisense_sequence = [self.base_pair_map[base] for base in self.sequence]\n        trajectory_coords.extend(self._get_chain_coordinates(antisense_sequence[::-1], translation, antisense=True))\n\n        return np.concatenate(trajectory_coords, axis=1)\n\n    def _create_topology(self):\n        \"\"\"Build the MDTraj topology with sense and anti-sense chains.\n\n        Returns:\n            md.Topology: Complete double-stranded DNA topology.\n        \"\"\"\n        topology = md.Topology()\n        sense_chain = topology.add_chain()\n        antisense_chain = topology.add_chain()\n\n        # Sense chain residues\n        self._add_chain_to_topology(self.sequence, topology, sense_chain)\n\n        # Antisense chain residues\n        antisense_sequence = [self.base_pair_map[base] for base in self.sequence]\n        self._add_chain_to_topology(antisense_sequence[::-1], topology, antisense_chain)\n\n        # Create standard bonds between atoms\n        topology.create_standard_bonds()\n\n        # Connect adjacent residues\n        self._connect_chain(topology, sense_chain)\n        self._connect_chain(topology, antisense_chain)\n\n        # Make the DNA circular if specified\n        if self.circular:\n            residues_sense = list(sense_chain.residues)\n            residues_antisense = list(antisense_chain.residues)\n            self._connect_residues(topology, residues_sense[-1], residues_sense[0])\n            self._connect_residues(topology, residues_antisense[-1], residues_antisense[0])\n\n        return topology\n\n    def _add_chain_to_topology(self, sequence, topology, chain):\n        \"\"\"Add residues for a full strand to the topology.\n\n        Args:\n            sequence (str or list): Nucleotide sequence.\n            topology (md.Topology): Target topology.\n            chain: Chain object to add residues to.\n        \"\"\"\n        for _,base in enumerate(sequence):\n            self._add_residue_to_topology(base, topology, chain, resSeq=_+1)\n\n    def _add_residue_to_topology(self, base, topology, chain, resSeq):\n        \"\"\"Add a single residue and its atoms to the topology.\n\n        Args:\n            base (str): One-letter base code.\n            topology (md.Topology): Target topology.\n            chain: Chain to add the residue to.\n            resSeq (int): Residue sequence number.\n        \"\"\"\n        residue = topology.add_residue(name='D' + base, chain=chain, resSeq=resSeq)\n        self._copy_atoms_from_reference(base, residue, topology)\n\n    def _copy_atoms_from_reference(self, base, residue, topology):\n        \"\"\"Copy atom definitions from the reference base to the new residue.\n\n        Args:\n            base (str): One-letter base code.\n            residue: Target residue in the topology.\n            topology (md.Topology): Target topology.\n        \"\"\"\n        for atom in self.reference_bases[base].topology.atoms:\n            topology.add_atom(atom.name, atom.element, residue)\n\n    def _connect_chain(self, topology, chain):\n        \"\"\"Add phosphodiester bonds between adjacent residues in a chain.\n\n        Args:\n            topology (md.Topology): Target topology.\n            chain: Chain whose residues should be connected.\n        \"\"\"\n        residues = list(chain.residues)\n        for i in range(len(residues) - 1):\n            self._connect_residues(topology, residues[i], residues[i+1])\n\n    def _connect_residues(self, topology, residue1, residue2):\n        \"\"\"Add an O3'\u2013P phosphodiester bond between two residues.\n\n        Args:\n            topology (md.Topology): Target topology.\n            residue1: Upstream residue (provides O3').\n            residue2: Downstream residue (provides P).\n        \"\"\"\n        topology.add_bond(residue1.atom(\"O3'\"), residue2.atom(\"P\"))\n\n    def get_basepair(self, base):\n        \"\"\"Get reference base-pair trajectories for a base and its complement.\n\n        Args:\n            base (str): One-letter base code.\n\n        Returns:\n            result (tuple[md.Trajectory, md.Trajectory]): ``(base_traj, complement_traj)``.\n        \"\"\"\n        return self.reference_bases[base], self.reference_bases[self.base_pair_map[base]]\n\n    def _rotation_matrix(self,axis, theta):\n        \"\"\"Compute a rotation matrix for counterclockwise rotation.\n\n        Args:\n            axis (numpy.ndarray): Rotation axis.\n            theta (float): Rotation angle in radians.\n\n        Returns:\n            R (numpy.ndarray): 3x3 rotation matrix.\n        \"\"\"\n        axis = np.asarray(axis)\n        axis = axis / np.linalg.norm(axis)\n        a = np.cos(theta / 2.0)\n        b, c, d = -axis * np.sin(theta / 2.0)\n        aa, bb, cc, dd = a * a, b * b, c * c, d * d\n        bc, ad, ac, ab, bd, cd = b * c, a * d, a * c, a * b, b * d, c * d\n        return np.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],\n                        [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],\n                        [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])\n\n    def _get_chain_coordinates(self, sequence, translation, antisense=False):\n        \"\"\"Generate coordinate arrays for a single strand.\n\n        Args:\n            sequence (str or list): Nucleotide sequence.\n            translation (float): Small offset applied to reference coordinates.\n            antisense (bool): If True, rotate coordinates 180\u00b0 around the x-axis\n                for the anti-sense strand.\n\n        Returns:\n            list[numpy.ndarray]: Per-residue coordinate arrays.\n        \"\"\"\n        coords = []\n        for base in sequence:\n            base_coords = (self.reference_bases[base].xyz + translation) #* -1\n            if antisense:\n                #base_coords = -base_coords # Flip coordinates\n                axis = [1, 0, 0]  # Rotate about x-axis\n                theta = np.pi  # Rotate by 180 degrees\n                # Compute the rotation matrix\n                R = self._rotation_matrix(axis, theta)\n                # Rotate base pair A (assuming you have it in a variable `base_pair_A`)\n                base_coords = np.dot(base_coords, R.T) #* -1 \n\n            coords.append(base_coords)\n        return coords\n</code></pre>"},{"location":"api/generators/#mdna.generators.SequenceGenerator.__init__","title":"<code>__init__(sequence=None, circular=False)</code>","text":"<p>Initialize the sequence generator.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code (sense strand).</p> <code>None</code> <code>circular</code> <code>bool</code> <p>If True, create a circular DNA topology.</p> <code>False</code> Source code in <code>mdna/generators.py</code> <pre><code>def __init__(self, sequence=None, circular=False):\n    \"\"\"Initialize the sequence generator.\n\n    Args:\n        sequence (str, optional): DNA sequence code (sense strand).\n        circular (bool): If True, create a circular DNA topology.\n    \"\"\"\n    #self.base_pair_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C','P':'T','D':'C','H':'T'}\n    self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n    self.sequence = sequence\n    self.circular = circular\n    self.reference_bases = self._load_reference_bases()\n    self.traj = self._make_DNA()\n</code></pre>"},{"location":"api/generators/#mdna.generators.SequenceGenerator.get_basepair","title":"<code>get_basepair(base)</code>","text":"<p>Get reference base-pair trajectories for a base and its complement.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>str</code> <p>One-letter base code.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>tuple[Trajectory, Trajectory]</code> <p><code>(base_traj, complement_traj)</code>.</p> Source code in <code>mdna/generators.py</code> <pre><code>def get_basepair(self, base):\n    \"\"\"Get reference base-pair trajectories for a base and its complement.\n\n    Args:\n        base (str): One-letter base code.\n\n    Returns:\n        result (tuple[md.Trajectory, md.Trajectory]): ``(base_traj, complement_traj)``.\n    \"\"\"\n    return self.reference_bases[base], self.reference_bases[self.base_pair_map[base]]\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator","title":"<code>mdna.generators.StructureGenerator</code>","text":"<p>Place nucleotide coordinates onto a spatial path defined by rigid-body frames.</p> <p>Takes an array of rigid-body frames (origin + three basis vectors per base pair) and a nucleotide sequence, then produces an MDTraj trajectory with atomic coordinates transformed to follow the path.</p> <p>Attributes:</p> Name Type Description <code>circular</code> <code>bool</code> <p>Whether the DNA is circular.</p> <code>sequence</code> <code>str</code> <p>Sense-strand sequence (auto-generated if not provided).</p> <code>spline</code> <code>SplineFrames or None</code> <p>Optional spline that supplies the frames.</p> <code>frames</code> <code>ndarray</code> <p>Shape <code>(n_bp, 4, 3)</code> rigid-body frames.</p> <code>length</code> <code>int</code> <p>Number of base pairs.</p> <code>traj</code> <code>Trajectory</code> <p>Resulting trajectory with positioned coordinates.</p> Example <pre><code>from mdna import SplineFrames, StructureGenerator\nspline = SplineFrames(control_points)\ngen = StructureGenerator(spline=spline, sequence='ATCG')\ngen.traj  # MDTraj trajectory with coordinates on the spline\n</code></pre> Source code in <code>mdna/generators.py</code> <pre><code>class StructureGenerator:\n    \"\"\"Place nucleotide coordinates onto a spatial path defined by rigid-body frames.\n\n    Takes an array of rigid-body frames (origin + three basis vectors per\n    base pair) and a nucleotide sequence, then produces an MDTraj trajectory\n    with atomic coordinates transformed to follow the path.\n\n    Attributes:\n        circular (bool): Whether the DNA is circular.\n        sequence (str): Sense-strand sequence (auto-generated if not provided).\n        spline (SplineFrames or None): Optional spline that supplies the frames.\n        frames (numpy.ndarray): Shape ``(n_bp, 4, 3)`` rigid-body frames.\n        length (int): Number of base pairs.\n        traj (md.Trajectory): Resulting trajectory with positioned coordinates.\n\n    Example:\n        ```python\n        from mdna import SplineFrames, StructureGenerator\n        spline = SplineFrames(control_points)\n        gen = StructureGenerator(spline=spline, sequence='ATCG')\n        gen.traj  # MDTraj trajectory with coordinates on the spline\n        ```\n    \"\"\"\n\n    def __init__(self, spline=None, sequence=None, circular=False, frames=None):\n        \"\"\"Initialize the structure generator.\n\n        Either *spline* or *frames* must be provided.  If both are given,\n        *frames* takes precedence.\n\n        Args:\n            spline (SplineFrames, optional): Spline object that provides frames.\n            sequence (str, optional): DNA sequence.  When ``None`` a random\n                sequence with 50 %% AT content is generated.\n            circular (bool): Generate circular DNA topology.\n            frames (numpy.ndarray, optional): Rigid-body frames with shape\n                ``(n_bp, 4, 3)``.\n\n        Raises:\n            ValueError: If neither *spline* nor *frames* is provided.\n        \"\"\"\n        self.circular = circular\n        self.sequence = sequence # Should deal with the fact if the sequence length does not match the spline length\n        self.spline = spline\n        if spline is not None:\n            self.frames = spline.frames\n        elif spline is None and frames is not None:\n            self.frames = frames\n        elif spline is not None and frames is not None:\n            self.frames = frames\n            print(\"Both spline and frames are provided, using frames\")\n        else:\n            raise ValueError(\"Either spline or frames must be provided\")\n\n        self.length = self.frames.shape[0] # numer of base pairs \n        self.initialize()\n        self.apply_spline()\n\n    def initialize(self):\n        \"\"\"Build the initial trajectory with dummy coordinates.\n\n        Generates a random sequence if none was provided, then creates\n        the topology and reference coordinates via :class:`SequenceGenerator`.\n        \"\"\"\n\n        # Generate DNA sequence\n        if self.sequence is None:\n            # Fraction of AT content\n            self.sequence = self.generate_letter_sequence(at_fraction=0.5)\n            print(self.sequence)\n\n        # Generate DNA trajectory and topology with dummy coordinates (aka everything based on standard bases)\n        self.dna = SequenceGenerator(sequence=self.sequence, circular=self.circular)\n        self.traj = self.dna.traj\n\n\n    def apply_spline(self):\n        \"\"\"Transform dummy base-pair coordinates to follow the spatial frames.\n\n        Iterates over every base pair and applies a rotation and translation\n        so that each base pair is positioned and oriented according to the\n        corresponding entry in :attr:`frames`.\n        \"\"\"\n\n        # Get base pair topology of strands\n        sense = self.traj.top._chains[0]._residues\n        anti = self.traj.top._chains[1]._residues[::-1]\n        basepairs = np.array(list(zip(sense, anti)))\n\n        # Set the dummy coordinates\n        initial_frame = np.array([[0,0,0],[1,0,0],[0,1,0],[0,0,1]])\n\n        # Create a list of initial frames for each base pair\n        basepair_frames = np.array([initial_frame for _ in range(len(basepairs))])  # Shape: (n_basepairs, 4, 3)\n\n        # Add an empty axis to match expected dimensions (n_basepairs, 1, 4, 3)\n        current_frames = basepair_frames[:, np.newaxis, :, :]\n        new_frames = self.frames #spline.frames # has shape (n_basepairs, 4, 3) base pairs, frames\n\n        # Loop over base pairs and apply the transformation to the base pair coordinates\n        for idx,(old,new) in enumerate(zip(current_frames, new_frames)):\n            self.update_basepair_coordinates(old, new, basepairs, idx)\n\n    def update_basepair_coordinates(self, old, new, basepairs, idx):\n        \"\"\"Rotate and translate a single base pair to a new frame.\n\n        Args:\n            old (numpy.ndarray): Current frame for this base pair, shape ``(1, 4, 3)``.\n            new (numpy.ndarray): Target frame, shape ``(4, 3)``.\n            basepairs (numpy.ndarray): Array of ``(sense_residue, antisense_residue)`` pairs.\n            idx (int): Index of the base pair to update.\n        \"\"\"\n\n        # Get the origin of the old and new frames\n        old_origin = old[0][0]\n        new_origin = new[0]\n\n        # Get basis of the old and new frames\n        old_basis = old[0][1:]\n        new_basis = np.array(new[1:]) # maybe need to flip the basis vectors here to get the right orientation\n\n        # Get the rotation and translation\n        rot = np.linalg.solve(old_basis,new_basis)\n        # rot = np.dot(new_basis,old_basis.T) &lt;-- this is the same as above\n        trans = new_origin - old_origin\n\n        # First collect xyz coordinates of the base pairs\n        xyz, indices = self.get_basepair_xyz(basepairs,idx)\n\n        # Apply the rotation and translation\n        new_xyz = np.dot(xyz,rot) + trans\n\n        # Set the new coordinates\n        self.traj.xyz[:,indices,:] = new_xyz\n        # return dna\n\n    def generate_letter_sequence(self, at_fraction=0.5):\n        \"\"\"Generate a random DNA sequence with a specified AT content.\n\n        Args:\n            at_fraction (float): Fraction of A/T bases (0\u20131).\n\n        Returns:\n            sequence (str): Random DNA sequence of length :attr:`length`.\n\n        Raises:\n            ValueError: If *at_fraction* is outside [0, 1].\n        \"\"\"\n        # Ensure at_fraction is within valid bounds\n        if not (0 &lt;= at_fraction &lt;= 1):\n            raise ValueError(\"at_fraction must be between 0 and 1 inclusive\")\n        # Calculate the number of 'A' and 'T' bases based on the given fraction\n        bases = ['A', 'T'] * int(self.length * at_fraction) + ['G', 'C'] * (self.length - int(self.length * at_fraction))\n        return ''.join(random.sample(bases, self.length))\n\n    def get_basepair_xyz(self, basepairs, idx):\n        \"\"\"Get atom coordinates for a single base pair.\n\n        Args:\n            basepairs (numpy.ndarray): Array of ``(sense_residue, antisense_residue)`` pairs.\n            idx (int): Base-pair index.\n\n        Returns:\n            result (tuple[numpy.ndarray, list[int]]): ``(xyz, atom_indices)``.\n        \"\"\"\n        indices = [at.index for at in basepairs[idx][0].atoms] + [at.index for at in basepairs[idx][1].atoms]\n        return self.traj.xyz[:,indices,:], indices\n\n    def get_traj(self, remove_terminal_phosphates: bool = False):\n        \"\"\"Return the DNA trajectory, optionally trimming terminal phosphates.\n\n        Args:\n            remove_terminal_phosphates (bool): If True and the structure is\n                linear, remove the 5\u2032 phosphate groups at the termini.\n\n        Returns:\n            traj (md.Trajectory): DNA trajectory.\n        \"\"\"\n        if self.circular or not remove_terminal_phosphates:\n            return self.traj\n\n        phosphor_termini = self.traj.top.select(f'name P OP1 OP2 and resid 0 {self.traj.top.chain(0).n_residues}')\n        all_atoms = self.traj.top.select('all')\n        return self.traj.atom_slice([at for at in all_atoms if at not in phosphor_termini])\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator.__init__","title":"<code>__init__(spline=None, sequence=None, circular=False, frames=None)</code>","text":"<p>Initialize the structure generator.</p> <p>Either spline or frames must be provided.  If both are given, frames takes precedence.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>SplineFrames</code> <p>Spline object that provides frames.</p> <code>None</code> <code>sequence</code> <code>str</code> <p>DNA sequence.  When <code>None</code> a random sequence with 50 %% AT content is generated.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Generate circular DNA topology.</p> <code>False</code> <code>frames</code> <code>ndarray</code> <p>Rigid-body frames with shape <code>(n_bp, 4, 3)</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither spline nor frames is provided.</p> Source code in <code>mdna/generators.py</code> <pre><code>def __init__(self, spline=None, sequence=None, circular=False, frames=None):\n    \"\"\"Initialize the structure generator.\n\n    Either *spline* or *frames* must be provided.  If both are given,\n    *frames* takes precedence.\n\n    Args:\n        spline (SplineFrames, optional): Spline object that provides frames.\n        sequence (str, optional): DNA sequence.  When ``None`` a random\n            sequence with 50 %% AT content is generated.\n        circular (bool): Generate circular DNA topology.\n        frames (numpy.ndarray, optional): Rigid-body frames with shape\n            ``(n_bp, 4, 3)``.\n\n    Raises:\n        ValueError: If neither *spline* nor *frames* is provided.\n    \"\"\"\n    self.circular = circular\n    self.sequence = sequence # Should deal with the fact if the sequence length does not match the spline length\n    self.spline = spline\n    if spline is not None:\n        self.frames = spline.frames\n    elif spline is None and frames is not None:\n        self.frames = frames\n    elif spline is not None and frames is not None:\n        self.frames = frames\n        print(\"Both spline and frames are provided, using frames\")\n    else:\n        raise ValueError(\"Either spline or frames must be provided\")\n\n    self.length = self.frames.shape[0] # numer of base pairs \n    self.initialize()\n    self.apply_spline()\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator.apply_spline","title":"<code>apply_spline()</code>","text":"<p>Transform dummy base-pair coordinates to follow the spatial frames.</p> <p>Iterates over every base pair and applies a rotation and translation so that each base pair is positioned and oriented according to the corresponding entry in :attr:<code>frames</code>.</p> Source code in <code>mdna/generators.py</code> <pre><code>def apply_spline(self):\n    \"\"\"Transform dummy base-pair coordinates to follow the spatial frames.\n\n    Iterates over every base pair and applies a rotation and translation\n    so that each base pair is positioned and oriented according to the\n    corresponding entry in :attr:`frames`.\n    \"\"\"\n\n    # Get base pair topology of strands\n    sense = self.traj.top._chains[0]._residues\n    anti = self.traj.top._chains[1]._residues[::-1]\n    basepairs = np.array(list(zip(sense, anti)))\n\n    # Set the dummy coordinates\n    initial_frame = np.array([[0,0,0],[1,0,0],[0,1,0],[0,0,1]])\n\n    # Create a list of initial frames for each base pair\n    basepair_frames = np.array([initial_frame for _ in range(len(basepairs))])  # Shape: (n_basepairs, 4, 3)\n\n    # Add an empty axis to match expected dimensions (n_basepairs, 1, 4, 3)\n    current_frames = basepair_frames[:, np.newaxis, :, :]\n    new_frames = self.frames #spline.frames # has shape (n_basepairs, 4, 3) base pairs, frames\n\n    # Loop over base pairs and apply the transformation to the base pair coordinates\n    for idx,(old,new) in enumerate(zip(current_frames, new_frames)):\n        self.update_basepair_coordinates(old, new, basepairs, idx)\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator.generate_letter_sequence","title":"<code>generate_letter_sequence(at_fraction=0.5)</code>","text":"<p>Generate a random DNA sequence with a specified AT content.</p> <p>Parameters:</p> Name Type Description Default <code>at_fraction</code> <code>float</code> <p>Fraction of A/T bases (0\u20131).</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>sequence</code> <code>str</code> <p>Random DNA sequence of length :attr:<code>length</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If at_fraction is outside [0, 1].</p> Source code in <code>mdna/generators.py</code> <pre><code>def generate_letter_sequence(self, at_fraction=0.5):\n    \"\"\"Generate a random DNA sequence with a specified AT content.\n\n    Args:\n        at_fraction (float): Fraction of A/T bases (0\u20131).\n\n    Returns:\n        sequence (str): Random DNA sequence of length :attr:`length`.\n\n    Raises:\n        ValueError: If *at_fraction* is outside [0, 1].\n    \"\"\"\n    # Ensure at_fraction is within valid bounds\n    if not (0 &lt;= at_fraction &lt;= 1):\n        raise ValueError(\"at_fraction must be between 0 and 1 inclusive\")\n    # Calculate the number of 'A' and 'T' bases based on the given fraction\n    bases = ['A', 'T'] * int(self.length * at_fraction) + ['G', 'C'] * (self.length - int(self.length * at_fraction))\n    return ''.join(random.sample(bases, self.length))\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator.get_basepair_xyz","title":"<code>get_basepair_xyz(basepairs, idx)</code>","text":"<p>Get atom coordinates for a single base pair.</p> <p>Parameters:</p> Name Type Description Default <code>basepairs</code> <code>ndarray</code> <p>Array of <code>(sense_residue, antisense_residue)</code> pairs.</p> required <code>idx</code> <code>int</code> <p>Base-pair index.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>tuple[ndarray, list[int]]</code> <p><code>(xyz, atom_indices)</code>.</p> Source code in <code>mdna/generators.py</code> <pre><code>def get_basepair_xyz(self, basepairs, idx):\n    \"\"\"Get atom coordinates for a single base pair.\n\n    Args:\n        basepairs (numpy.ndarray): Array of ``(sense_residue, antisense_residue)`` pairs.\n        idx (int): Base-pair index.\n\n    Returns:\n        result (tuple[numpy.ndarray, list[int]]): ``(xyz, atom_indices)``.\n    \"\"\"\n    indices = [at.index for at in basepairs[idx][0].atoms] + [at.index for at in basepairs[idx][1].atoms]\n    return self.traj.xyz[:,indices,:], indices\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator.get_traj","title":"<code>get_traj(remove_terminal_phosphates=False)</code>","text":"<p>Return the DNA trajectory, optionally trimming terminal phosphates.</p> <p>Parameters:</p> Name Type Description Default <code>remove_terminal_phosphates</code> <code>bool</code> <p>If True and the structure is linear, remove the 5\u2032 phosphate groups at the termini.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>traj</code> <code>Trajectory</code> <p>DNA trajectory.</p> Source code in <code>mdna/generators.py</code> <pre><code>def get_traj(self, remove_terminal_phosphates: bool = False):\n    \"\"\"Return the DNA trajectory, optionally trimming terminal phosphates.\n\n    Args:\n        remove_terminal_phosphates (bool): If True and the structure is\n            linear, remove the 5\u2032 phosphate groups at the termini.\n\n    Returns:\n        traj (md.Trajectory): DNA trajectory.\n    \"\"\"\n    if self.circular or not remove_terminal_phosphates:\n        return self.traj\n\n    phosphor_termini = self.traj.top.select(f'name P OP1 OP2 and resid 0 {self.traj.top.chain(0).n_residues}')\n    all_atoms = self.traj.top.select('all')\n    return self.traj.atom_slice([at for at in all_atoms if at not in phosphor_termini])\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator.initialize","title":"<code>initialize()</code>","text":"<p>Build the initial trajectory with dummy coordinates.</p> <p>Generates a random sequence if none was provided, then creates the topology and reference coordinates via :class:<code>SequenceGenerator</code>.</p> Source code in <code>mdna/generators.py</code> <pre><code>def initialize(self):\n    \"\"\"Build the initial trajectory with dummy coordinates.\n\n    Generates a random sequence if none was provided, then creates\n    the topology and reference coordinates via :class:`SequenceGenerator`.\n    \"\"\"\n\n    # Generate DNA sequence\n    if self.sequence is None:\n        # Fraction of AT content\n        self.sequence = self.generate_letter_sequence(at_fraction=0.5)\n        print(self.sequence)\n\n    # Generate DNA trajectory and topology with dummy coordinates (aka everything based on standard bases)\n    self.dna = SequenceGenerator(sequence=self.sequence, circular=self.circular)\n    self.traj = self.dna.traj\n</code></pre>"},{"location":"api/generators/#mdna.generators.StructureGenerator.update_basepair_coordinates","title":"<code>update_basepair_coordinates(old, new, basepairs, idx)</code>","text":"<p>Rotate and translate a single base pair to a new frame.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>ndarray</code> <p>Current frame for this base pair, shape <code>(1, 4, 3)</code>.</p> required <code>new</code> <code>ndarray</code> <p>Target frame, shape <code>(4, 3)</code>.</p> required <code>basepairs</code> <code>ndarray</code> <p>Array of <code>(sense_residue, antisense_residue)</code> pairs.</p> required <code>idx</code> <code>int</code> <p>Index of the base pair to update.</p> required Source code in <code>mdna/generators.py</code> <pre><code>def update_basepair_coordinates(self, old, new, basepairs, idx):\n    \"\"\"Rotate and translate a single base pair to a new frame.\n\n    Args:\n        old (numpy.ndarray): Current frame for this base pair, shape ``(1, 4, 3)``.\n        new (numpy.ndarray): Target frame, shape ``(4, 3)``.\n        basepairs (numpy.ndarray): Array of ``(sense_residue, antisense_residue)`` pairs.\n        idx (int): Index of the base pair to update.\n    \"\"\"\n\n    # Get the origin of the old and new frames\n    old_origin = old[0][0]\n    new_origin = new[0]\n\n    # Get basis of the old and new frames\n    old_basis = old[0][1:]\n    new_basis = np.array(new[1:]) # maybe need to flip the basis vectors here to get the right orientation\n\n    # Get the rotation and translation\n    rot = np.linalg.solve(old_basis,new_basis)\n    # rot = np.dot(new_basis,old_basis.T) &lt;-- this is the same as above\n    trans = new_origin - old_origin\n\n    # First collect xyz coordinates of the base pairs\n    xyz, indices = self.get_basepair_xyz(basepairs,idx)\n\n    # Apply the rotation and translation\n    new_xyz = np.dot(xyz,rot) + trans\n\n    # Set the new coordinates\n    self.traj.xyz[:,indices,:] = new_xyz\n</code></pre>"},{"location":"api/geometry/","title":"Geometry Classes","text":"<p>Classes for computing nucleobase reference frames and rigid base parameters.</p>"},{"location":"api/geometry/#reference-base-class","title":"Reference Base Class","text":"<p>Fits a reference frame to a single nucleobase using the Tsukuba convention.</p>"},{"location":"api/geometry/#mdna.geometry.ReferenceBase","title":"<code>mdna.geometry.ReferenceBase</code>","text":"<p>Compute a nucleobase reference frame following the Tsukuba convention.</p> <p>Given an MDTraj trajectory for a single residue, this class identifies the base type (purine, pyrimidine, or non-canonical analogue), locates the key atoms (C1', N-glycosidic nitrogen, and a ring carbon), and calculates the local reference frame vectors (origin b_R, long axis b_L, short axis b_D, and normal b_N).</p> <p>Attributes:</p> Name Type Description <code>traj</code> <code>Trajectory</code> <p>Single-residue trajectory.</p> <code>base_type</code> <code>str</code> <p>One-letter nucleobase code (e.g. <code>'A'</code>, <code>'T'</code>, <code>'D'</code>).</p> <code>b_R</code> <code>ndarray</code> <p>Reference point (origin) of shape <code>(n_frames, 3)</code>.</p> <code>b_L</code> <code>ndarray</code> <p>Long-axis unit vector of shape <code>(n_frames, 3)</code>.</p> <code>b_D</code> <code>ndarray</code> <p>Short-axis unit vector of shape <code>(n_frames, 3)</code>.</p> <code>b_N</code> <code>ndarray</code> <p>Base-normal unit vector of shape <code>(n_frames, 3)</code>.</p> Source code in <code>mdna/geometry.py</code> <pre><code>class ReferenceBase:\n    \"\"\"Compute a nucleobase reference frame following the Tsukuba convention.\n\n    Given an MDTraj trajectory for a single residue, this class identifies the\n    base type (purine, pyrimidine, or non-canonical analogue), locates the key\n    atoms (C1', N-glycosidic nitrogen, and a ring carbon), and calculates the\n    local reference frame vectors (origin *b_R*, long axis *b_L*, short axis\n    *b_D*, and normal *b_N*).\n\n    Attributes:\n        traj (md.Trajectory): Single-residue trajectory.\n        base_type (str): One-letter nucleobase code (e.g. ``'A'``, ``'T'``, ``'D'``).\n        b_R (numpy.ndarray): Reference point (origin) of shape ``(n_frames, 3)``.\n        b_L (numpy.ndarray): Long-axis unit vector of shape ``(n_frames, 3)``.\n        b_D (numpy.ndarray): Short-axis unit vector of shape ``(n_frames, 3)``.\n        b_N (numpy.ndarray): Base-normal unit vector of shape ``(n_frames, 3)``.\n    \"\"\"\n\n    def __init__(self, traj):\n        \"\"\"Initialize the reference base calculation.\n\n        Args:\n            traj (md.Trajectory): MDTraj trajectory containing a single nucleotide residue.\n        \"\"\"\n        self.traj = traj\n        # Determine base type (purine/pyrimidine/other)\n        self.base_type = self.get_base_type()\n        # Define the Tsukuba convention parameters\n        self.tau_1, self.tau_2, self.d = np.radians(141.478), -np.radians(54.418), 0.4702     \n        # Get coordinates of key atoms based on base type\n        self.C1_coords, self.N_coords, self.C_coords = self.get_coordinates()\n        # Calculate base reference point and base vectors\n        self.b_R, self.b_L, self.b_D, self.b_N = self.calculate_base_frame()\n        # self.basis = np.array([self.b_D.T, self.b_L.T, self.b_N])\n\n    def _select_atom_by_name(self, name: str) -&gt; np.ndarray:\n        \"\"\"Select atom coordinates by atom name.\n\n        Args:\n            name (str): Atom selection string (e.g. ``'N9'``, ``'\"C1\\'\"'``).\n\n        Returns:\n            numpy.ndarray: Coordinates of shape ``(n_frames, 3)``.\n        \"\"\"\n        # Select an atom by name returns shape (n_frames, 1, [x,y,z])\n        return np.squeeze(self.traj.xyz[:,[self.traj.topology.select(f'name {name}')[0]],:],axis=1)\n\n    def get_base_type(self) -&gt; str:\n        \"\"\"Determine the nucleobase type from the atoms present in the trajectory.\n\n        Matches the set of non-hydrogen atom names against the known\n        nucleobase dictionaries for canonical and non-canonical bases.\n\n        Raises:\n            ValueError: If no known base type matches the atom set.\n\n        Returns:\n            str: Single-letter nucleobase code (e.g. ``'A'``, ``'G'``, ``'D'``).\n        \"\"\"\n        # Extracts all non-hydrogen atoms from the trajectory topology\n        atoms = {atom.name for atom in self.traj.topology.atoms if atom.element.symbol != 'H'}\n\n        # Check each base in the dictionary to see if all its atoms are present in the extracted atoms set\n        for base, base_atoms in NUCLEOBASE_DICT.items():\n            if all(atom in atoms for atom in base_atoms):\n                return base\n        # If no base matches, raise an error\n        raise ValueError(\"Cannot determine the base type from the PDB file.\")\n\n    def get_coordinates(self) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Retrieve C1', N-glycosidic, and ring-carbon coordinates for the base.\n\n        The specific atoms selected depend on the base type (purine vs\n        pyrimidine vs non-canonical analogue).\n\n        Returns:\n            tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]:\n                ``(C1_coords, N_coords, C_coords)`` each of shape ``(n_frames, 3)``.\n        \"\"\"\n        # Get the coordinates of key atoms based on the base type\n        C1_coords = self._select_atom_by_name('\"C1\\'\"')\n        if self.base_type in ['C','T','U','D']:# \"pyrimidine\"\n            N_coords = self._select_atom_by_name(\"N1\")\n            C_coords = self._select_atom_by_name(\"C2\")\n        elif self.base_type in ['A','G','E','B','P']:# \"purine\":\n            N_coords = self._select_atom_by_name(\"N9\")\n            C_coords = self._select_atom_by_name(\"C4\") \n        elif self.base_type in ['S','Z']: # Hachi pyrimidine analogues\n            N_coords = self._select_atom_by_name(\"C1\")\n            C_coords = self._select_atom_by_name(\"C2\")\n        elif self.base_type in ['L']: # UBPs hydrophobic\n            N_coords = self._select_atom_by_name(\"N1\")\n            C_coords = self._select_atom_by_name(\"C5\")\n        elif self.base_type in ['M']: # UBPs hydrophilic\n            N_coords = self._select_atom_by_name(\"C1\")\n            C_coords = self._select_atom_by_name(\"C6\")\n        else:\n            raise ValueError(f\"Unsupported base type: {self.base_type}\")\n        return C1_coords, N_coords, C_coords\n\n\n    def calculate_base_frame(self) -&gt; np.ndarray:\n        \"\"\"Calculate the base reference frame from the Tsukuba convention.\n\n        Computes the base-normal (*b_N*) from the cross product of key atom\n        vectors, then derives the reference point (*b_R*), long axis (*b_L*),\n        and short axis (*b_D*) by rotating the N\u2192C1' vector.\n\n        Returns:\n            numpy.ndarray: Array of shape ``(4, n_frames, 3)`` containing\n                ``[b_R, b_D, b_L, b_N]``.\n        \"\"\"\n\n        # Calculate normal vector using cross product of vectors formed by key atoms\n        #  The coords have the shape (n,1,3)\n        b_N = np.cross((self.N_coords - self.C1_coords), (self.N_coords-self.C_coords), axis=1)\n        b_N /= np.linalg.norm(b_N, axis=1, keepdims=True)  # Normalize b_N to have unit length\n\n        # Compute displacement vector N-C1' \n        N_C1_vector = self.C1_coords - self.N_coords  # Pointing from N to C1'\n        N_C1_vector /= np.linalg.norm(N_C1_vector, axis=1, keepdims=True)\n\n        # Rotate N-C1' vector by angle tau_1 around b_N to get the direction for displacement\n        R_b_R = RigidBody.get_rotation_matrix(self.tau_1 * b_N)\n\n        # Displace N along this direction by a distance d to get b_R\n        b_R = self.N_coords + np.einsum('ijk,ik-&gt;ij', R_b_R, N_C1_vector * self.d)\n\n        # Take a unit vector in the N-C1' direction, rotate it around b_N by angle tau_2 to get b_L\n        R_b_L = RigidBody.get_rotation_matrix(self.tau_2 * b_N)\n        b_L = np.einsum('ijk,ik-&gt;ij', R_b_L, N_C1_vector) \n\n        # Calculate b_D using cross product of b_L and b_N\n        b_D = np.cross(b_L, b_N, axis=1)\n\n        return np.array([b_R, b_D, b_L, b_N])\n        #return np.array([b_R, -b_D, -b_L, -b_N])\n\n    def plot_baseframe(self, atoms=True, frame=True, ax=None, length=1):\n        \"\"\"Plot the nucleobase atoms and/or reference frame vectors in 3D.\n\n        Args:\n            atoms (bool): If True, scatter-plot the atom positions. Defaults to True.\n            frame (bool): If True, draw quiver arrows for the *b_L*, *b_D*, and *b_N* vectors. Defaults to True.\n            ax (matplotlib.axes.Axes, optional): Existing 3D axes to draw on. If None, a new figure is created.\n            length (int): Length scale for the quiver arrows. Defaults to 1.\n        \"\"\"\n        if ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n        else:\n            fig = False\n\n        # Plot the DNA atoms\n        if atoms:\n            atoms_coords = self.traj.xyz[0]\n            ax.scatter(atoms_coords[:,0], atoms_coords[:,1], atoms_coords[:,2], alpha=0.6)\n\n        # Plot the reference frame vectors\n        if frame:\n            origin = self.b_R[0]\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_L[0][0], self.b_L[0][1], self.b_L[0][2], \n                    color='r', length=length, normalize=True)\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_D[0][0], self.b_D[0][1], self.b_D[0][2], \n                    color='g', length=length, normalize=True)\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_N[0][0], self.b_N[0][1], self.b_N[0][2], \n                    color='b', length=length, normalize=True)\n\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n\n        if fig: \n            # Make axes of equal length\n            max_range = np.array([\n                atoms_coords[:,0].max()-atoms_coords[:,0].min(), \n                atoms_coords[:,1].max()-atoms_coords[:,1].min(), \n                atoms_coords[:,2].max()-atoms_coords[:,2].min()\n            ]).max() / 2.0\n\n            mid_x = (atoms_coords[:,0].max()+atoms_coords[:,0].min()) * 0.5\n            mid_y = (atoms_coords[:,1].max()+atoms_coords[:,1].min()) * 0.5\n            mid_z = (atoms_coords[:,2].max()+atoms_coords[:,2].min()) * 0.5\n            ax.set_xlim(mid_x - max_range, mid_x + max_range)\n            ax.set_ylim(mid_y - max_range, mid_y + max_range)\n            ax.set_zlim(mid_z - max_range, mid_z + max_range)\n\n        ax.axis('equal')\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.ReferenceBase.__init__","title":"<code>__init__(traj)</code>","text":"<p>Initialize the reference base calculation.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Trajectory</code> <p>MDTraj trajectory containing a single nucleotide residue.</p> required Source code in <code>mdna/geometry.py</code> <pre><code>def __init__(self, traj):\n    \"\"\"Initialize the reference base calculation.\n\n    Args:\n        traj (md.Trajectory): MDTraj trajectory containing a single nucleotide residue.\n    \"\"\"\n    self.traj = traj\n    # Determine base type (purine/pyrimidine/other)\n    self.base_type = self.get_base_type()\n    # Define the Tsukuba convention parameters\n    self.tau_1, self.tau_2, self.d = np.radians(141.478), -np.radians(54.418), 0.4702     \n    # Get coordinates of key atoms based on base type\n    self.C1_coords, self.N_coords, self.C_coords = self.get_coordinates()\n    # Calculate base reference point and base vectors\n    self.b_R, self.b_L, self.b_D, self.b_N = self.calculate_base_frame()\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.ReferenceBase.calculate_base_frame","title":"<code>calculate_base_frame()</code>","text":"<p>Calculate the base reference frame from the Tsukuba convention.</p> <p>Computes the base-normal (b_N) from the cross product of key atom vectors, then derives the reference point (b_R), long axis (b_L), and short axis (b_D) by rotating the N\u2192C1' vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Array of shape <code>(4, n_frames, 3)</code> containing <code>[b_R, b_D, b_L, b_N]</code>.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def calculate_base_frame(self) -&gt; np.ndarray:\n    \"\"\"Calculate the base reference frame from the Tsukuba convention.\n\n    Computes the base-normal (*b_N*) from the cross product of key atom\n    vectors, then derives the reference point (*b_R*), long axis (*b_L*),\n    and short axis (*b_D*) by rotating the N\u2192C1' vector.\n\n    Returns:\n        numpy.ndarray: Array of shape ``(4, n_frames, 3)`` containing\n            ``[b_R, b_D, b_L, b_N]``.\n    \"\"\"\n\n    # Calculate normal vector using cross product of vectors formed by key atoms\n    #  The coords have the shape (n,1,3)\n    b_N = np.cross((self.N_coords - self.C1_coords), (self.N_coords-self.C_coords), axis=1)\n    b_N /= np.linalg.norm(b_N, axis=1, keepdims=True)  # Normalize b_N to have unit length\n\n    # Compute displacement vector N-C1' \n    N_C1_vector = self.C1_coords - self.N_coords  # Pointing from N to C1'\n    N_C1_vector /= np.linalg.norm(N_C1_vector, axis=1, keepdims=True)\n\n    # Rotate N-C1' vector by angle tau_1 around b_N to get the direction for displacement\n    R_b_R = RigidBody.get_rotation_matrix(self.tau_1 * b_N)\n\n    # Displace N along this direction by a distance d to get b_R\n    b_R = self.N_coords + np.einsum('ijk,ik-&gt;ij', R_b_R, N_C1_vector * self.d)\n\n    # Take a unit vector in the N-C1' direction, rotate it around b_N by angle tau_2 to get b_L\n    R_b_L = RigidBody.get_rotation_matrix(self.tau_2 * b_N)\n    b_L = np.einsum('ijk,ik-&gt;ij', R_b_L, N_C1_vector) \n\n    # Calculate b_D using cross product of b_L and b_N\n    b_D = np.cross(b_L, b_N, axis=1)\n\n    return np.array([b_R, b_D, b_L, b_N])\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.ReferenceBase.get_base_type","title":"<code>get_base_type()</code>","text":"<p>Determine the nucleobase type from the atoms present in the trajectory.</p> <p>Matches the set of non-hydrogen atom names against the known nucleobase dictionaries for canonical and non-canonical bases.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no known base type matches the atom set.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Single-letter nucleobase code (e.g. <code>'A'</code>, <code>'G'</code>, <code>'D'</code>).</p> Source code in <code>mdna/geometry.py</code> <pre><code>def get_base_type(self) -&gt; str:\n    \"\"\"Determine the nucleobase type from the atoms present in the trajectory.\n\n    Matches the set of non-hydrogen atom names against the known\n    nucleobase dictionaries for canonical and non-canonical bases.\n\n    Raises:\n        ValueError: If no known base type matches the atom set.\n\n    Returns:\n        str: Single-letter nucleobase code (e.g. ``'A'``, ``'G'``, ``'D'``).\n    \"\"\"\n    # Extracts all non-hydrogen atoms from the trajectory topology\n    atoms = {atom.name for atom in self.traj.topology.atoms if atom.element.symbol != 'H'}\n\n    # Check each base in the dictionary to see if all its atoms are present in the extracted atoms set\n    for base, base_atoms in NUCLEOBASE_DICT.items():\n        if all(atom in atoms for atom in base_atoms):\n            return base\n    # If no base matches, raise an error\n    raise ValueError(\"Cannot determine the base type from the PDB file.\")\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.ReferenceBase.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Retrieve C1', N-glycosidic, and ring-carbon coordinates for the base.</p> <p>The specific atoms selected depend on the base type (purine vs pyrimidine vs non-canonical analogue).</p> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray, ndarray]</code> <p>tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]: <code>(C1_coords, N_coords, C_coords)</code> each of shape <code>(n_frames, 3)</code>.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def get_coordinates(self) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Retrieve C1', N-glycosidic, and ring-carbon coordinates for the base.\n\n    The specific atoms selected depend on the base type (purine vs\n    pyrimidine vs non-canonical analogue).\n\n    Returns:\n        tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]:\n            ``(C1_coords, N_coords, C_coords)`` each of shape ``(n_frames, 3)``.\n    \"\"\"\n    # Get the coordinates of key atoms based on the base type\n    C1_coords = self._select_atom_by_name('\"C1\\'\"')\n    if self.base_type in ['C','T','U','D']:# \"pyrimidine\"\n        N_coords = self._select_atom_by_name(\"N1\")\n        C_coords = self._select_atom_by_name(\"C2\")\n    elif self.base_type in ['A','G','E','B','P']:# \"purine\":\n        N_coords = self._select_atom_by_name(\"N9\")\n        C_coords = self._select_atom_by_name(\"C4\") \n    elif self.base_type in ['S','Z']: # Hachi pyrimidine analogues\n        N_coords = self._select_atom_by_name(\"C1\")\n        C_coords = self._select_atom_by_name(\"C2\")\n    elif self.base_type in ['L']: # UBPs hydrophobic\n        N_coords = self._select_atom_by_name(\"N1\")\n        C_coords = self._select_atom_by_name(\"C5\")\n    elif self.base_type in ['M']: # UBPs hydrophilic\n        N_coords = self._select_atom_by_name(\"C1\")\n        C_coords = self._select_atom_by_name(\"C6\")\n    else:\n        raise ValueError(f\"Unsupported base type: {self.base_type}\")\n    return C1_coords, N_coords, C_coords\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.ReferenceBase.plot_baseframe","title":"<code>plot_baseframe(atoms=True, frame=True, ax=None, length=1)</code>","text":"<p>Plot the nucleobase atoms and/or reference frame vectors in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>bool</code> <p>If True, scatter-plot the atom positions. Defaults to True.</p> <code>True</code> <code>frame</code> <code>bool</code> <p>If True, draw quiver arrows for the b_L, b_D, and b_N vectors. Defaults to True.</p> <code>True</code> <code>ax</code> <code>Axes</code> <p>Existing 3D axes to draw on. If None, a new figure is created.</p> <code>None</code> <code>length</code> <code>int</code> <p>Length scale for the quiver arrows. Defaults to 1.</p> <code>1</code> Source code in <code>mdna/geometry.py</code> <pre><code>def plot_baseframe(self, atoms=True, frame=True, ax=None, length=1):\n    \"\"\"Plot the nucleobase atoms and/or reference frame vectors in 3D.\n\n    Args:\n        atoms (bool): If True, scatter-plot the atom positions. Defaults to True.\n        frame (bool): If True, draw quiver arrows for the *b_L*, *b_D*, and *b_N* vectors. Defaults to True.\n        ax (matplotlib.axes.Axes, optional): Existing 3D axes to draw on. If None, a new figure is created.\n        length (int): Length scale for the quiver arrows. Defaults to 1.\n    \"\"\"\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n    else:\n        fig = False\n\n    # Plot the DNA atoms\n    if atoms:\n        atoms_coords = self.traj.xyz[0]\n        ax.scatter(atoms_coords[:,0], atoms_coords[:,1], atoms_coords[:,2], alpha=0.6)\n\n    # Plot the reference frame vectors\n    if frame:\n        origin = self.b_R[0]\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_L[0][0], self.b_L[0][1], self.b_L[0][2], \n                color='r', length=length, normalize=True)\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_D[0][0], self.b_D[0][1], self.b_D[0][2], \n                color='g', length=length, normalize=True)\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_N[0][0], self.b_N[0][1], self.b_N[0][2], \n                color='b', length=length, normalize=True)\n\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n\n    if fig: \n        # Make axes of equal length\n        max_range = np.array([\n            atoms_coords[:,0].max()-atoms_coords[:,0].min(), \n            atoms_coords[:,1].max()-atoms_coords[:,1].min(), \n            atoms_coords[:,2].max()-atoms_coords[:,2].min()\n        ]).max() / 2.0\n\n        mid_x = (atoms_coords[:,0].max()+atoms_coords[:,0].min()) * 0.5\n        mid_y = (atoms_coords[:,1].max()+atoms_coords[:,1].min()) * 0.5\n        mid_z = (atoms_coords[:,2].max()+atoms_coords[:,2].min()) * 0.5\n        ax.set_xlim(mid_x - max_range, mid_x + max_range)\n        ax.set_ylim(mid_y - max_range, mid_y + max_range)\n        ax.set_zlim(mid_z - max_range, mid_z + max_range)\n\n    ax.axis('equal')\n</code></pre>"},{"location":"api/geometry/#rigid-base-parameter-class","title":"Rigid Base Parameter Class","text":"<p>Computes inter- and intra-base pair parameters from an MDTraj trajectory.</p>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames","title":"<code>mdna.geometry.NucleicFrames</code>","text":"<p>Rigid base-pair parameter computation from DNA trajectories.</p> <p>Extracts nucleobase reference frames from an MDTraj trajectory using the Tsukuba convention, then computes the six intra-base-pair parameters (shear, stretch, stagger, buckle, propeller, opening) and six inter-base-pair step parameters (shift, slide, rise, tilt, roll, twist) for every frame in the trajectory.</p> <p>The mean base-pair reference frames are also stored and can be used as input for downstream construction or analysis.</p> <p>Attributes:</p> Name Type Description <code>traj</code> <code>Trajectory</code> <p>Input trajectory.</p> <code>frames</code> <code>ndarray</code> <p>Mean reference frames of shape <code>(n_bp, n_frames, 4, 3)</code>.</p> <code>parameters</code> <code>ndarray</code> <p>Combined base-pair and step parameters of shape <code>(n_bp, n_frames, 12)</code>.</p> <code>bp_params</code> <code>ndarray</code> <p>Intra-base-pair parameters of shape <code>(n_bp, n_frames, 6)</code>.</p> <code>step_params</code> <code>ndarray</code> <p>Inter-base-pair step parameters of shape <code>(n_bp, n_frames, 6)</code>.</p> <code>names</code> <code>list[str]</code> <p>Parameter names (base + step).</p> Example <pre><code>import mdtraj as md\nimport mdna\n\ntraj = md.load('dna_trajectory.xtc', top='dna.pdb')\ndna = mdna.NucleicFrames(traj)\nparams, names = dna.get_parameters()\n# params.shape \u2192 (n_frames, n_bp, 12)\n</code></pre> Source code in <code>mdna/geometry.py</code> <pre><code>class NucleicFrames:\n    \"\"\"Rigid base-pair parameter computation from DNA trajectories.\n\n    Extracts nucleobase reference frames from an MDTraj trajectory using the\n    Tsukuba convention, then computes the six intra-base-pair parameters\n    (shear, stretch, stagger, buckle, propeller, opening) and six inter-base-pair\n    step parameters (shift, slide, rise, tilt, roll, twist) for every frame in\n    the trajectory.\n\n    The mean base-pair reference frames are also stored and can be used as input\n    for downstream construction or analysis.\n\n    Attributes:\n        traj (md.Trajectory): Input trajectory.\n        frames (numpy.ndarray): Mean reference frames of shape ``(n_bp, n_frames, 4, 3)``.\n        parameters (numpy.ndarray): Combined base-pair and step parameters of shape\n            ``(n_bp, n_frames, 12)``.\n        bp_params (numpy.ndarray): Intra-base-pair parameters of shape ``(n_bp, n_frames, 6)``.\n        step_params (numpy.ndarray): Inter-base-pair step parameters of shape ``(n_bp, n_frames, 6)``.\n        names (list[str]): Parameter names (base + step).\n\n    Example:\n        ```python\n        import mdtraj as md\n        import mdna\n\n        traj = md.load('dna_trajectory.xtc', top='dna.pdb')\n        dna = mdna.NucleicFrames(traj)\n        params, names = dna.get_parameters()\n        # params.shape \u2192 (n_frames, n_bp, 12)\n        ```\n    \"\"\"\n\n    def __init__(self, traj, chainids=[0,1], fit_reference=False):\n        \"\"\"Initialize the NucleicFrames object.\n\n        Args:\n            traj (object): MDtraj trajectory object.\n            chainids (list, optional): Chainids of sense- and anti-sense strands. Defaults to [0,1].\n            fit_reference (bool, optional): Fit each base to canonical reference bases before frame extraction.\n                Defaults to False.\n        \"\"\"\n        self.traj = traj\n        self.top = traj.topology\n        self.fit_reference = fit_reference\n        self.reference_base_map = {'U': 'T'}\n        self.reference_fit_data = self._prepare_reference_fit_data() if self.fit_reference else {}\n        self.res_A = self.get_residues(chain_index=chainids[0], reverse=False)\n        self.res_B = self.get_residues(chain_index=chainids[1], reverse=True)\n        self.mean_reference_frames = np.empty((len(self.res_A), 1, 4, 3))\n        self.base_frames = self.get_base_reference_frames()\n        self.analyse_frames()\n\n    def get_residues(self, chain_index, reverse=False):\n        \"\"\"Get residues from a specified chain.\n\n        Args:\n            chain_index (int): Index of the chain in the topology.\n            reverse (bool): If True, return residues in reverse order (used for the anti-sense strand).\n\n        Returns:\n            residues (list): MDTraj Residue objects.\n\n        Raises:\n            IndexError: If *chain_index* is out of range.\n        \"\"\"\n        if chain_index &gt;= len(self.top._chains):\n            raise IndexError(\"Chain index out of range.\")\n        chain = self.top._chains[chain_index]\n        residues = chain._residues\n        return list(reversed(residues)) if reverse else residues\n\n    def load_reference_bases(self):\n        \"\"\"Load canonical reference base structures from bundled HDF5 files.\n\n        Returns:\n            bases (dict[str, md.Trajectory]): Mapping of base letter (A, C, G, T) to single-frame trajectory.\n        \"\"\"\n        bases = ['C', 'G', 'T', 'A']\n        return {base: md.load_hdf5(get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in bases}\n\n    def _prepare_reference_fit_data(self):\n        \"\"\"Prepare canonical base atom coordinates and frames for optional fitting.\"\"\"\n        reference_fit_data = {}\n        for base, base_traj in self.load_reference_bases().items():\n            ref_base = ReferenceBase(base_traj)\n            atom_coords = {\n                atom.name: base_traj.xyz[0, atom.index, :]\n                for atom in base_traj.topology.atoms\n                if atom.element.symbol != 'H'\n            }\n            reference_fit_data[base] = {\n                'atom_coords': atom_coords,\n                'frame': np.array([ref_base.b_R[0], ref_base.b_L[0], ref_base.b_D[0], ref_base.b_N[0]])\n            }\n        return reference_fit_data\n\n    def _get_fitted_base_vectors(self, res, ref_base, default_vectors):\n        \"\"\"Fit residue atoms to canonical reference and transform canonical frame.\"\"\"\n        reference_key = self.reference_base_map.get(ref_base.base_type, ref_base.base_type)\n        reference_data = self.reference_fit_data.get(reference_key)\n        if reference_data is None:\n            return default_vectors\n\n        residue_atom_indices = {\n            atom.name: atom.index\n            for atom in res.topology.atoms\n            if atom.element.symbol != 'H'\n        }\n\n        candidate_atoms = NUCLEOBASE_DICT.get(ref_base.base_type, [])\n        common_atoms = [\n            atom_name for atom_name in candidate_atoms\n            if atom_name in residue_atom_indices and atom_name in reference_data['atom_coords']\n        ]\n        if len(common_atoms) &lt; 3:\n            return default_vectors\n\n        reference_coords = np.array([reference_data['atom_coords'][atom_name] for atom_name in common_atoms])\n        residue_coords = res.xyz[:, [residue_atom_indices[atom_name] for atom_name in common_atoms], :]\n\n        reference_frame = reference_data['frame']\n        reference_center = reference_coords.mean(axis=0)\n        reference_centered = reference_coords - reference_center\n\n        fitted_vectors = np.empty_like(default_vectors)\n        for frame_index in range(residue_coords.shape[0]):\n            frame_coords = residue_coords[frame_index]\n            frame_center = frame_coords.mean(axis=0)\n            frame_centered = frame_coords - frame_center\n            try:\n                rotation, _ = R.align_vectors(frame_centered, reference_centered)\n            except ValueError:\n                return default_vectors\n\n            fitted_vectors[frame_index, 0] = rotation.apply(reference_frame[0] - reference_center) + frame_center\n            fitted_vectors[frame_index, 1:] = rotation.apply(reference_frame[1:])\n\n        return fitted_vectors\n\n    def get_base_vectors(self, res):\n        \"\"\"Compute base reference vectors for a single residue.\n\n        Args:\n            res (md.Trajectory): Single-residue trajectory slice.\n\n        Returns:\n            vectors (numpy.ndarray): Base vectors of shape ``(n_frames, 4, 3)``\n                ordered as ``[b_R, b_L, b_D, b_N]``.\n        \"\"\"\n        ref_base = ReferenceBase(res)\n        base_vectors = np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n        if not self.fit_reference:\n            return base_vectors\n        return self._get_fitted_base_vectors(res, ref_base, base_vectors)\n\n    def get_base_reference_frames(self):\n        \"\"\"Compute reference frames for all residues in both strands.\n\n        Returns:\n            frames (dict): Mapping of MDTraj Residue to base vectors array of shape ``(n_frames, 4, 3)``.\n        \"\"\"\n        reference_frames = {} # Dictionary to store the base vectors for each residue\n        for res in self.res_A + self.res_B:\n            res_traj = self.traj.atom_slice([at.index for at in res.atoms])\n            base_vectors = self.get_base_vectors(res_traj)\n            reference_frames[res] = base_vectors # Store the base vectors for the residue index (with shape (4, n_frames, 3))\n        return reference_frames\n\n    def reshape_input(self,input_A,input_B,is_step=False):\n\n        \"\"\"Reshape the input to the correct format for the calculations.\n\n        Args:\n        input_A (ndarray): Input array for the first triad.\n        input_B (ndarray): Input array for the second triad.\n        is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n        Returns:\n        rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n        rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n        origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n        origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n        original_shape (tuple): The original shape of the input.\n        \"\"\"\n\n        # Store original shape\n        original_shape = input_A.shape\n\n        # Flatten frames to compute rotation matrices for each time step simultaneously\n        input_A_ = input_A.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n        input_B_ = input_B.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n\n        # Extract the triads without origin (rotation matrices)\n        rotation_A = input_A_[:,1:]  # shape (n, 3, 3)\n        rotation_B = input_B_[:,1:]  # shape (n, 3, 3)\n\n        if not is_step:\n            # flip (connecting the backbones) and the (baseplane normals).\n            # so the second and third vector b_L, b_N\n            rotation_B[:,[1,2]] *= -1\n\n        # Extract origins of triads\n        origin_A = input_A_[:,0]  # shape (n, 3)\n        origin_B = input_B_[:,0]  # shape (n, 3)\n\n        return rotation_A, rotation_B, origin_A, origin_B, original_shape\n\n\n    def compute_parameters(self, rotation_A, rotation_B, origin_A, origin_B):\n        \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n        Args:\n            rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n            rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n            origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n            origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n\n        Returns:\n            rigid_parameters (ndarray): The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.\n            trans_mid (ndarray): The mean translational vector of shape (n, 3) between the triads.\n            rotation_mid (ndarray): The mean rotation matrix of shape (n, 3, 3) between the triads.\n        \"\"\"\n\n        # Linear interpolation of translations\n        trans_mid = 0.5 * (origin_A + origin_B)\n\n        # Relative translation\n        trans_AB = origin_A - origin_B\n\n        # Get relative rotation matrix of base pair\n        rotation_BA = rotation_B.transpose(0,2,1) @ rotation_A  # returns shape (n, 3, 3)\n\n        # Get rotation angles based on  rotation matrices\n        rotation_angle_BA = RigidBody.extract_omega_values(rotation_BA)\n\n        # Compute halfway rotation matrix and triad (mid frame)\n        rotation_halfway = RigidBody.get_rotation_matrix(rotation_angle_BA * 0.5)\n\n        # Get rotation matrix of base pair (aka mean rotation frame)\n        rotation_mid = rotation_B @ rotation_halfway \n\n        # Get transaltional coordinate vector and convert to angstroms\n        translational_parameters = np.einsum('ijk,ik-&gt;ij',rotation_mid.transpose(0,2,1), trans_AB) * 10\n\n        # Get rotational parameters and convert to degrees\n        rotational_parameters = np.rad2deg(np.einsum('ijk,ik-&gt;ij', rotation_BA.transpose(0,2,1), rotation_angle_BA))\n\n        # Merge translational and rotational parameters\n        rigid_parameters = np.hstack((translational_parameters, rotational_parameters))\n\n        # Return the parameters and the mean reference frame\n        return rigid_parameters, trans_mid, rotation_mid\n\n\n    def calculate_parameters(self,frames_A, frames_B, is_step=False):\n        \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n        Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads.\n        The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame.\n        With the order of the vectors being: b_R, b_L, b_D, b_N.\n\n        Args:\n            frames_A (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain A.\n            frames_B (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain B.\n            is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n        Notes:\n            Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.\n\n        Returns:\n            params (ndarray): The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.\n            mean_reference_frames (ndarray): The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.\n        \"\"\"\n\n        # Reshape frames\n        rotation_A, rotation_B, origin_A, origin_B, original_shape = self.reshape_input(frames_A,frames_B, is_step=is_step)\n\n        # Compute parameters\n        if not is_step:\n            # Flip from row to column representation of the rotation matrices\n            rotation_A = rotation_A.transpose(0,2,1)\n            rotation_B = rotation_B.transpose(0,2,1)\n            params, mean_origin, mean_rotation = self.compute_parameters(rotation_A, rotation_B, origin_A, origin_B)\n        else:\n            # Switch the input of the B and A triads to get the correct parameters\n            params, mean_origin, mean_rotation = self.compute_parameters(rotation_B, rotation_A, origin_B, origin_A)\n\n        # Reshape the parameters to the original shape\n        params = params.reshape(original_shape[0], original_shape[1], 6).swapaxes(0, 1)\n\n        # Collect mean reference frames from mid frames of each base pair\n        mean_reference_frames = np.hstack((mean_origin[:, np.newaxis, :],mean_rotation)).reshape(original_shape)\n\n        if is_step:\n            # Creating an array of zeros with shape (10000, 1, 6)\n            extra_column = np.zeros((params.shape[0], 1, 6))\n\n            # Concatenating the existing array and the extra column along the second axis\n            params = np.concatenate((extra_column,params), axis=1)\n\n        # Return the parameters and the mean reference frames\n        return  params, mean_reference_frames if not is_step else params\n\n\n    def analyse_frames(self):\n        \"\"\"Compute base-pair and step parameters from the extracted reference frames.\n\n        Populates ``bp_params``, ``step_params``, ``parameters``, ``frames``,\n        and ``names`` attributes.\n        \"\"\"\n\n        # Get base reference frames for each residue\n        frames_A = np.array([self.base_frames[res] for res in self.res_A])\n        frames_B = np.array([self.base_frames[res] for res in self.res_B])\n\n        # Compute parameters between each base pair and mean reference frames\n        self.bp_params, self.mean_reference_frames = self.calculate_parameters(frames_A, frames_B)\n\n        # Extract mean reference frames for each neighboring base pair\n        B1_triads = self.mean_reference_frames[:-1] # select all but the last frame\n        B2_triads = self.mean_reference_frames[1:] # select all but the first frame\n\n        # Compute parameters between each base pair and mean reference frames\n        self.step_params = self.calculate_parameters(B1_triads, B2_triads, is_step=True)[0]\n\n        # Store mean reference frame / aka base pair triads as frames and transpose rotation matrices back to row wise\n        self.frames = self.mean_reference_frames\n        self.frames[:, :, 1:, :] = np.transpose(self.frames[:, :, 1:, :], axes=(0, 1, 3, 2))\n        self._clean_parameters()\n\n    def _clean_parameters(self):\n        \"\"\"Assign parameter names and merge base-pair and step arrays.\"\"\"\n        self.step_parameter_names = ['shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n        self.base_parameter_names = ['shear', 'stretch', 'stagger', 'buckle', 'propeller', 'opening']\n        self.names = self.base_parameter_names + self.step_parameter_names\n        self.parameters = np.dstack((self.bp_params, self.step_params))\n\n    def get_parameters(self, step=False, base=False):\n        \"\"\"Return computed rigid base parameters.\n\n        Args:\n            step (bool): If True, return only step parameters.\n            base (bool): If True, return only base-pair parameters.\n\n        Returns:\n            result (tuple[numpy.ndarray, list[str]]): Parameters of shape\n                ``(n_frames, n_bp, n_params)`` and corresponding names.\n\n        Raises:\n            ValueError: If both *step* and *base* are True.\n        \"\"\"\n        if step and not base:\n            return self.step_params, self.step_parameter_names\n        elif base and not step:\n            return self.bp_params, self.base_parameter_names\n        elif not step and not base:\n            return self.parameters, self.names\n        raise ValueError(\"Use only one of step=True or base=True, or neither.\")\n\n    def get_parameter(self, name='twist') -&gt; np.ndarray:\n        \"\"\"Get a single named parameter across all frames.\n\n        Args:\n            name (str): Parameter name. One of: shear, stretch, stagger, buckle,\n                propeller, opening, shift, slide, rise, tilt, roll, twist.\n\n        Returns:\n            numpy.ndarray: Parameter values of shape ``(n_frames, n_bp)``.\n\n        Raises:\n            ValueError: If the parameter name is not recognised.\n        \"\"\"\n\n        if name not in self.names:\n            raise ValueError(f\"Parameter {name} not found.\")\n        return self.parameters[:,:,self.names.index(name)]\n\n\n    def plot_parameters(self, fig=None, ax=None, mean=True, std=True, figsize=[10, 3.5], save=False, step=True, base=True, base_color='cornflowerblue', step_color='coral'):\n        \"\"\"Plot the rigid base parameters of the DNA structure.\n\n        Args:\n            fig (matplotlib.figure.Figure, optional): Existing figure.\n            ax (numpy.ndarray, optional): Array of axes to plot on.\n            mean (bool): Plot the mean line.\n            std (bool): Plot the standard deviation band.\n            figsize (list): Figure size ``[width, height]``.\n            save (bool): If True, save the figure to ``parameters.png``.\n            step (bool): Include step parameters.\n            base (bool): Include base-pair parameters.\n            base_color (str): Color for base-pair parameter plots.\n            step_color (str): Color for step parameter plots.\n\n        Returns:\n            result (tuple): ``(fig, ax)`` matplotlib figure and axes array.\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n\n        cols = step + base\n\n        if fig is None and ax is None:\n            fig,ax = plt.subplots(cols,6, figsize=[12,2*cols])\n            ax = ax.flatten()\n        if step and not base:\n            names = self.step_parameter_names\n        elif base and not step:\n            names = self.base_parameter_names\n        elif base and step:\n            names = self.names\n\n        for _,name in enumerate(names):\n            if name in self.step_parameter_names:\n                color = step_color\n            else:\n                color = base_color\n            para = self.get_parameter(name)\n            mean = np.mean(para, axis=0)\n            std = np.std(para, axis=0)\n            x = range(len(mean))\n            #ax[_].errorbar(x,mean, yerr=std, fmt='-', color=color)\n            ax[_].fill_between(x, mean-std, mean+std, color=color, alpha=0.2)\n            ax[_].plot(mean, color=color,lw=1)    \n            ax[_].scatter(x=x,y=mean,color=color,s=10)\n            ax[_].set_title(name)\n\n        fig.tight_layout()\n        if save:\n            fig.savefig('parameters.png')\n        return fig, ax \n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.__init__","title":"<code>__init__(traj, chainids=[0, 1], fit_reference=False)</code>","text":"<p>Initialize the NucleicFrames object.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory object.</p> required <code>chainids</code> <code>list</code> <p>Chainids of sense- and anti-sense strands. Defaults to [0,1].</p> <code>[0, 1]</code> <code>fit_reference</code> <code>bool</code> <p>Fit each base to canonical reference bases before frame extraction. Defaults to False.</p> <code>False</code> Source code in <code>mdna/geometry.py</code> <pre><code>def __init__(self, traj, chainids=[0,1], fit_reference=False):\n    \"\"\"Initialize the NucleicFrames object.\n\n    Args:\n        traj (object): MDtraj trajectory object.\n        chainids (list, optional): Chainids of sense- and anti-sense strands. Defaults to [0,1].\n        fit_reference (bool, optional): Fit each base to canonical reference bases before frame extraction.\n            Defaults to False.\n    \"\"\"\n    self.traj = traj\n    self.top = traj.topology\n    self.fit_reference = fit_reference\n    self.reference_base_map = {'U': 'T'}\n    self.reference_fit_data = self._prepare_reference_fit_data() if self.fit_reference else {}\n    self.res_A = self.get_residues(chain_index=chainids[0], reverse=False)\n    self.res_B = self.get_residues(chain_index=chainids[1], reverse=True)\n    self.mean_reference_frames = np.empty((len(self.res_A), 1, 4, 3))\n    self.base_frames = self.get_base_reference_frames()\n    self.analyse_frames()\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.analyse_frames","title":"<code>analyse_frames()</code>","text":"<p>Compute base-pair and step parameters from the extracted reference frames.</p> <p>Populates <code>bp_params</code>, <code>step_params</code>, <code>parameters</code>, <code>frames</code>, and <code>names</code> attributes.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def analyse_frames(self):\n    \"\"\"Compute base-pair and step parameters from the extracted reference frames.\n\n    Populates ``bp_params``, ``step_params``, ``parameters``, ``frames``,\n    and ``names`` attributes.\n    \"\"\"\n\n    # Get base reference frames for each residue\n    frames_A = np.array([self.base_frames[res] for res in self.res_A])\n    frames_B = np.array([self.base_frames[res] for res in self.res_B])\n\n    # Compute parameters between each base pair and mean reference frames\n    self.bp_params, self.mean_reference_frames = self.calculate_parameters(frames_A, frames_B)\n\n    # Extract mean reference frames for each neighboring base pair\n    B1_triads = self.mean_reference_frames[:-1] # select all but the last frame\n    B2_triads = self.mean_reference_frames[1:] # select all but the first frame\n\n    # Compute parameters between each base pair and mean reference frames\n    self.step_params = self.calculate_parameters(B1_triads, B2_triads, is_step=True)[0]\n\n    # Store mean reference frame / aka base pair triads as frames and transpose rotation matrices back to row wise\n    self.frames = self.mean_reference_frames\n    self.frames[:, :, 1:, :] = np.transpose(self.frames[:, :, 1:, :], axes=(0, 1, 3, 2))\n    self._clean_parameters()\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.calculate_parameters","title":"<code>calculate_parameters(frames_A, frames_B, is_step=False)</code>","text":"<p>Calculate the parameters between each base pair and mean reference frames.</p> <p>Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads. The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame. With the order of the vectors being: b_R, b_L, b_D, b_N.</p> <p>Parameters:</p> Name Type Description Default <code>frames_A</code> <code>ndarray</code> <p>Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain A.</p> required <code>frames_B</code> <code>ndarray</code> <p>Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain B.</p> required <code>is_step</code> <code>bool</code> <p>Flag indicating if the input is a single step or a trajectory. Defaults to False.</p> <code>False</code> Notes <p>Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.</p> <p>Returns:</p> Name Type Description <code>params</code> <code>ndarray</code> <p>The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.</p> <code>mean_reference_frames</code> <code>ndarray</code> <p>The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def calculate_parameters(self,frames_A, frames_B, is_step=False):\n    \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n    Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads.\n    The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame.\n    With the order of the vectors being: b_R, b_L, b_D, b_N.\n\n    Args:\n        frames_A (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain A.\n        frames_B (ndarray): Frames of shape (n_frames, n_residues, 4, 3) representing the base triads for chain B.\n        is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n    Notes:\n        Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.\n\n    Returns:\n        params (ndarray): The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.\n        mean_reference_frames (ndarray): The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.\n    \"\"\"\n\n    # Reshape frames\n    rotation_A, rotation_B, origin_A, origin_B, original_shape = self.reshape_input(frames_A,frames_B, is_step=is_step)\n\n    # Compute parameters\n    if not is_step:\n        # Flip from row to column representation of the rotation matrices\n        rotation_A = rotation_A.transpose(0,2,1)\n        rotation_B = rotation_B.transpose(0,2,1)\n        params, mean_origin, mean_rotation = self.compute_parameters(rotation_A, rotation_B, origin_A, origin_B)\n    else:\n        # Switch the input of the B and A triads to get the correct parameters\n        params, mean_origin, mean_rotation = self.compute_parameters(rotation_B, rotation_A, origin_B, origin_A)\n\n    # Reshape the parameters to the original shape\n    params = params.reshape(original_shape[0], original_shape[1], 6).swapaxes(0, 1)\n\n    # Collect mean reference frames from mid frames of each base pair\n    mean_reference_frames = np.hstack((mean_origin[:, np.newaxis, :],mean_rotation)).reshape(original_shape)\n\n    if is_step:\n        # Creating an array of zeros with shape (10000, 1, 6)\n        extra_column = np.zeros((params.shape[0], 1, 6))\n\n        # Concatenating the existing array and the extra column along the second axis\n        params = np.concatenate((extra_column,params), axis=1)\n\n    # Return the parameters and the mean reference frames\n    return  params, mean_reference_frames if not is_step else params\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.compute_parameters","title":"<code>compute_parameters(rotation_A, rotation_B, origin_A, origin_B)</code>","text":"<p>Calculate the parameters between each base pair and mean reference frames.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_A</code> <code>ndarray</code> <p>Rotation matrices of shape (n, 3, 3) for the first triad.</p> required <code>rotation_B</code> <code>ndarray</code> <p>Rotation matrices of shape (n, 3, 3) for the second triad.</p> required <code>origin_A</code> <code>ndarray</code> <p>Origins of shape (n, 3) for the first triad.</p> required <code>origin_B</code> <code>ndarray</code> <p>Origins of shape (n, 3) for the second triad.</p> required <p>Returns:</p> Name Type Description <code>rigid_parameters</code> <code>ndarray</code> <p>The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.</p> <code>trans_mid</code> <code>ndarray</code> <p>The mean translational vector of shape (n, 3) between the triads.</p> <code>rotation_mid</code> <code>ndarray</code> <p>The mean rotation matrix of shape (n, 3, 3) between the triads.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def compute_parameters(self, rotation_A, rotation_B, origin_A, origin_B):\n    \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n    Args:\n        rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n        rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n        origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n        origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n\n    Returns:\n        rigid_parameters (ndarray): The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.\n        trans_mid (ndarray): The mean translational vector of shape (n, 3) between the triads.\n        rotation_mid (ndarray): The mean rotation matrix of shape (n, 3, 3) between the triads.\n    \"\"\"\n\n    # Linear interpolation of translations\n    trans_mid = 0.5 * (origin_A + origin_B)\n\n    # Relative translation\n    trans_AB = origin_A - origin_B\n\n    # Get relative rotation matrix of base pair\n    rotation_BA = rotation_B.transpose(0,2,1) @ rotation_A  # returns shape (n, 3, 3)\n\n    # Get rotation angles based on  rotation matrices\n    rotation_angle_BA = RigidBody.extract_omega_values(rotation_BA)\n\n    # Compute halfway rotation matrix and triad (mid frame)\n    rotation_halfway = RigidBody.get_rotation_matrix(rotation_angle_BA * 0.5)\n\n    # Get rotation matrix of base pair (aka mean rotation frame)\n    rotation_mid = rotation_B @ rotation_halfway \n\n    # Get transaltional coordinate vector and convert to angstroms\n    translational_parameters = np.einsum('ijk,ik-&gt;ij',rotation_mid.transpose(0,2,1), trans_AB) * 10\n\n    # Get rotational parameters and convert to degrees\n    rotational_parameters = np.rad2deg(np.einsum('ijk,ik-&gt;ij', rotation_BA.transpose(0,2,1), rotation_angle_BA))\n\n    # Merge translational and rotational parameters\n    rigid_parameters = np.hstack((translational_parameters, rotational_parameters))\n\n    # Return the parameters and the mean reference frame\n    return rigid_parameters, trans_mid, rotation_mid\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.get_base_reference_frames","title":"<code>get_base_reference_frames()</code>","text":"<p>Compute reference frames for all residues in both strands.</p> <p>Returns:</p> Name Type Description <code>frames</code> <code>dict</code> <p>Mapping of MDTraj Residue to base vectors array of shape <code>(n_frames, 4, 3)</code>.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def get_base_reference_frames(self):\n    \"\"\"Compute reference frames for all residues in both strands.\n\n    Returns:\n        frames (dict): Mapping of MDTraj Residue to base vectors array of shape ``(n_frames, 4, 3)``.\n    \"\"\"\n    reference_frames = {} # Dictionary to store the base vectors for each residue\n    for res in self.res_A + self.res_B:\n        res_traj = self.traj.atom_slice([at.index for at in res.atoms])\n        base_vectors = self.get_base_vectors(res_traj)\n        reference_frames[res] = base_vectors # Store the base vectors for the residue index (with shape (4, n_frames, 3))\n    return reference_frames\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.get_base_vectors","title":"<code>get_base_vectors(res)</code>","text":"<p>Compute base reference vectors for a single residue.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>Trajectory</code> <p>Single-residue trajectory slice.</p> required <p>Returns:</p> Name Type Description <code>vectors</code> <code>ndarray</code> <p>Base vectors of shape <code>(n_frames, 4, 3)</code> ordered as <code>[b_R, b_L, b_D, b_N]</code>.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def get_base_vectors(self, res):\n    \"\"\"Compute base reference vectors for a single residue.\n\n    Args:\n        res (md.Trajectory): Single-residue trajectory slice.\n\n    Returns:\n        vectors (numpy.ndarray): Base vectors of shape ``(n_frames, 4, 3)``\n            ordered as ``[b_R, b_L, b_D, b_N]``.\n    \"\"\"\n    ref_base = ReferenceBase(res)\n    base_vectors = np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n    if not self.fit_reference:\n        return base_vectors\n    return self._get_fitted_base_vectors(res, ref_base, base_vectors)\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.get_parameter","title":"<code>get_parameter(name='twist')</code>","text":"<p>Get a single named parameter across all frames.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name. One of: shear, stretch, stagger, buckle, propeller, opening, shift, slide, rise, tilt, roll, twist.</p> <code>'twist'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Parameter values of shape <code>(n_frames, n_bp)</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the parameter name is not recognised.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def get_parameter(self, name='twist') -&gt; np.ndarray:\n    \"\"\"Get a single named parameter across all frames.\n\n    Args:\n        name (str): Parameter name. One of: shear, stretch, stagger, buckle,\n            propeller, opening, shift, slide, rise, tilt, roll, twist.\n\n    Returns:\n        numpy.ndarray: Parameter values of shape ``(n_frames, n_bp)``.\n\n    Raises:\n        ValueError: If the parameter name is not recognised.\n    \"\"\"\n\n    if name not in self.names:\n        raise ValueError(f\"Parameter {name} not found.\")\n    return self.parameters[:,:,self.names.index(name)]\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.get_parameters","title":"<code>get_parameters(step=False, base=False)</code>","text":"<p>Return computed rigid base parameters.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>bool</code> <p>If True, return only step parameters.</p> <code>False</code> <code>base</code> <code>bool</code> <p>If True, return only base-pair parameters.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>result</code> <code>tuple[ndarray, list[str]]</code> <p>Parameters of shape <code>(n_frames, n_bp, n_params)</code> and corresponding names.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both step and base are True.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def get_parameters(self, step=False, base=False):\n    \"\"\"Return computed rigid base parameters.\n\n    Args:\n        step (bool): If True, return only step parameters.\n        base (bool): If True, return only base-pair parameters.\n\n    Returns:\n        result (tuple[numpy.ndarray, list[str]]): Parameters of shape\n            ``(n_frames, n_bp, n_params)`` and corresponding names.\n\n    Raises:\n        ValueError: If both *step* and *base* are True.\n    \"\"\"\n    if step and not base:\n        return self.step_params, self.step_parameter_names\n    elif base and not step:\n        return self.bp_params, self.base_parameter_names\n    elif not step and not base:\n        return self.parameters, self.names\n    raise ValueError(\"Use only one of step=True or base=True, or neither.\")\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.get_residues","title":"<code>get_residues(chain_index, reverse=False)</code>","text":"<p>Get residues from a specified chain.</p> <p>Parameters:</p> Name Type Description Default <code>chain_index</code> <code>int</code> <p>Index of the chain in the topology.</p> required <code>reverse</code> <code>bool</code> <p>If True, return residues in reverse order (used for the anti-sense strand).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>residues</code> <code>list</code> <p>MDTraj Residue objects.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If chain_index is out of range.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def get_residues(self, chain_index, reverse=False):\n    \"\"\"Get residues from a specified chain.\n\n    Args:\n        chain_index (int): Index of the chain in the topology.\n        reverse (bool): If True, return residues in reverse order (used for the anti-sense strand).\n\n    Returns:\n        residues (list): MDTraj Residue objects.\n\n    Raises:\n        IndexError: If *chain_index* is out of range.\n    \"\"\"\n    if chain_index &gt;= len(self.top._chains):\n        raise IndexError(\"Chain index out of range.\")\n    chain = self.top._chains[chain_index]\n    residues = chain._residues\n    return list(reversed(residues)) if reverse else residues\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.load_reference_bases","title":"<code>load_reference_bases()</code>","text":"<p>Load canonical reference base structures from bundled HDF5 files.</p> <p>Returns:</p> Name Type Description <code>bases</code> <code>dict[str, Trajectory]</code> <p>Mapping of base letter (A, C, G, T) to single-frame trajectory.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def load_reference_bases(self):\n    \"\"\"Load canonical reference base structures from bundled HDF5 files.\n\n    Returns:\n        bases (dict[str, md.Trajectory]): Mapping of base letter (A, C, G, T) to single-frame trajectory.\n    \"\"\"\n    bases = ['C', 'G', 'T', 'A']\n    return {base: md.load_hdf5(get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in bases}\n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.plot_parameters","title":"<code>plot_parameters(fig=None, ax=None, mean=True, std=True, figsize=[10, 3.5], save=False, step=True, base=True, base_color='cornflowerblue', step_color='coral')</code>","text":"<p>Plot the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Existing figure.</p> <code>None</code> <code>ax</code> <code>ndarray</code> <p>Array of axes to plot on.</p> <code>None</code> <code>mean</code> <code>bool</code> <p>Plot the mean line.</p> <code>True</code> <code>std</code> <code>bool</code> <p>Plot the standard deviation band.</p> <code>True</code> <code>figsize</code> <code>list</code> <p>Figure size <code>[width, height]</code>.</p> <code>[10, 3.5]</code> <code>save</code> <code>bool</code> <p>If True, save the figure to <code>parameters.png</code>.</p> <code>False</code> <code>step</code> <code>bool</code> <p>Include step parameters.</p> <code>True</code> <code>base</code> <code>bool</code> <p>Include base-pair parameters.</p> <code>True</code> <code>base_color</code> <code>str</code> <p>Color for base-pair parameter plots.</p> <code>'cornflowerblue'</code> <code>step_color</code> <code>str</code> <p>Color for step parameter plots.</p> <code>'coral'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>tuple</code> <p><code>(fig, ax)</code> matplotlib figure and axes array.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def plot_parameters(self, fig=None, ax=None, mean=True, std=True, figsize=[10, 3.5], save=False, step=True, base=True, base_color='cornflowerblue', step_color='coral'):\n    \"\"\"Plot the rigid base parameters of the DNA structure.\n\n    Args:\n        fig (matplotlib.figure.Figure, optional): Existing figure.\n        ax (numpy.ndarray, optional): Array of axes to plot on.\n        mean (bool): Plot the mean line.\n        std (bool): Plot the standard deviation band.\n        figsize (list): Figure size ``[width, height]``.\n        save (bool): If True, save the figure to ``parameters.png``.\n        step (bool): Include step parameters.\n        base (bool): Include base-pair parameters.\n        base_color (str): Color for base-pair parameter plots.\n        step_color (str): Color for step parameter plots.\n\n    Returns:\n        result (tuple): ``(fig, ax)`` matplotlib figure and axes array.\n    \"\"\"\n\n    import matplotlib.pyplot as plt\n\n    cols = step + base\n\n    if fig is None and ax is None:\n        fig,ax = plt.subplots(cols,6, figsize=[12,2*cols])\n        ax = ax.flatten()\n    if step and not base:\n        names = self.step_parameter_names\n    elif base and not step:\n        names = self.base_parameter_names\n    elif base and step:\n        names = self.names\n\n    for _,name in enumerate(names):\n        if name in self.step_parameter_names:\n            color = step_color\n        else:\n            color = base_color\n        para = self.get_parameter(name)\n        mean = np.mean(para, axis=0)\n        std = np.std(para, axis=0)\n        x = range(len(mean))\n        #ax[_].errorbar(x,mean, yerr=std, fmt='-', color=color)\n        ax[_].fill_between(x, mean-std, mean+std, color=color, alpha=0.2)\n        ax[_].plot(mean, color=color,lw=1)    \n        ax[_].scatter(x=x,y=mean,color=color,s=10)\n        ax[_].set_title(name)\n\n    fig.tight_layout()\n    if save:\n        fig.savefig('parameters.png')\n    return fig, ax \n</code></pre>"},{"location":"api/geometry/#mdna.geometry.NucleicFrames.reshape_input","title":"<code>reshape_input(input_A, input_B, is_step=False)</code>","text":"<p>Reshape the input to the correct format for the calculations.</p> <p>Args: input_A (ndarray): Input array for the first triad. input_B (ndarray): Input array for the second triad. is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.</p> <p>Returns: rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad. rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad. origin_A (ndarray): Origins of shape (n, 3) for the first triad. origin_B (ndarray): Origins of shape (n, 3) for the second triad. original_shape (tuple): The original shape of the input.</p> Source code in <code>mdna/geometry.py</code> <pre><code>def reshape_input(self,input_A,input_B,is_step=False):\n\n    \"\"\"Reshape the input to the correct format for the calculations.\n\n    Args:\n    input_A (ndarray): Input array for the first triad.\n    input_B (ndarray): Input array for the second triad.\n    is_step (bool, optional): Flag indicating if the input is a single step or a trajectory. Defaults to False.\n\n    Returns:\n    rotation_A (ndarray): Rotation matrices of shape (n, 3, 3) for the first triad.\n    rotation_B (ndarray): Rotation matrices of shape (n, 3, 3) for the second triad.\n    origin_A (ndarray): Origins of shape (n, 3) for the first triad.\n    origin_B (ndarray): Origins of shape (n, 3) for the second triad.\n    original_shape (tuple): The original shape of the input.\n    \"\"\"\n\n    # Store original shape\n    original_shape = input_A.shape\n\n    # Flatten frames to compute rotation matrices for each time step simultaneously\n    input_A_ = input_A.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n    input_B_ = input_B.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n\n    # Extract the triads without origin (rotation matrices)\n    rotation_A = input_A_[:,1:]  # shape (n, 3, 3)\n    rotation_B = input_B_[:,1:]  # shape (n, 3, 3)\n\n    if not is_step:\n        # flip (connecting the backbones) and the (baseplane normals).\n        # so the second and third vector b_L, b_N\n        rotation_B[:,[1,2]] *= -1\n\n    # Extract origins of triads\n    origin_A = input_A_[:,0]  # shape (n, 3)\n    origin_B = input_B_[:,0]  # shape (n, 3)\n\n    return rotation_A, rotation_B, origin_A, origin_B, original_shape\n</code></pre>"},{"location":"api/minimizer/","title":"Minimizer","text":"<p>Monte Carlo energy minimization for DNA structures using the PMCpy engine.</p>"},{"location":"api/minimizer/#mdna.minimizer.Minimizer","title":"<code>mdna.minimizer.Minimizer</code>","text":"<p>Monte Carlo energy minimization of DNA structures using the PMCpy engine.</p> <p>The Minimizer relaxes a <code>Nucleic</code> object by running rigid base-pair Monte Carlo simulations with sequence-dependent elastic potentials and optional excluded-volume interactions.  Three equilibration strategies are available:</p> <ul> <li>Full equilibration (default) \u2014 adaptive convergence monitoring.</li> <li>Simple equilibration \u2014 fixed-sweep protocol, faster but less thorough.</li> <li>Writhe equilibration \u2014 maintains linking number while equilibrating   writhe for circular DNA (requires compiled PyLk Cython extensions).</li> </ul> <p>After minimization the internal frames are updated in-place and the full MC trajectory can be retrieved via :meth:<code>get_MC_traj</code>.</p> <p>Parameters:</p> Name Type Description Default <code>nucleic</code> <code>Nucleic</code> <p>A :class:<code>~mdna.nucleic.Nucleic</code> instance whose attributes (frames, sequence, topology, \u2026) are copied into the Minimizer.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If the PMCpy <code>Run</code> class cannot be imported.</p> Source code in <code>mdna/minimizer.py</code> <pre><code>class Minimizer:\n    \"\"\"Monte Carlo energy minimization of DNA structures using the PMCpy engine.\n\n    The Minimizer relaxes a ``Nucleic`` object by running rigid base-pair Monte\n    Carlo simulations with sequence-dependent elastic potentials and optional\n    excluded-volume interactions.  Three equilibration strategies are available:\n\n    * **Full equilibration** (default) \u2014 adaptive convergence monitoring.\n    * **Simple equilibration** \u2014 fixed-sweep protocol, faster but less thorough.\n    * **Writhe equilibration** \u2014 maintains linking number while equilibrating\n      writhe for circular DNA (requires compiled PyLk Cython extensions).\n\n    After minimization the internal frames are updated in-place and the full MC\n    trajectory can be retrieved via :meth:`get_MC_traj`.\n\n    Args:\n        nucleic: A :class:`~mdna.nucleic.Nucleic` instance whose attributes\n            (frames, sequence, topology, \u2026) are copied into the Minimizer.\n\n    Raises:\n        ImportError: If the PMCpy ``Run`` class cannot be imported.\n    \"\"\"\n\n    def __init__(self, nucleic: 'Nucleic') -&gt; None:\n        # Dynamically set attributes from the nucleic instance\n        self.__dict__.update(nucleic.__dict__)\n\n        # Check if the required import is available\n        if not self._check_import():\n            raise ImportError(\"Run class from pmcpy.run.run is not available.\")\n\n    def _check_import(self) -&gt; bool:\n        \"\"\"Check whether the PMCpy ``Run`` class is importable.\n\n        Returns:\n            bool: True if import succeeds, False otherwise.\n        \"\"\"\n        try:\n            from .PMCpy.pmcpy.run.run import Run\n            self.Run = Run  # Store the imported class in the instance\n            return True\n        except ImportError as e:\n            print(f\"ImportError: {e}\")\n            return False\n\n    def _initialize_mc_engine(self):\n        \"\"\"Create and return a PMCpy ``Run`` instance configured from the current state.\n\n        Returns:\n            Run: An initialized PMCpy Monte Carlo engine.\n        \"\"\"\n        # Get the positions and triads of the current frame\n        pos = self.frames[:,self.frame,0,:]\n        triads = self.frames[:,self.frame,1:,:].transpose(0,2,1) # flip row vectors to column vectors\n        print('Circular:',self.circular)\n        # Initialize the Monte Carlo engine\n        mc = self.Run(triads=triads,positions=pos,\n                        sequence=self.sequence,\n                        closed=self.circular,\n                        endpoints_fixed=self.endpoints_fixed,\n                        fixed=self.fixed,\n                        temp=self.temperature,\n                        exvol_rad=self.exvol_rad)\n        return  mc\n\n    def _update_frames(self) -&gt; None:\n        \"\"\"Write optimized positions and triads back into the stored frames array.\"\"\"\n        # update the spline with new positions and triads\n        self.frames[:,self.frame,0,:] = self.out['positions'] # set the origins of the frames\n        self.frames[:,self.frame,1:,:] = self.out['triads'].transpose(0,2,1) # set the triads of the frames as row vectors\n\n    def _get_positions_and_triads(self):\n        \"\"\"Extract final positions and triads from the MC output.\n\n        Also stores the last-frame triads and positions in ``self.out`` for\n        subsequent use by :meth:`_update_frames`.\n\n        Returns:\n            tuple[numpy.ndarray, numpy.ndarray]: ``(positions, triads)`` arrays\n                with shapes ``(n_frames, n_bp, 3)`` and\n                ``(n_frames, n_bp, 3, 3)`` respectively, where triads are\n                returned as row-vector convention.\n        \"\"\"\n        # get the positions and triads of the simulation\n        positions = self.out['confs'][:,:,:3,3] \n        triads = self.out['confs'][:,:,:3,:3]\n\n        # get the last frames of the simulation\n        self.out['triads'] = triads[-1]\n        self.out['positions'] = positions[-1]\n        return positions, triads.transpose(0,1,3,2) # flip column vectors to row vectors\n\n    def minimize(self,  frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = True, fixed : List[int] = [], dump_every : int = 20, plot : bool = False) -&gt; None:\n        \"\"\"Run Monte Carlo energy minimization on the DNA structure.\n\n        Initializes the PMCpy engine with the current base-pair frames and\n        sequence, performs MC equilibration, and updates the internal frames\n        with the relaxed configuration.\n\n        Args:\n            frame: Index of the stored frame to minimize (default ``-1``, the\n                last frame).\n            exvol_rad: Excluded-volume radius in nm.  Base pairs closer than\n                this distance incur a repulsive energy penalty.\n            temperature: Temperature in Kelvin for the Metropolis acceptance\n                criterion.\n            simple: If True, use simple (fixed-sweep) equilibration instead of\n                the adaptive convergence protocol.\n            equilibrate_writhe: If True, additionally equilibrate the writhe\n                for circular DNA.  Requires ``simple=True``.\n            endpoints_fixed: If True, the first and last base pairs are held\n                fixed during the simulation.\n            fixed: List of base-pair indices to keep fixed.\n            dump_every: Save a trajectory snapshot every *n* MC sweeps.\n            plot: If True, plot the energy trace during full equilibration.\n\n        Raises:\n            ValueError: If ``equilibrate_writhe=True`` with ``simple=False``.\n        \"\"\"\n        # Set the parameters\n        self.endpoints_fixed = endpoints_fixed\n        self.fixed = fixed\n        self.exvol_rad = exvol_rad\n        self.temperature = temperature\n        self.frame = frame\n        print('Minimize the DNA structure:\\nsimple equilibration =', simple, '\\nequilibrate writhe =', equilibrate_writhe, '\\nexcluded volume radius =', exvol_rad, '\\ntemperature =', temperature)\n        minimizer = self._initialize_mc_engine()    \n\n        # Run the Monte Carlo simulation\n        if equilibrate_writhe:\n            self.out = minimizer.equilibrate_simple(equilibrate_writhe=equilibrate_writhe,dump_every=dump_every)\n        elif not simple and equilibrate_writhe:\n            raise ValueError(\"Minimization of writhe is only supported for simple equilibration.\")\n        else:\n            self.out = minimizer.equilibrate(dump_every=dump_every,plot_equi=plot)\n\n        # Update the reference frames\n        positions, triads = self._get_positions_and_triads()\n        self._update_frames()\n\n    def get_MC_traj(self) -&gt; 'md.Trajectory':\n        \"\"\"Build an MDTraj Trajectory from the MC sampling snapshots.\n\n        Each frame contains Argon atoms at base-pair center positions and\n        Helium (dummy) atoms offset along the major-groove vector, connected\n        by bonds.  This allows visualization of the MC relaxation path.\n\n        Returns:\n            md.Trajectory: An MDTraj trajectory with ``2 * n_bp`` atoms per\n                frame and ``n_snapshots`` frames.\n        \"\"\"\n        # Get the xyz coordinates of the new spline\n        xyz = self.out['confs'][:, :, :3, 3]\n\n        # Get the triads and calculate the major vector positions\n        triads = self.out['confs'][:, :, :3, :3].transpose(0, 1, 3, 2)\n        major_vector = triads[:, :, 0, :]\n        major_positions = xyz + major_vector*1.1  # Scale the major vector by 1.1\n\n        # Concatenate the original xyz and the major_positions\n        all_positions = np.concatenate((xyz, major_positions), axis=1)\n\n        # Create a topology for the new spline\n        topology = md.Topology()\n        # Add a chain to the topology\n        chain = topology.add_chain()\n        # Add argon atoms to the topology\n        num_atoms = xyz.shape[1]\n        for i in range(num_atoms):\n            residue = topology.add_residue(name='Ar', chain=chain)\n            topology.add_atom('Ar', element=md.element.argon, residue=residue)\n\n        # Add dummy atoms to the topology\n        for i in range(num_atoms):\n            residue = topology.add_residue(name='DUM', chain=chain)\n            topology.add_atom('DUM', element=md.element.helium, residue=residue)  # Using helium as a placeholder element\n\n        # Add bonds to the topology\n        for i in range(num_atoms - 1):\n            topology.add_bond(topology.atom(i), topology.atom(i + 1))\n\n        # Add bonds between each atom and its corresponding dummy atom\n        for i in range(num_atoms):\n            topology.add_bond(topology.atom(i), topology.atom(num_atoms + i))\n\n        if self.circular:\n            # Add a bond between the first and last atom\n            topology.add_bond(topology.atom(0), topology.atom(num_atoms - 1))\n\n        # Create a trajectory from the all_positions coordinates and the topology\n        traj = md.Trajectory(all_positions, topology=topology)\n\n        return traj\n\n    def run(self, cycles: int, dump_every: int = 20, start_id: int = 0) -&gt; np.ndarray:\n        \"\"\"Run the Monte Carlo simulation\"\"\"\n        raise NotImplementedError(\"This method is not implemented yet.\")\n</code></pre>"},{"location":"api/minimizer/#mdna.minimizer.Minimizer.get_MC_traj","title":"<code>get_MC_traj()</code>","text":"<p>Build an MDTraj Trajectory from the MC sampling snapshots.</p> <p>Each frame contains Argon atoms at base-pair center positions and Helium (dummy) atoms offset along the major-groove vector, connected by bonds.  This allows visualization of the MC relaxation path.</p> <p>Returns:</p> Type Description <code>Trajectory</code> <p>md.Trajectory: An MDTraj trajectory with <code>2 * n_bp</code> atoms per frame and <code>n_snapshots</code> frames.</p> Source code in <code>mdna/minimizer.py</code> <pre><code>def get_MC_traj(self) -&gt; 'md.Trajectory':\n    \"\"\"Build an MDTraj Trajectory from the MC sampling snapshots.\n\n    Each frame contains Argon atoms at base-pair center positions and\n    Helium (dummy) atoms offset along the major-groove vector, connected\n    by bonds.  This allows visualization of the MC relaxation path.\n\n    Returns:\n        md.Trajectory: An MDTraj trajectory with ``2 * n_bp`` atoms per\n            frame and ``n_snapshots`` frames.\n    \"\"\"\n    # Get the xyz coordinates of the new spline\n    xyz = self.out['confs'][:, :, :3, 3]\n\n    # Get the triads and calculate the major vector positions\n    triads = self.out['confs'][:, :, :3, :3].transpose(0, 1, 3, 2)\n    major_vector = triads[:, :, 0, :]\n    major_positions = xyz + major_vector*1.1  # Scale the major vector by 1.1\n\n    # Concatenate the original xyz and the major_positions\n    all_positions = np.concatenate((xyz, major_positions), axis=1)\n\n    # Create a topology for the new spline\n    topology = md.Topology()\n    # Add a chain to the topology\n    chain = topology.add_chain()\n    # Add argon atoms to the topology\n    num_atoms = xyz.shape[1]\n    for i in range(num_atoms):\n        residue = topology.add_residue(name='Ar', chain=chain)\n        topology.add_atom('Ar', element=md.element.argon, residue=residue)\n\n    # Add dummy atoms to the topology\n    for i in range(num_atoms):\n        residue = topology.add_residue(name='DUM', chain=chain)\n        topology.add_atom('DUM', element=md.element.helium, residue=residue)  # Using helium as a placeholder element\n\n    # Add bonds to the topology\n    for i in range(num_atoms - 1):\n        topology.add_bond(topology.atom(i), topology.atom(i + 1))\n\n    # Add bonds between each atom and its corresponding dummy atom\n    for i in range(num_atoms):\n        topology.add_bond(topology.atom(i), topology.atom(num_atoms + i))\n\n    if self.circular:\n        # Add a bond between the first and last atom\n        topology.add_bond(topology.atom(0), topology.atom(num_atoms - 1))\n\n    # Create a trajectory from the all_positions coordinates and the topology\n    traj = md.Trajectory(all_positions, topology=topology)\n\n    return traj\n</code></pre>"},{"location":"api/minimizer/#mdna.minimizer.Minimizer.minimize","title":"<code>minimize(frame=-1, exvol_rad=2.0, temperature=300, simple=False, equilibrate_writhe=False, endpoints_fixed=True, fixed=[], dump_every=20, plot=False)</code>","text":"<p>Run Monte Carlo energy minimization on the DNA structure.</p> <p>Initializes the PMCpy engine with the current base-pair frames and sequence, performs MC equilibration, and updates the internal frames with the relaxed configuration.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>Index of the stored frame to minimize (default <code>-1</code>, the last frame).</p> <code>-1</code> <code>exvol_rad</code> <code>float</code> <p>Excluded-volume radius in nm.  Base pairs closer than this distance incur a repulsive energy penalty.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature in Kelvin for the Metropolis acceptance criterion.</p> <code>300</code> <code>simple</code> <code>bool</code> <p>If True, use simple (fixed-sweep) equilibration instead of the adaptive convergence protocol.</p> <code>False</code> <code>equilibrate_writhe</code> <code>bool</code> <p>If True, additionally equilibrate the writhe for circular DNA.  Requires <code>simple=True</code>.</p> <code>False</code> <code>endpoints_fixed</code> <code>bool</code> <p>If True, the first and last base pairs are held fixed during the simulation.</p> <code>True</code> <code>fixed</code> <code>List[int]</code> <p>List of base-pair indices to keep fixed.</p> <code>[]</code> <code>dump_every</code> <code>int</code> <p>Save a trajectory snapshot every n MC sweeps.</p> <code>20</code> <code>plot</code> <code>bool</code> <p>If True, plot the energy trace during full equilibration.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>equilibrate_writhe=True</code> with <code>simple=False</code>.</p> Source code in <code>mdna/minimizer.py</code> <pre><code>def minimize(self,  frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = True, fixed : List[int] = [], dump_every : int = 20, plot : bool = False) -&gt; None:\n    \"\"\"Run Monte Carlo energy minimization on the DNA structure.\n\n    Initializes the PMCpy engine with the current base-pair frames and\n    sequence, performs MC equilibration, and updates the internal frames\n    with the relaxed configuration.\n\n    Args:\n        frame: Index of the stored frame to minimize (default ``-1``, the\n            last frame).\n        exvol_rad: Excluded-volume radius in nm.  Base pairs closer than\n            this distance incur a repulsive energy penalty.\n        temperature: Temperature in Kelvin for the Metropolis acceptance\n            criterion.\n        simple: If True, use simple (fixed-sweep) equilibration instead of\n            the adaptive convergence protocol.\n        equilibrate_writhe: If True, additionally equilibrate the writhe\n            for circular DNA.  Requires ``simple=True``.\n        endpoints_fixed: If True, the first and last base pairs are held\n            fixed during the simulation.\n        fixed: List of base-pair indices to keep fixed.\n        dump_every: Save a trajectory snapshot every *n* MC sweeps.\n        plot: If True, plot the energy trace during full equilibration.\n\n    Raises:\n        ValueError: If ``equilibrate_writhe=True`` with ``simple=False``.\n    \"\"\"\n    # Set the parameters\n    self.endpoints_fixed = endpoints_fixed\n    self.fixed = fixed\n    self.exvol_rad = exvol_rad\n    self.temperature = temperature\n    self.frame = frame\n    print('Minimize the DNA structure:\\nsimple equilibration =', simple, '\\nequilibrate writhe =', equilibrate_writhe, '\\nexcluded volume radius =', exvol_rad, '\\ntemperature =', temperature)\n    minimizer = self._initialize_mc_engine()    \n\n    # Run the Monte Carlo simulation\n    if equilibrate_writhe:\n        self.out = minimizer.equilibrate_simple(equilibrate_writhe=equilibrate_writhe,dump_every=dump_every)\n    elif not simple and equilibrate_writhe:\n        raise ValueError(\"Minimization of writhe is only supported for simple equilibration.\")\n    else:\n        self.out = minimizer.equilibrate(dump_every=dump_every,plot_equi=plot)\n\n    # Update the reference frames\n    positions, triads = self._get_positions_and_triads()\n    self._update_frames()\n</code></pre>"},{"location":"api/minimizer/#mdna.minimizer.Minimizer.run","title":"<code>run(cycles, dump_every=20, start_id=0)</code>","text":"<p>Run the Monte Carlo simulation</p> Source code in <code>mdna/minimizer.py</code> <pre><code>def run(self, cycles: int, dump_every: int = 20, start_id: int = 0) -&gt; np.ndarray:\n    \"\"\"Run the Monte Carlo simulation\"\"\"\n    raise NotImplementedError(\"This method is not implemented yet.\")\n</code></pre>"},{"location":"api/nucleic/","title":"Nucleic","text":"<p>The central class in MDNA, holding the DNA sequence, reference frames, and atomic trajectory.</p>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic","title":"<code>mdna.nucleic.Nucleic</code>","text":"<p>Contains mdna DNA structure with reference frames and trajectory</p> Source code in <code>mdna/nucleic.py</code> <pre><code>class Nucleic:\n\n    \"\"\"Contains mdna DNA structure with reference frames and trajectory\"\"\"\n\n    def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=[0,1], circular=None):\n            \"\"\"Initializes the DNA structure.\n\n            Args:\n                sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n                n_bp (int): The number of base pairs. Default is None.\n                traj (object): The MDTraj trajectory. Default is None.\n                frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n                chainids (list): The chain IDs. Default is [0,1].\n                circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n            Raises:\n                ValueError: If both traj and frames are provided.\n                ValueError: If frames have an invalid shape.\n                ValueError: If the number of base pairs in the sequence and frames do not match.\n                ValueError: If neither traj nor frames are provided.\n\n            Notes:\n                - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n                - If frames is provided, n_bp will be determined from the shape of frames.\n                - If sequence is provided, it will be checked against the number of base pairs.\n\n            Attributes:\n                sequence (str): The DNA sequence.\n                n_bp (int): The number of base pairs.\n                traj (object): The MDTraj trajectory.\n                frames (np.ndarray): The reference frames of the DNA structure.\n                chainids (list): The chain IDs.\n                circular (bool): A flag that indicates if the structure is circular/closed.\n                rigid (None): A container for rigid base parameters class output.\n                minimizer (None): A container for minimizer class output.\n            \"\"\"\n            # Check for trajectory\n            if traj is not None:\n                if frames is not None:\n                    raise ValueError('Provide either a trajectory or reference frames, not both')\n                # Extract sequence from the trajectory\n                sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n                n_bp = len(sequence)\n                sequence = ''.join(sequence)\n                frames = None  # Nucleic class will handle extraction from traj\n\n            # Check for reference frames\n            elif frames is not None:\n                if frames.ndim == 3:\n                    # Case (n_bp, 4, 3)\n                    frames = np.expand_dims(frames, axis=1)\n                if frames.ndim != 4:\n                    raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n                n_bp = frames.shape[0]\n                if sequence is not None:\n                    if len(sequence) != n_bp:\n                        raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                    else:\n                        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n            else:\n                raise ValueError('Provide either a trajectory or reference frames')\n\n            self.sequence, self.n_bp = sequence, n_bp\n            self.traj = traj\n            self.frames = frames\n            self.chainids = chainids\n            self.circular = self._is_circular() if circular is None else circular \n            self.rigid = None # Container for rigid base parameters class output\n            self.minimizer = None # Container for minimizer class output\n            self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n\n    def describe(self):\n        \"\"\"Print the DNA structure information\"\"\"\n        print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n        print('Sequence:', ''.join(self.sequence))\n\n        if self.traj is not None:\n            print('Trajectory:',self.traj)\n        else:\n            print('Trajectory not loaded')\n\n        if self.frames is not None:\n            print('Frames: ', self.frames.shape)\n        else:\n            print('Frames not loaded')\n\n    def _frames_to_traj(self, frame=-1):\n        \"\"\"Convert reference frames to trajectory\"\"\"\n        if self.frames is None:\n            raise ValueError('Load reference frames first')\n        self.traj = None\n        generator = StructureGenerator(frames=self.frames[:,frame,:,:], sequence=self.sequence, circular=self.circular)\n        self.traj = generator.get_traj(remove_terminal_phosphates=False)\n\n    def _traj_to_frames(self):\n        \"\"\"Convert trajectory to reference frames\"\"\"\n        if self.traj is None:\n            raise ValueError('Load trajectory first')\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        self.frames =self.rigid.frames\n\n    def get_frames(self):\n        \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n        Returns: array of reference frames of shape (n_bp, n_frames, 4, 3)\n        where n_bp is the number of base pairs, n_frames is the number of frames, \n        and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n        Returns:\n            frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n        if self.frames is None:\n            self._traj_to_frames()\n        return self.frames\n\n    def get_traj(self):\n        \"\"\"Get the trajectory of the current state of the DNA structure\n        Returns:\n            MDtraj object\"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n\n        if self.traj.n_atoms &gt; 99999:\n            print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n        return self.traj\n\n    def get_rigid_object(self):\n        \"\"\"Get the rigid base class object of the DNA structure\n\n        Returns:\n            NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n        if self.rigid is None and self.traj is not None:\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        elif self.rigid is None and self.traj is None:\n            self._frames_to_traj()\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        else:\n            return self.rigid\n\n    def get_parameters(self, step : bool = False, base : bool = False) -&gt; tuple[np.ndarray, list[str]]:\n        \"\"\"By default retuns all the parameters of the DNA structure.\n        Use arguments to get a specific parameter group of the DNA structure.\n\n        Args:\n            step (bool, optional): Returns only the step parameters of consequative bases. Defaults to False.\n            base (bool, optional): Returns onlt the base pair parameters of opposing bases. Defaults to False.\n\n        Returns:\n            (parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameters(step=step, base=base)\n\n    def get_parameter(self, parameter_name : str) -&gt; np.ndarray:\n        \"\"\"Get a specific parameter from the rigid base parameters class object of the DNA structure\n\n        Args:\n            parameter_name (str): The name of the parameter to retrieve.\n\n        Notes:\n            The following parameters can be retrieved:\n            - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n        Returns:\n            np.ndarray: The parameter values of the DNA structure.\"\"\"\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_parameter(parameter_name)\n\n    def get_base_frames(self) -&gt; dict:\n        \"\"\"Get the base reference frames of the DNA structure\n\n        Returns:\n            dict: A dictionary containing the base reference frames of the DNA structure.\n                The keys are residue topologies of the MDTraj object (`traj.top.residues`) and\n                the values are reference frames with shape `(n_frames, 4, 3)`, where rows are\n                origin, `b_L`, `b_D`, and `b_N`.\n        \"\"\"\n\n        if self.rigid is None:\n            self.get_rigid_object()\n        return self.rigid.get_base_reference_frames()\n\n\n    def _is_circular(self, frame=0):\n        \"\"\"Detects if the DNA structure is circular for a given chain and frame.\n\n        Args:\n            frame (int, optional): Frame index to check. Default is 0.\n\n        Returns:\n            bool: True if the DNA is circular, False otherwise.\n        \"\"\"\n        if self.frames is None:\n            self._traj_to_frames()\n\n        start = self.frames[0, frame, 0]\n        end = self.frames[-1, frame, 0]\n        distance = np.linalg.norm(start - end)\n\n        # 0.34 nm is roughly the distance between base pairs and 20 is the minimum number of base pairs for circular DNA\n        return distance &lt; 1 and self.frames.shape[0] &gt; 20\n\n    def _plot_chain(self, ax, traj, chainid, frame, lw=1, markersize=2, color='k'):\n        \"\"\"Plot the DNA structure of a chain\"\"\"\n        phosphor = traj.top.select(f'name P and chainid {chainid}')\n        x = traj.xyz[frame, phosphor, 0]\n        y = traj.xyz[frame, phosphor, 1]\n        z = traj.xyz[frame, phosphor, 2]\n\n        ax.plot(x, y, z, '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n        if self.circular:\n            # Connect the last point to the first point\n            ax.plot([x[-1], x[0]], [y[-1], y[0]], [z[-1], z[0]], '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n    def _plot_helical_axis(self, ax, frame, lw=1, color='k'):\n        helical_axis = self.frames[:,frame,0]\n        ax.plot(helical_axis[:,0],helical_axis[:,1],helical_axis[:,2],':',c=color,lw=lw*0.7)\n        if self.circular:\n            ax.plot([helical_axis[-1,0],helical_axis[0,0]],[helical_axis[-1,1],helical_axis[0,1]],[helical_axis[-1,2],helical_axis[0,2]],':',c='k',lw=lw*0.7)\n\n    def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey',color_axis='k'):\n        \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n        Args:\n            ax (object, optional): Matplotlib axis. Default is None.\n            fig (object, optional): Figure axis. Default is None.\n            save (bool, optional): Save image as png. Default is False.\n            frame (int, optional): Index of trajectory to visualize. Default is -1.\n            markersize (int, optional): Width of backbone plot. Default is 2.\n            lw (int, optional): Line width of plots. Default is 1.\n            helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n            backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n            lead (bool, optional): Plot leading strand. Default is False.\n            anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n            triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n            length (float, optional): Length of triad vectors. Default is 0.23.\n            color_lead (str, optional): Color of the leading strand. Default is 'k'.\n            color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n            color_axis (str, optional): Color of the helical axis. Default is 'k'.\n\n        Notes:\n            - The function draws a 3D representation of the DNA structure using matplotlib.\n            - The function requires either the trajectory or reference frames to be loaded before calling.\n\n        Example:\n            Make a DNA structure and draw the 3D representation\n            ```python\n            dna = nuc.make(sequence='CGCGAATTCGCG')\n            dna.draw()\n            ```\n        \"\"\"\n\n        # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n        # in shape (time/n_frames, n_bp, 4, 3)\n\n        if self.traj is None:\n            self._frames_to_traj()\n        elif self.frames is None:\n            self._traj_to_frames()\n\n        if fig is None and ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n\n        if backbone:\n            lead = True\n            anti = True\n        if lead:\n            self._plot_chain(ax, self.traj, self.chainids[0], frame=frame, markersize=markersize, lw=lw, color=color_lead)\n        if anti:\n            self._plot_chain(ax, self.traj, self.chainids[1], frame=frame, markersize=markersize, lw=lw, color=color_anti)\n        if helical_axis:\n            self._plot_helical_axis(ax, frame=frame, lw=lw, color=color_axis)\n        if triads:\n            for triad in self.frames:\n                triad = triad[frame]\n                ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n        ax.axis('equal')\n        ax.axis('off')\n        if save:\n            fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n\n    def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 5, plot : bool = False):\n        \"\"\"\n        Minimize the DNA structure. This method updates the  of the DNA structure.\n\n        Args:\n            frame (int): The trajectory frame to minimize. Defaults to -1.\n            simple (bool): Whether to use simple equilibration. Defaults to False.\n            equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n            endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n            fixed (list): List of fixed base pairs. Defaults to an empty list.\n            exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n            temperature (int): Temperature for equilibration. Defaults to 300.\n            dump_every (int): Frequency of dumping frames. Defaults to 5.\n            plot (bool): Whether to plot the energy. Defaults to False.\n\n        Additional keyword arguments can be provided and will be passed to the minimizer.\n\n        Notes:\n\n            For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n            This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n            The other option is to use the full equilibration, which is based on the actual energy of the system.\n            We assume the energy to converge exponentially to the equilibrated value.\n            This works fairly well for most examples I checked but is not entirely robust. \n            Considering autocorrelation has some issues when there are relaxations at different timescales.\n            Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n            It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n        Example:\n            Load a DNA structure and minimize it\n            ```python\n            nuc = mdna.load(traj)\n            nuc.minimize(temperature=310, exvol_rad=2.0)\n            ```\n        \"\"\"\n        self.minimizer = Minimizer(self)\n        self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n        # Update the reference frames\n        self._frames_to_traj()\n\n    def get_MC_traj(self):\n        \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n        if self.minimizer is None:\n            raise ValueError('Run minimization first')\n        return self.minimizer.get_MC_traj()\n\n    def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n        \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n        The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n        Args:\n            mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n            complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n            frame (int, optional): The frame to mutate. Defaults to -1.\n            verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n        Raises:\n            ValueError: If no mutation dictionary is provided.\n\n        Notes:\n            - Valid nucleobases for mutations include:\n                - Canonical bases: A, T, G, C, U\n                - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n                - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n                - Hydrophobic pairs: d5SICS (L), dNaM (M)\n            - Mutation updates coordinates/topology and clears cached frame/rigid/minimization state.\n\n        Example:\n            Create a DNA object \n            ```python\n            dna = DNA()\n            mutations = {0: 'A', 1: 'T', 2: 'G'}\n            dna.mutate(mutations=mutations, complementary=True, frame=-1)\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if mutations is None:\n            raise ValueError('Provide a mutation dictionary')\n\n        # TODO: Check if valid letters in mutations dictionary\n\n        mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n        self.traj = mutant.get_traj()\n        # Update sequence\n        self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n        self.frames = None\n        self.rigid = None\n        self.minimizer = None\n\n\n    def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n            \"\"\"Flips the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n                deg (int): The degrees to flip. Defaults to 180.\n                frame (int): The frame to flip. Defaults to -1.\n\n            Raises:\n                ValueError: If no fliplist is provided.\n\n            Notes:\n                - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n                - Flipping updates coordinates and clears cached frame/rigid/minimization state.\n\n            Example:\n                Flip DNA\n                ```python\n                dna = mdna.make('GCAAAGC)\n                dna.flip(fliplist=[3,4], deg=180)\n                ```\n\n            \"\"\"\n\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(fliplist) == 0:\n                raise ValueError('Provide a fliplist')\n\n            flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n            self.traj = flipper.get_traj()\n            self.frames = None\n            self.rigid = None\n            self.minimizer = None\n\n    def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n            \"\"\"Methylate the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                methylations (list): List of base pairs to methylate. Defaults to [].\n                CpG (bool): Whether to methylate CpG sites. Defaults to False.\n                leading_strand (int): The leading strand to methylate. Defaults to 0.\n                frame (int): The frame to methylate. Defaults to -1.\n\n            Raises:\n                ValueError: If the DNA structure is not loaded.\n                ValueError: If the methylations list is empty.\n\n            Notes:\n                Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n                Cached frame/rigid/minimization state is cleared after methylation.\n\n            Example:\n                Methylate DNA\n                ```python\n                dna = mdna.make('GCGCGCGAGCGA)\n                dna.metyhlate(fliplist=[3,4])\n                ```\n            \"\"\"\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(methylations) == 0 and not CpG:\n                raise ValueError('Provide a non-empty methylations list')\n\n            methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n            self.traj = methylator.get_traj()\n            self.frames = None\n            self.rigid = None\n            self.minimizer = None\n\n    def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n        \"\"\"Extend the DNA structure in the specified direction.\n            The method updates the attributes of the DNA object.\n\n\n        Args:\n            n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n            sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n            fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n            forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n            frame (int, optional): The time frame to extend. Defaults to -1.\n            shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n            margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n            minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n            plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n            exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n            temperature (int, optional): Temperature for equilibration. Defaults\n\n        Raises:\n            ValueError: If the DNA structure is circular and cannot be extended.\n            ValueError: If neither a fixed endpoint nor a length is specified for extension.\n            ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n        Notes:\n            - If the DNA structure is circular, it cannot be extended.\n\n        Example:\n            Extend DNA structure\n            ```python\n            nuc = mdna.make(n_bp=100)\n            nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n            ```\n        \"\"\"\n        if self.circular:\n            raise ValueError('Cannot extend circular DNA structure')  \n        if self.traj is None:\n            self._frames_to_traj()\n        if shape is None:\n            shape = Shapes.line(length=1)\n        if self.frames is None:\n            self._traj_to_frames()\n\n        # Check the input sequence and number of base pairs\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n        extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n        # Also update, n_bp, sequence, frames etc\n        self.nuc = extender.nuc\n\n        if minimize:\n            self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n        # Update attributes\n        self.sequence = self.nuc.sequence\n        self.traj = self.nuc.get_traj()\n        self.frames = self.nuc.get_frames()\n        self.n_bp = self.nuc.n_bp\n\n    def invert(self):\n        \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n         The method updates attributes of the DNA object.\n\n         Raises:\n            NotImplementedError: Not implemented yet.\n        \"\"\"\n        raise NotImplementedError('Not implemented yet')\n\n    def get_linking_number(self, frame : int = -1):\n        \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n        Args:\n            frame (int, optional): Time frame of trajectory, by default -1\n\n        Returns:\n            linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n        \"\"\"\n\n        if self.frames is None:\n                self._traj_to_frames()\n        frames = self.frames[:,frame,:,:]\n        positions = np.ascontiguousarray(frames[:,0])\n        triads = np.ascontiguousarray(frames[:,1:].transpose(0,2,1)) # Flip row vectors to columns\n\n        writhe = pylk.writhe(positions)\n        lk = pylk.triads2link(positions, triads)\n        return np.array([lk, writhe, lk - writhe])\n\n    def save_pdb(self, filename : str = None, frame : int = -1):\n        \"\"\"Save the DNA structure as a pdb file.\n\n        Args:\n            filename (str, optional): Filename to save the pdb file. Defaults to None.\n            frame (int, optional): If the trajectory has multiple frames, specify the frame to save. Defaults to -1.\n        \"\"\"\n\n        # check if traj\n        if self.traj is None:\n            self._frames_to_traj()\n        if filename is None:\n            filename = 'my_mdna'\n        self.traj[frame].save(f'{filename}.pdb')\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.__init__","title":"<code>__init__(sequence=None, n_bp=None, traj=None, frames=None, chainids=[0, 1], circular=None)</code>","text":"<p>Initializes the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence, e.g. 'CGCGAATTCGCG'.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>The number of base pairs. Default is None.</p> <code>None</code> <code>traj</code> <code>object</code> <p>The MDTraj trajectory. Default is None.</p> <code>None</code> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure. Default is None.</p> <code>None</code> <code>chainids</code> <code>list</code> <p>The chain IDs. Default is [0,1].</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both traj and frames are provided.</p> <code>ValueError</code> <p>If frames have an invalid shape.</p> <code>ValueError</code> <p>If the number of base pairs in the sequence and frames do not match.</p> <code>ValueError</code> <p>If neither traj nor frames are provided.</p> Notes <ul> <li>If traj is provided, sequence and n_bp will be extracted from the trajectory.</li> <li>If frames is provided, n_bp will be determined from the shape of frames.</li> <li>If sequence is provided, it will be checked against the number of base pairs.</li> </ul> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>str</code> <p>The DNA sequence.</p> <code>n_bp</code> <code>int</code> <p>The number of base pairs.</p> <code>traj</code> <code>object</code> <p>The MDTraj trajectory.</p> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure.</p> <code>chainids</code> <code>list</code> <p>The chain IDs.</p> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed.</p> <code>rigid</code> <code>None</code> <p>A container for rigid base parameters class output.</p> <code>minimizer</code> <code>None</code> <p>A container for minimizer class output.</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=[0,1], circular=None):\n        \"\"\"Initializes the DNA structure.\n\n        Args:\n            sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n            n_bp (int): The number of base pairs. Default is None.\n            traj (object): The MDTraj trajectory. Default is None.\n            frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n            chainids (list): The chain IDs. Default is [0,1].\n            circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n        Raises:\n            ValueError: If both traj and frames are provided.\n            ValueError: If frames have an invalid shape.\n            ValueError: If the number of base pairs in the sequence and frames do not match.\n            ValueError: If neither traj nor frames are provided.\n\n        Notes:\n            - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n            - If frames is provided, n_bp will be determined from the shape of frames.\n            - If sequence is provided, it will be checked against the number of base pairs.\n\n        Attributes:\n            sequence (str): The DNA sequence.\n            n_bp (int): The number of base pairs.\n            traj (object): The MDTraj trajectory.\n            frames (np.ndarray): The reference frames of the DNA structure.\n            chainids (list): The chain IDs.\n            circular (bool): A flag that indicates if the structure is circular/closed.\n            rigid (None): A container for rigid base parameters class output.\n            minimizer (None): A container for minimizer class output.\n        \"\"\"\n        # Check for trajectory\n        if traj is not None:\n            if frames is not None:\n                raise ValueError('Provide either a trajectory or reference frames, not both')\n            # Extract sequence from the trajectory\n            sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n            n_bp = len(sequence)\n            sequence = ''.join(sequence)\n            frames = None  # Nucleic class will handle extraction from traj\n\n        # Check for reference frames\n        elif frames is not None:\n            if frames.ndim == 3:\n                # Case (n_bp, 4, 3)\n                frames = np.expand_dims(frames, axis=1)\n            if frames.ndim != 4:\n                raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n            n_bp = frames.shape[0]\n            if sequence is not None:\n                if len(sequence) != n_bp:\n                    raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                else:\n                    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n        else:\n            raise ValueError('Provide either a trajectory or reference frames')\n\n        self.sequence, self.n_bp = sequence, n_bp\n        self.traj = traj\n        self.frames = frames\n        self.chainids = chainids\n        self.circular = self._is_circular() if circular is None else circular \n        self.rigid = None # Container for rigid base parameters class output\n        self.minimizer = None # Container for minimizer class output\n        self.base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z'}\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.describe","title":"<code>describe()</code>","text":"<p>Print the DNA structure information</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def describe(self):\n    \"\"\"Print the DNA structure information\"\"\"\n    print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n    print('Sequence:', ''.join(self.sequence))\n\n    if self.traj is not None:\n        print('Trajectory:',self.traj)\n    else:\n        print('Trajectory not loaded')\n\n    if self.frames is not None:\n        print('Frames: ', self.frames.shape)\n    else:\n        print('Frames not loaded')\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_frames","title":"<code>get_frames()</code>","text":"<p>Get the reference frames of the DNA structure belonging to the base steps: Returns: array of reference frames of shape (n_bp, n_frames, 4, 3) where n_bp is the number of base pairs, n_frames is the number of frames,  and 4 corresponds to the origin and the 3 vectors of the reference frame</p> <p>Returns:</p> Name Type Description <code>frames</code> <code>ndarray</code> <p>reference frames of the DNA structure</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_frames(self):\n    \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n    Returns: array of reference frames of shape (n_bp, n_frames, 4, 3)\n    where n_bp is the number of base pairs, n_frames is the number of frames, \n    and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n    Returns:\n        frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n    if self.frames is None:\n        self._traj_to_frames()\n    return self.frames\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_traj","title":"<code>get_traj()</code>","text":"<p>Get the trajectory of the current state of the DNA structure Returns:     MDtraj object</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_traj(self):\n    \"\"\"Get the trajectory of the current state of the DNA structure\n    Returns:\n        MDtraj object\"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n\n    if self.traj.n_atoms &gt; 99999:\n        print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n    return self.traj\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_rigid_object","title":"<code>get_rigid_object()</code>","text":"<p>Get the rigid base class object of the DNA structure</p> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_rigid_object(self):\n    \"\"\"Get the rigid base class object of the DNA structure\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n    if self.rigid is None and self.traj is not None:\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    elif self.rigid is None and self.traj is None:\n        self._frames_to_traj()\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    else:\n        return self.rigid\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_parameters","title":"<code>get_parameters(step=False, base=False)</code>","text":"<p>By default retuns all the parameters of the DNA structure. Use arguments to get a specific parameter group of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>bool</code> <p>Returns only the step parameters of consequative bases. Defaults to False.</p> <code>False</code> <code>base</code> <code>bool</code> <p>Returns onlt the base pair parameters of opposing bases. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[ndarray, list[str]]</code> <p>(parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_parameters(self, step : bool = False, base : bool = False) -&gt; tuple[np.ndarray, list[str]]:\n    \"\"\"By default retuns all the parameters of the DNA structure.\n    Use arguments to get a specific parameter group of the DNA structure.\n\n    Args:\n        step (bool, optional): Returns only the step parameters of consequative bases. Defaults to False.\n        base (bool, optional): Returns onlt the base pair parameters of opposing bases. Defaults to False.\n\n    Returns:\n        (parameters, names) (tuple) : Returns the names of the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_parameters(step=step, base=base)\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_parameter","title":"<code>get_parameter(parameter_name)</code>","text":"<p>Get a specific parameter from the rigid base parameters class object of the DNA structure</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>The name of the parameter to retrieve.</p> required Notes <p>The following parameters can be retrieved: - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The parameter values of the DNA structure.</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_parameter(self, parameter_name : str) -&gt; np.ndarray:\n    \"\"\"Get a specific parameter from the rigid base parameters class object of the DNA structure\n\n    Args:\n        parameter_name (str): The name of the parameter to retrieve.\n\n    Notes:\n        The following parameters can be retrieved:\n        - shift, slide, rise, tilt, roll, twist, shear, stretch, stagger, buckle, propeller, opening\n\n    Returns:\n        np.ndarray: The parameter values of the DNA structure.\"\"\"\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_parameter(parameter_name)\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_base_frames","title":"<code>get_base_frames()</code>","text":"<p>Get the base reference frames of the DNA structure</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the base reference frames of the DNA structure. The keys are residue topologies of the MDTraj object (<code>traj.top.residues</code>) and the values are reference frames with shape <code>(n_frames, 4, 3)</code>, where rows are origin, <code>b_L</code>, <code>b_D</code>, and <code>b_N</code>.</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_base_frames(self) -&gt; dict:\n    \"\"\"Get the base reference frames of the DNA structure\n\n    Returns:\n        dict: A dictionary containing the base reference frames of the DNA structure.\n            The keys are residue topologies of the MDTraj object (`traj.top.residues`) and\n            the values are reference frames with shape `(n_frames, 4, 3)`, where rows are\n            origin, `b_L`, `b_D`, and `b_N`.\n    \"\"\"\n\n    if self.rigid is None:\n        self.get_rigid_object()\n    return self.rigid.get_base_reference_frames()\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_linking_number","title":"<code>get_linking_number(frame=-1)</code>","text":"<p>Get the linking number of the DNA structure based on Gauss's linking number theorem.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>Time frame of trajectory, by default -1</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>linking_number</code> <code>ndarray</code> <p>Numpy array containing the linking number, writhe, and twist corresponding to the time frame</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_linking_number(self, frame : int = -1):\n    \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n    Args:\n        frame (int, optional): Time frame of trajectory, by default -1\n\n    Returns:\n        linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n    \"\"\"\n\n    if self.frames is None:\n            self._traj_to_frames()\n    frames = self.frames[:,frame,:,:]\n    positions = np.ascontiguousarray(frames[:,0])\n    triads = np.ascontiguousarray(frames[:,1:].transpose(0,2,1)) # Flip row vectors to columns\n\n    writhe = pylk.writhe(positions)\n    lk = pylk.triads2link(positions, triads)\n    return np.array([lk, writhe, lk - writhe])\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.draw","title":"<code>draw(ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23, color_lead='k', color_anti='darkgrey', color_axis='k')</code>","text":"<p>Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>object</code> <p>Matplotlib axis. Default is None.</p> <code>None</code> <code>fig</code> <code>object</code> <p>Figure axis. Default is None.</p> <code>None</code> <code>save</code> <code>bool</code> <p>Save image as png. Default is False.</p> <code>False</code> <code>frame</code> <code>int</code> <p>Index of trajectory to visualize. Default is -1.</p> <code>-1</code> <code>markersize</code> <code>int</code> <p>Width of backbone plot. Default is 2.</p> <code>2</code> <code>lw</code> <code>int</code> <p>Line width of plots. Default is 1.</p> <code>1</code> <code>helical_axis</code> <code>bool</code> <p>Plot central axis passing through frame origins. Default is True.</p> <code>True</code> <code>backbone</code> <code>bool</code> <p>Plot backbone as 'o-' line plot through phosphor atoms. Default is True.</p> <code>True</code> <code>lead</code> <code>bool</code> <p>Plot leading strand. Default is False.</p> <code>False</code> <code>anti</code> <code>bool</code> <p>Plot anti-sense opposing leading strand. Default is False.</p> <code>False</code> <code>triads</code> <code>bool</code> <p>Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.</p> <code>False</code> <code>length</code> <code>float</code> <p>Length of triad vectors. Default is 0.23.</p> <code>0.23</code> <code>color_lead</code> <code>str</code> <p>Color of the leading strand. Default is 'k'.</p> <code>'k'</code> <code>color_anti</code> <code>str</code> <p>Color of the anti strand. Default is 'darkgrey'.</p> <code>'darkgrey'</code> <code>color_axis</code> <code>str</code> <p>Color of the helical axis. Default is 'k'.</p> <code>'k'</code> Notes <ul> <li>The function draws a 3D representation of the DNA structure using matplotlib.</li> <li>The function requires either the trajectory or reference frames to be loaded before calling.</li> </ul> Example <p>Make a DNA structure and draw the 3D representation <pre><code>dna = nuc.make(sequence='CGCGAATTCGCG')\ndna.draw()\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey',color_axis='k'):\n    \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n    Args:\n        ax (object, optional): Matplotlib axis. Default is None.\n        fig (object, optional): Figure axis. Default is None.\n        save (bool, optional): Save image as png. Default is False.\n        frame (int, optional): Index of trajectory to visualize. Default is -1.\n        markersize (int, optional): Width of backbone plot. Default is 2.\n        lw (int, optional): Line width of plots. Default is 1.\n        helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n        backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n        lead (bool, optional): Plot leading strand. Default is False.\n        anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n        triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n        length (float, optional): Length of triad vectors. Default is 0.23.\n        color_lead (str, optional): Color of the leading strand. Default is 'k'.\n        color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n        color_axis (str, optional): Color of the helical axis. Default is 'k'.\n\n    Notes:\n        - The function draws a 3D representation of the DNA structure using matplotlib.\n        - The function requires either the trajectory or reference frames to be loaded before calling.\n\n    Example:\n        Make a DNA structure and draw the 3D representation\n        ```python\n        dna = nuc.make(sequence='CGCGAATTCGCG')\n        dna.draw()\n        ```\n    \"\"\"\n\n    # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n    # in shape (time/n_frames, n_bp, 4, 3)\n\n    if self.traj is None:\n        self._frames_to_traj()\n    elif self.frames is None:\n        self._traj_to_frames()\n\n    if fig is None and ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n\n    if backbone:\n        lead = True\n        anti = True\n    if lead:\n        self._plot_chain(ax, self.traj, self.chainids[0], frame=frame, markersize=markersize, lw=lw, color=color_lead)\n    if anti:\n        self._plot_chain(ax, self.traj, self.chainids[1], frame=frame, markersize=markersize, lw=lw, color=color_anti)\n    if helical_axis:\n        self._plot_helical_axis(ax, frame=frame, lw=lw, color=color_axis)\n    if triads:\n        for triad in self.frames:\n            triad = triad[frame]\n            ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n    ax.axis('equal')\n    ax.axis('off')\n    if save:\n        fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.minimize","title":"<code>minimize(frame=-1, exvol_rad=2.0, temperature=300, simple=False, equilibrate_writhe=False, endpoints_fixed=False, fixed=[], dump_every=5, plot=False)</code>","text":"<p>Minimize the DNA structure. This method updates the  of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The trajectory frame to minimize. Defaults to -1.</p> <code>-1</code> <code>simple</code> <code>bool</code> <p>Whether to use simple equilibration. Defaults to False.</p> <code>False</code> <code>equilibrate_writhe</code> <code>bool</code> <p>Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.</p> <code>False</code> <code>endpoints_fixed</code> <code>bool</code> <p>Whether the endpoints are fixed. Defaults to False.</p> <code>False</code> <code>fixed</code> <code>list</code> <p>List of fixed base pairs. Defaults to an empty list.</p> <code>[]</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults to 300.</p> <code>300</code> <code>dump_every</code> <code>int</code> <p>Frequency of dumping frames. Defaults to 5.</p> <code>5</code> <code>plot</code> <code>bool</code> <p>Whether to plot the energy. Defaults to False.</p> <code>False</code> <p>Additional keyword arguments can be provided and will be passed to the minimizer.</p> <p>Notes:</p> <pre><code>For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \nThis options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration.\n\nThe other option is to use the full equilibration, which is based on the actual energy of the system.\nWe assume the energy to converge exponentially to the equilibrated value.\nThis works fairly well for most examples I checked but is not entirely robust. \nConsidering autocorrelation has some issues when there are relaxations at different timescales.\nAlso, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \nIt is really non-trivial to set a criterion for whether or not a globally stable value is reached.\n</code></pre> Example <p>Load a DNA structure and minimize it <pre><code>nuc = mdna.load(traj)\nnuc.minimize(temperature=310, exvol_rad=2.0)\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 5, plot : bool = False):\n    \"\"\"\n    Minimize the DNA structure. This method updates the  of the DNA structure.\n\n    Args:\n        frame (int): The trajectory frame to minimize. Defaults to -1.\n        simple (bool): Whether to use simple equilibration. Defaults to False.\n        equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n        endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n        fixed (list): List of fixed base pairs. Defaults to an empty list.\n        exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n        temperature (int): Temperature for equilibration. Defaults to 300.\n        dump_every (int): Frequency of dumping frames. Defaults to 5.\n        plot (bool): Whether to plot the energy. Defaults to False.\n\n    Additional keyword arguments can be provided and will be passed to the minimizer.\n\n    Notes:\n\n        For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n        This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n        The other option is to use the full equilibration, which is based on the actual energy of the system.\n        We assume the energy to converge exponentially to the equilibrated value.\n        This works fairly well for most examples I checked but is not entirely robust. \n        Considering autocorrelation has some issues when there are relaxations at different timescales.\n        Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n        It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n    Example:\n        Load a DNA structure and minimize it\n        ```python\n        nuc = mdna.load(traj)\n        nuc.minimize(temperature=310, exvol_rad=2.0)\n        ```\n    \"\"\"\n    self.minimizer = Minimizer(self)\n    self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n    # Update the reference frames\n    self._frames_to_traj()\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.mutate","title":"<code>mutate(mutations=None, complementary=True, frame=-1, verbose=False)</code>","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the mutated sequence. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> <li>Mutation updates coordinates/topology and clears cached frame/rigid/minimization state.</li> </ul> Example <p>Create a DNA object  <pre><code>dna = DNA()\nmutations = {0: 'A', 1: 'T', 2: 'G'}\ndna.mutate(mutations=mutations, complementary=True, frame=-1)\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1, verbose: bool = False):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n        verbose (bool, optional): Whether to print the mutated sequence. Defaults to False.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n        - Mutation updates coordinates/topology and clears cached frame/rigid/minimization state.\n\n    Example:\n        Create a DNA object \n        ```python\n        dna = DNA()\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n        ```\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary, verbose=verbose)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n    self.frames = None\n    self.rigid = None\n    self.minimizer = None\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.flip","title":"<code>flip(fliplist=[], deg=180, frame=-1)</code>","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <ul> <li>Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.</li> <li>Flipping updates coordinates and clears cached frame/rigid/minimization state.</li> </ul> Example <p>Flip DNA <pre><code>dna = mdna.make('GCAAAGC)\ndna.flip(fliplist=[3,4], deg=180)\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            - Rotating the nucleobase by 180 degrees corresponds to the Hoogsteen base pair configuration.\n            - Flipping updates coordinates and clears cached frame/rigid/minimization state.\n\n        Example:\n            Flip DNA\n            ```python\n            dna = mdna.make('GCAAAGC)\n            dna.flip(fliplist=[3,4], deg=180)\n            ```\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n        self.frames = None\n        self.rigid = None\n        self.minimizer = None\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.methylate","title":"<code>methylate(methylations=[], CpG=False, leading_strand=0, frame=-1)</code>","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <p>Using the <code>CpG</code> flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list. Cached frame/rigid/minimization state is cleared after methylation.</p> Example <p>Methylate DNA <pre><code>dna = mdna.make('GCGCGCGAGCGA)\ndna.metyhlate(fliplist=[3,4])\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            Using the `CpG` flag will methylate the CpG sites in the DNA structure. This flag supercedes the methylations list.\n            Cached frame/rigid/minimization state is cleared after methylation.\n\n        Example:\n            Methylate DNA\n            ```python\n            dna = mdna.make('GCGCGCGAGCGA)\n            dna.metyhlate(fliplist=[3,4])\n            ```\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(methylations) == 0 and not CpG:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n        self.frames = None\n        self.rigid = None\n        self.minimizer = None\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.extend","title":"<code>extend(n_bp=None, sequence=None, fixed_endpoints=False, forward=True, frame=-1, shape=None, margin=1, minimize=True, plot=False, exvol_rad=2.0, temperature=300)</code>","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure. Defaults to None.</p> <code>None</code> <code>sequence</code> <code>str or List</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <code>plot</code> <code>bool</code> <p>Whether to plot the Energy during minmization. Defaults to False.</p> <code>False</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults</p> <code>300</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> </ul> Example <p>Extend DNA structure <pre><code>nuc = mdna.make(n_bp=100)\nnuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n</code></pre></p> Source code in <code>mdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int = None, sequence: Union[str|List] = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True, plot : bool = False, exvol_rad : float = 2.0, temperature : int = 300):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure. Defaults to None.\n        sequence (str or List, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n        plot (bool, optional): Whether to plot the Energy during minmization. Defaults to False.\n        exvol_rad (float, optional): Excluded volume radius. Defaults to 2.0.\n        temperature (int, optional): Temperature for equilibration. Defaults\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n\n    Example:\n        Extend DNA structure\n        ```python\n        nuc = mdna.make(n_bp=100)\n        nuc.extend(n_bp=10, forward=True, margin=2, minimize=True)\n        ```\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')  \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints, plot=plot, exvol_rad=exvol_rad, temperature=temperature)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.invert","title":"<code>invert()</code>","text":"<p>Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5 The method updates attributes of the DNA object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Not implemented yet.</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def invert(self):\n    \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n     The method updates attributes of the DNA object.\n\n     Raises:\n        NotImplementedError: Not implemented yet.\n    \"\"\"\n    raise NotImplementedError('Not implemented yet')\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.get_MC_traj","title":"<code>get_MC_traj()</code>","text":"<p>Get the MC sampling energy minimization trajectory of the new spline.</p> Source code in <code>mdna/nucleic.py</code> <pre><code>def get_MC_traj(self):\n    \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n    if self.minimizer is None:\n        raise ValueError('Run minimization first')\n    return self.minimizer.get_MC_traj()\n</code></pre>"},{"location":"api/nucleic/#mdna.nucleic.Nucleic.save_pdb","title":"<code>save_pdb(filename=None, frame=-1)</code>","text":"<p>Save the DNA structure as a pdb file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename to save the pdb file. Defaults to None.</p> <code>None</code> <code>frame</code> <code>int</code> <p>If the trajectory has multiple frames, specify the frame to save. Defaults to -1.</p> <code>-1</code> Source code in <code>mdna/nucleic.py</code> <pre><code>def save_pdb(self, filename : str = None, frame : int = -1):\n    \"\"\"Save the DNA structure as a pdb file.\n\n    Args:\n        filename (str, optional): Filename to save the pdb file. Defaults to None.\n        frame (int, optional): If the trajectory has multiple frames, specify the frame to save. Defaults to -1.\n    \"\"\"\n\n    # check if traj\n    if self.traj is None:\n        self._frames_to_traj()\n    if filename is None:\n        filename = 'my_mdna'\n    self.traj[frame].save(f'{filename}.pdb')\n</code></pre>"},{"location":"api/shapes/","title":"Shapes","text":"<p>Factory class providing predefined DNA shape control points.</p>"},{"location":"api/shapes/#mdna.utils.Shapes","title":"<code>mdna.utils.Shapes</code>","text":"<p>Factory for parametric 3-D curves used as DNA path control points.</p> <p>Each class method returns an <code>(n, 3)</code> array of points tracing a named shape that can be passed directly to :class:<code>~mdna.SplineFrames</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>class Shapes:\n    \"\"\"Factory for parametric 3-D curves used as DNA path control points.\n\n    Each class method returns an ``(n, 3)`` array of points tracing a named\n    shape that can be passed directly to :class:`~mdna.SplineFrames`.\n    \"\"\"\n\n    def __init__(self, parametric_function, t_values=None, num_points=100):\n        \"\"\"Initialize a Shapes instance from a parametric function.\n\n        Args:\n            parametric_function (callable): ``f(t) -&gt; (x, y, z)``.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n        \"\"\"\n        self.num_points = num_points\n        self.parametric_function = parametric_function\n        self.points = self._generate_points(t_values)\n\n    def _generate_points(self,t_values=None):\n        x_values, y_values, z_values = self.parametric_function(t_values)\n        return np.stack((x_values, y_values, z_values), axis=1)\n\n    @classmethod\n    def circle(cls, radius=1, t_values=None, num_points=100):\n        \"\"\"Create a circle in 3D space.\n\n        Args:\n            radius (float): Radius of the circle.\n            t_values (numpy.ndarray, optional): Parameter values; defaults\n                to ``linspace(0, 2\u03c0, num_points)``.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the circle, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * np.cos(t_values),\n            radius * np.sin(t_values),\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def line(cls, length=1, num_points=100):\n        \"\"\"Create a straight line along the x-axis.\n\n        Args:\n            length (float): Length of the line.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the line, shape ``(num_points, 3)``.\n        \"\"\"\n        t_values = np.linspace(0, 1, num=num_points)\n        parametric_function = lambda t_values: (\n            t_values * length,\n            np.zeros_like(t_values),\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def helix(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n        \"\"\"Create a helical curve.\n\n        Args:\n            radius (float): Helix radius.\n            pitch (float): Pitch factor (rise per turn).\n            height (float): Overall height scaling.\n            num_turns (int): Number of helical turns.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the helix, shape ``(num_points, 3)``.\n        \"\"\"\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * np.cos(t_values),\n            radius * np.sin(t_values),\n            height * t_values / (2 * np.pi) - pitch * num_turns * t_values / (2 * np.pi)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def spiral(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n        \"\"\"Create an expanding spiral (radius grows with *t*).\n\n        Args:\n            radius (float): Initial radius scaling.\n            pitch (float): Pitch factor.\n            height (float): Height scaling.\n            num_turns (int): Number of turns.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the spiral, shape ``(num_points, 3)``.\n        \"\"\"\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * t_values * np.cos(t_values),\n            radius * t_values * np.sin(t_values),\n            height * t_values / (2 * np.pi) * pitch\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def mobius_strip(cls, radius=1, width=0.5, num_twists=1, t_values=None, num_points=100):\n        \"\"\"Create a M\u00f6bius strip centre-line.\n\n        Args:\n            radius (float): Major radius of the strip.\n            width (float): Half-width of the strip.\n            num_twists (int): Number of half-twists.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the M\u00f6bius strip, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        u_values = np.linspace(0, width, num=num_points)\n        u, t = np.meshgrid(u_values, t_values)\n        x_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.cos(t)\n        y_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.sin(t)\n        z_values = u * np.sin(t / 2) * np.cos(num_twists * t)\n        parametric_function = lambda t_values: (\n            x_values.flatten(),\n            y_values.flatten(),\n            z_values.flatten()\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def square(cls, side_length=1,t_values=None,num_points=100):\n        \"\"\"Create a square path (first definition \u2014 piecewise).\n\n        Args:\n            side_length (float): Length of each side.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the square, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 1, num=num_points)\n        parametric_function = lambda t_values: (\n            side_length * (2 * (t_values &lt; 0.25) - 1),\n            side_length * (2 * (t_values &gt;= 0.25) &amp; (t_values &lt; 0.5)) - side_length,\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def trefoil(cls, radius=1, num_turns=1,t_values=None,num_points=100):\n        \"\"\"Create a trefoil knot.\n\n        Args:\n            radius (float): Scaling factor.\n            num_turns (int): Number of traversals around the knot.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the trefoil knot, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        x_values = np.sin(t_values) + 2 * np.sin(2 * t_values)\n        y_values = np.cos(t_values) - 2 * np.cos(2 * t_values)\n        z_values = -np.sin(3 * t_values)\n        parametric_function = lambda t_values: (\n            radius * x_values,\n            radius * y_values,\n            radius * z_values\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def square(cls, side=1, t_values=None,num_points=100):\n        \"\"\"Create a square path (segment-wise construction).\n\n        Args:\n            side (float): Length of each side.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the square, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 4, num=num_points)\n        # Calculate x and y coordinates based on t_values\n        x_values = np.zeros_like(t_values)\n        y_values = np.zeros_like(t_values)\n        for i, t in enumerate(t_values):\n            if 0 &lt;= t &lt; 1:\n                x_values[i] = t * side\n                y_values[i] = 0\n            elif 1 &lt;= t &lt; 2:\n                x_values[i] = side\n                y_values[i] = (t - 1) * side\n            elif 2 &lt;= t &lt; 3:\n                x_values[i] = (3 - t) * side\n                y_values[i] = side\n            elif 3 &lt;= t &lt;= 4:\n                x_values[i] = 0\n                y_values[i] = (4 - t) * side\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (\n            x_values,\n            y_values,\n            z_values\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def heart(cls, a=1, b=1, c=1,t_values=None,num_points=100):\n        \"\"\"Create a heart-shaped curve.\n\n        Args:\n            a (float): Amplitude of the x-component.\n            b (float): Amplitude of the first cosine term.\n            c (float): Amplitude of the second cosine term.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the heart shape, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(-np.pi, np.pi, num=num_points)\n        x_values = a * np.sin(t_values) ** 3\n        y_values = b * np.cos(t_values) - c * np.cos(2 * t_values)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def ellipse(cls, a=1, b=1, t_values=None,num_points=100):\n        \"\"\"Create an ellipse in the xy-plane.\n\n        Args:\n            a (float): Semi-major axis (x).\n            b (float): Semi-minor axis (y).\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the ellipse, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        x_values = a * np.cos(t_values)\n        y_values = b * np.sin(t_values)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def lemniscate_of_bernoulli(cls, a=1, b=1, t_values=None,num_points=100):\n        \"\"\"Create a lemniscate of Bernoulli (figure-eight curve).\n\n        Args:\n            a (float): x-scaling factor.\n            b (float): y-scaling factor.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the lemniscate, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        x_values = a * np.sqrt(2) * np.cos(t_values) / (np.sin(t_values) ** 2 + 1)\n        y_values = b * np.sqrt(2) * np.cos(t_values) * np.sin(t_values) / (np.sin(t_values) ** 2 + 1)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def torus_helix(cls, R=1, r=2, num_windings=3, t_values=None, num_points=100):\n        \"\"\"Create a helix wound around a torus.\n\n        Args:\n            R (float): Major radius of the torus.\n            r (float): Minor radius (tube radius).\n            num_windings (int): Number of windings around the torus.\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the torus helix, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n\n        parametric_function = lambda t_values: (\n            (R + r * np.cos(num_windings*t_values)) * np.cos( t_values),\n            (R + r * np.cos(num_windings*t_values)) * np.sin( t_values),\n            r * np.sin(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def bonus(cls, t_values=None,num_points=100):\n        \"\"\"Create a bonus (Batman) shape.\n\n        Credit: https://www.geogebra.org/m/pH8wD3rW, Author: Simona Riva.\n\n        Args:\n            t_values (numpy.ndarray, optional): Parameter values.\n            num_points (int): Number of sample points.\n\n        Returns:\n            points (numpy.ndarray): Points on the bonus shape, shape ``(num_points, 3)``.\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        t = t_values\n        parametric_function = lambda t: (\n                                        -(721*np.sin(t))/4 + 196/3*np.sin(2*t) - 86/3*np.sin(3*t) - 131/2*np.sin(4*t) + 477/14*np.sin(5*t) \n                                        + 27*np.sin(6*t) - 29/2*np.sin(7*t) + 68/5*np.sin(8*t) + 1/10*np.sin(9*t) + 23/4*np.sin(10*t) \n                                        - 19/2*np.sin(12*t) - 85/21*np.sin(13*t) + 2/3*np.sin(14*t) + 27/5*np.sin(15*t) + 7/4*np.sin(16*t) \n                                        + 17/9*np.sin(17*t) - 4*np.sin(18*t) - 1/2*np.sin(19*t) + 1/6*np.sin(20*t) + 6/7*np.sin(21*t) \n                                        - 1/8*np.sin(22*t) + 1/3*np.sin(23*t) + 3/2*np.sin(24*t) + 13/5*np.sin(25*t) + np.sin(26*t) \n                                        - 2*np.sin(27*t) + 3/5*np.sin(28*t) - 1/5*np.sin(29*t) + 1/5*np.sin(30*t) + (2337*np.cos(t))/8 \n                                        - 43/5*np.cos(2*t) + 322/5*np.cos(3*t) - 117/5*np.cos(4*t) - 26/5*np.cos(5*t) - 23/3*np.cos(6*t) \n                                        + 143/4*np.cos(7*t) - 11/4*np.cos(8*t) - 31/3*np.cos(9*t) - 13/4*np.cos(10*t) - 9/2*np.cos(11*t) \n                                        + 41/20*np.cos(12*t) + 8*np.cos(13*t) + 2/3*np.cos(14*t) + 6*np.cos(15*t) + 17/4*np.cos(16*t) \n                                        - 3/2*np.cos(17*t) - 29/10*np.cos(18*t) + 11/6*np.cos(19*t) + 12/5*np.cos(20*t) + 3/2*np.cos(21*t) \n                                        + 11/12*np.cos(22*t) - 4/5*np.cos(23*t) + np.cos(24*t) + 17/8*np.cos(25*t) - 7/2*np.cos(26*t) \n                                        - 5/6*np.cos(27*t) - 11/10*np.cos(28*t) + 1/2*np.cos(29*t) - 1/5*np.cos(30*t),\n                                        -(637/2)*np.sin(t) - (188/5)*np.sin(2*t) - (11/7)*np.sin(3*t) - (12/5)*np.sin(4*t) + (11/3)*np.sin(5*t)\n                                        - (37/4)*np.sin(6*t) + (8/3)*np.sin(7*t) + (65/6)*np.sin(8*t) - (32/5)*np.sin(9*t) - (41/4)*np.sin(10*t)\n                                        - (38/3)*np.sin(11*t) - (47/8)*np.sin(12*t) + (5/4)*np.sin(13*t) - (41/7)*np.sin(14*t) - (7/3)*np.sin(15*t)\n                                        - (13/7)*np.sin(16*t) + (17/4)*np.sin(17*t) - (9/4)*np.sin(18*t) + (8/9)*np.sin(19*t) + (3/5)*np.sin(20*t)\n                                        - (2/5)*np.sin(21*t) + (4/3)*np.sin(22*t) + (1/3)*np.sin(23*t) + (3/5)*np.sin(24*t) - (3/5)*np.sin(25*t)\n                                        + (6/5)*np.sin(26*t) - (1/5)*np.sin(27*t) + (10/9)*np.sin(28*t) + (1/3)*np.sin(29*t) - (3/4)*np.sin(30*t)\n                                        - (125/2)*np.cos(t) - (521/9)*np.cos(2*t) - (359/3)*np.cos(3*t) + (47/3)*np.cos(4*t) - (33/2)*np.cos(5*t)\n                                        - (5/4)*np.cos(6*t) + (31/8)*np.cos(7*t) + (9/10)*np.cos(8*t) - (119/4)*np.cos(9*t) - (17/2)*np.cos(10*t)\n                                        + (22/3)*np.cos(11*t) + (15/4)*np.cos(12*t) - (5/2)*np.cos(13*t) + (19/6)*np.cos(14*t) + (7/4)*np.cos(15*t)\n                                        + (31/4)*np.cos(16*t) - np.cos(17*t) + (11/10)*np.cos(18*t) - (2/3)*np.cos(19*t) + (13/3)*np.cos(20*t)\n                                        - (5/4)*np.cos(21*t) + (2/3)*np.cos(22*t) + (1/4)*np.cos(23*t) + (5/6)*np.cos(24*t) + (3/4)*np.cos(26*t)\n                                        - (1/2)*np.cos(27*t) - (1/10)*np.cos(28*t) - (1/3)*np.cos(29*t) - (1/19)*np.cos(30*t),\n                                        np.zeros_like(t))\n        return cls(parametric_function, t_values).points*0.1\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.__init__","title":"<code>__init__(parametric_function, t_values=None, num_points=100)</code>","text":"<p>Initialize a Shapes instance from a parametric function.</p> <p>Parameters:</p> Name Type Description Default <code>parametric_function</code> <code>callable</code> <p><code>f(t) -&gt; (x, y, z)</code>.</p> required <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> Source code in <code>mdna/utils.py</code> <pre><code>def __init__(self, parametric_function, t_values=None, num_points=100):\n    \"\"\"Initialize a Shapes instance from a parametric function.\n\n    Args:\n        parametric_function (callable): ``f(t) -&gt; (x, y, z)``.\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n    \"\"\"\n    self.num_points = num_points\n    self.parametric_function = parametric_function\n    self.points = self._generate_points(t_values)\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.bonus","title":"<code>bonus(t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a bonus (Batman) shape.</p> <p>Credit: https://www.geogebra.org/m/pH8wD3rW, Author: Simona Riva.</p> <p>Parameters:</p> Name Type Description Default <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the bonus shape, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef bonus(cls, t_values=None,num_points=100):\n    \"\"\"Create a bonus (Batman) shape.\n\n    Credit: https://www.geogebra.org/m/pH8wD3rW, Author: Simona Riva.\n\n    Args:\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the bonus shape, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    t = t_values\n    parametric_function = lambda t: (\n                                    -(721*np.sin(t))/4 + 196/3*np.sin(2*t) - 86/3*np.sin(3*t) - 131/2*np.sin(4*t) + 477/14*np.sin(5*t) \n                                    + 27*np.sin(6*t) - 29/2*np.sin(7*t) + 68/5*np.sin(8*t) + 1/10*np.sin(9*t) + 23/4*np.sin(10*t) \n                                    - 19/2*np.sin(12*t) - 85/21*np.sin(13*t) + 2/3*np.sin(14*t) + 27/5*np.sin(15*t) + 7/4*np.sin(16*t) \n                                    + 17/9*np.sin(17*t) - 4*np.sin(18*t) - 1/2*np.sin(19*t) + 1/6*np.sin(20*t) + 6/7*np.sin(21*t) \n                                    - 1/8*np.sin(22*t) + 1/3*np.sin(23*t) + 3/2*np.sin(24*t) + 13/5*np.sin(25*t) + np.sin(26*t) \n                                    - 2*np.sin(27*t) + 3/5*np.sin(28*t) - 1/5*np.sin(29*t) + 1/5*np.sin(30*t) + (2337*np.cos(t))/8 \n                                    - 43/5*np.cos(2*t) + 322/5*np.cos(3*t) - 117/5*np.cos(4*t) - 26/5*np.cos(5*t) - 23/3*np.cos(6*t) \n                                    + 143/4*np.cos(7*t) - 11/4*np.cos(8*t) - 31/3*np.cos(9*t) - 13/4*np.cos(10*t) - 9/2*np.cos(11*t) \n                                    + 41/20*np.cos(12*t) + 8*np.cos(13*t) + 2/3*np.cos(14*t) + 6*np.cos(15*t) + 17/4*np.cos(16*t) \n                                    - 3/2*np.cos(17*t) - 29/10*np.cos(18*t) + 11/6*np.cos(19*t) + 12/5*np.cos(20*t) + 3/2*np.cos(21*t) \n                                    + 11/12*np.cos(22*t) - 4/5*np.cos(23*t) + np.cos(24*t) + 17/8*np.cos(25*t) - 7/2*np.cos(26*t) \n                                    - 5/6*np.cos(27*t) - 11/10*np.cos(28*t) + 1/2*np.cos(29*t) - 1/5*np.cos(30*t),\n                                    -(637/2)*np.sin(t) - (188/5)*np.sin(2*t) - (11/7)*np.sin(3*t) - (12/5)*np.sin(4*t) + (11/3)*np.sin(5*t)\n                                    - (37/4)*np.sin(6*t) + (8/3)*np.sin(7*t) + (65/6)*np.sin(8*t) - (32/5)*np.sin(9*t) - (41/4)*np.sin(10*t)\n                                    - (38/3)*np.sin(11*t) - (47/8)*np.sin(12*t) + (5/4)*np.sin(13*t) - (41/7)*np.sin(14*t) - (7/3)*np.sin(15*t)\n                                    - (13/7)*np.sin(16*t) + (17/4)*np.sin(17*t) - (9/4)*np.sin(18*t) + (8/9)*np.sin(19*t) + (3/5)*np.sin(20*t)\n                                    - (2/5)*np.sin(21*t) + (4/3)*np.sin(22*t) + (1/3)*np.sin(23*t) + (3/5)*np.sin(24*t) - (3/5)*np.sin(25*t)\n                                    + (6/5)*np.sin(26*t) - (1/5)*np.sin(27*t) + (10/9)*np.sin(28*t) + (1/3)*np.sin(29*t) - (3/4)*np.sin(30*t)\n                                    - (125/2)*np.cos(t) - (521/9)*np.cos(2*t) - (359/3)*np.cos(3*t) + (47/3)*np.cos(4*t) - (33/2)*np.cos(5*t)\n                                    - (5/4)*np.cos(6*t) + (31/8)*np.cos(7*t) + (9/10)*np.cos(8*t) - (119/4)*np.cos(9*t) - (17/2)*np.cos(10*t)\n                                    + (22/3)*np.cos(11*t) + (15/4)*np.cos(12*t) - (5/2)*np.cos(13*t) + (19/6)*np.cos(14*t) + (7/4)*np.cos(15*t)\n                                    + (31/4)*np.cos(16*t) - np.cos(17*t) + (11/10)*np.cos(18*t) - (2/3)*np.cos(19*t) + (13/3)*np.cos(20*t)\n                                    - (5/4)*np.cos(21*t) + (2/3)*np.cos(22*t) + (1/4)*np.cos(23*t) + (5/6)*np.cos(24*t) + (3/4)*np.cos(26*t)\n                                    - (1/2)*np.cos(27*t) - (1/10)*np.cos(28*t) - (1/3)*np.cos(29*t) - (1/19)*np.cos(30*t),\n                                    np.zeros_like(t))\n    return cls(parametric_function, t_values).points*0.1\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.circle","title":"<code>circle(radius=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a circle in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle.</p> <code>1</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values; defaults to <code>linspace(0, 2\u03c0, num_points)</code>.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the circle, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef circle(cls, radius=1, t_values=None, num_points=100):\n    \"\"\"Create a circle in 3D space.\n\n    Args:\n        radius (float): Radius of the circle.\n        t_values (numpy.ndarray, optional): Parameter values; defaults\n            to ``linspace(0, 2\u03c0, num_points)``.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the circle, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * np.cos(t_values),\n        radius * np.sin(t_values),\n        np.zeros_like(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.ellipse","title":"<code>ellipse(a=1, b=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create an ellipse in the xy-plane.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Semi-major axis (x).</p> <code>1</code> <code>b</code> <code>float</code> <p>Semi-minor axis (y).</p> <code>1</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the ellipse, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef ellipse(cls, a=1, b=1, t_values=None,num_points=100):\n    \"\"\"Create an ellipse in the xy-plane.\n\n    Args:\n        a (float): Semi-major axis (x).\n        b (float): Semi-minor axis (y).\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the ellipse, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    x_values = a * np.cos(t_values)\n    y_values = b * np.sin(t_values)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.heart","title":"<code>heart(a=1, b=1, c=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a heart-shaped curve.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Amplitude of the x-component.</p> <code>1</code> <code>b</code> <code>float</code> <p>Amplitude of the first cosine term.</p> <code>1</code> <code>c</code> <code>float</code> <p>Amplitude of the second cosine term.</p> <code>1</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the heart shape, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef heart(cls, a=1, b=1, c=1,t_values=None,num_points=100):\n    \"\"\"Create a heart-shaped curve.\n\n    Args:\n        a (float): Amplitude of the x-component.\n        b (float): Amplitude of the first cosine term.\n        c (float): Amplitude of the second cosine term.\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the heart shape, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(-np.pi, np.pi, num=num_points)\n    x_values = a * np.sin(t_values) ** 3\n    y_values = b * np.cos(t_values) - c * np.cos(2 * t_values)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.helix","title":"<code>helix(radius=1, pitch=1, height=1, num_turns=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a helical curve.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Helix radius.</p> <code>1</code> <code>pitch</code> <code>float</code> <p>Pitch factor (rise per turn).</p> <code>1</code> <code>height</code> <code>float</code> <p>Overall height scaling.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>Number of helical turns.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the helix, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef helix(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n    \"\"\"Create a helical curve.\n\n    Args:\n        radius (float): Helix radius.\n        pitch (float): Pitch factor (rise per turn).\n        height (float): Overall height scaling.\n        num_turns (int): Number of helical turns.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the helix, shape ``(num_points, 3)``.\n    \"\"\"\n    t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * np.cos(t_values),\n        radius * np.sin(t_values),\n        height * t_values / (2 * np.pi) - pitch * num_turns * t_values / (2 * np.pi)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.lemniscate_of_bernoulli","title":"<code>lemniscate_of_bernoulli(a=1, b=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a lemniscate of Bernoulli (figure-eight curve).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>x-scaling factor.</p> <code>1</code> <code>b</code> <code>float</code> <p>y-scaling factor.</p> <code>1</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the lemniscate, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef lemniscate_of_bernoulli(cls, a=1, b=1, t_values=None,num_points=100):\n    \"\"\"Create a lemniscate of Bernoulli (figure-eight curve).\n\n    Args:\n        a (float): x-scaling factor.\n        b (float): y-scaling factor.\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the lemniscate, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    x_values = a * np.sqrt(2) * np.cos(t_values) / (np.sin(t_values) ** 2 + 1)\n    y_values = b * np.sqrt(2) * np.cos(t_values) * np.sin(t_values) / (np.sin(t_values) ** 2 + 1)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.line","title":"<code>line(length=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a straight line along the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>Length of the line.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the line, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef line(cls, length=1, num_points=100):\n    \"\"\"Create a straight line along the x-axis.\n\n    Args:\n        length (float): Length of the line.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the line, shape ``(num_points, 3)``.\n    \"\"\"\n    t_values = np.linspace(0, 1, num=num_points)\n    parametric_function = lambda t_values: (\n        t_values * length,\n        np.zeros_like(t_values),\n        np.zeros_like(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.mobius_strip","title":"<code>mobius_strip(radius=1, width=0.5, num_twists=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a M\u00f6bius strip centre-line.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Major radius of the strip.</p> <code>1</code> <code>width</code> <code>float</code> <p>Half-width of the strip.</p> <code>0.5</code> <code>num_twists</code> <code>int</code> <p>Number of half-twists.</p> <code>1</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the M\u00f6bius strip, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef mobius_strip(cls, radius=1, width=0.5, num_twists=1, t_values=None, num_points=100):\n    \"\"\"Create a M\u00f6bius strip centre-line.\n\n    Args:\n        radius (float): Major radius of the strip.\n        width (float): Half-width of the strip.\n        num_twists (int): Number of half-twists.\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the M\u00f6bius strip, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    u_values = np.linspace(0, width, num=num_points)\n    u, t = np.meshgrid(u_values, t_values)\n    x_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.cos(t)\n    y_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.sin(t)\n    z_values = u * np.sin(t / 2) * np.cos(num_twists * t)\n    parametric_function = lambda t_values: (\n        x_values.flatten(),\n        y_values.flatten(),\n        z_values.flatten()\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.spiral","title":"<code>spiral(radius=1, pitch=1, height=1, num_turns=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create an expanding spiral (radius grows with t).</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Initial radius scaling.</p> <code>1</code> <code>pitch</code> <code>float</code> <p>Pitch factor.</p> <code>1</code> <code>height</code> <code>float</code> <p>Height scaling.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>Number of turns.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the spiral, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef spiral(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n    \"\"\"Create an expanding spiral (radius grows with *t*).\n\n    Args:\n        radius (float): Initial radius scaling.\n        pitch (float): Pitch factor.\n        height (float): Height scaling.\n        num_turns (int): Number of turns.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the spiral, shape ``(num_points, 3)``.\n    \"\"\"\n    t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * t_values * np.cos(t_values),\n        radius * t_values * np.sin(t_values),\n        height * t_values / (2 * np.pi) * pitch\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.square","title":"<code>square(side=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a square path (segment-wise construction).</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>float</code> <p>Length of each side.</p> <code>1</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the square, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef square(cls, side=1, t_values=None,num_points=100):\n    \"\"\"Create a square path (segment-wise construction).\n\n    Args:\n        side (float): Length of each side.\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the square, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 4, num=num_points)\n    # Calculate x and y coordinates based on t_values\n    x_values = np.zeros_like(t_values)\n    y_values = np.zeros_like(t_values)\n    for i, t in enumerate(t_values):\n        if 0 &lt;= t &lt; 1:\n            x_values[i] = t * side\n            y_values[i] = 0\n        elif 1 &lt;= t &lt; 2:\n            x_values[i] = side\n            y_values[i] = (t - 1) * side\n        elif 2 &lt;= t &lt; 3:\n            x_values[i] = (3 - t) * side\n            y_values[i] = side\n        elif 3 &lt;= t &lt;= 4:\n            x_values[i] = 0\n            y_values[i] = (4 - t) * side\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (\n        x_values,\n        y_values,\n        z_values\n    )\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.torus_helix","title":"<code>torus_helix(R=1, r=2, num_windings=3, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a helix wound around a torus.</p> <p>Parameters:</p> Name Type Description Default <code>R</code> <code>float</code> <p>Major radius of the torus.</p> <code>1</code> <code>r</code> <code>float</code> <p>Minor radius (tube radius).</p> <code>2</code> <code>num_windings</code> <code>int</code> <p>Number of windings around the torus.</p> <code>3</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the torus helix, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef torus_helix(cls, R=1, r=2, num_windings=3, t_values=None, num_points=100):\n    \"\"\"Create a helix wound around a torus.\n\n    Args:\n        R (float): Major radius of the torus.\n        r (float): Minor radius (tube radius).\n        num_windings (int): Number of windings around the torus.\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the torus helix, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n\n    parametric_function = lambda t_values: (\n        (R + r * np.cos(num_windings*t_values)) * np.cos( t_values),\n        (R + r * np.cos(num_windings*t_values)) * np.sin( t_values),\n        r * np.sin(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"api/shapes/#mdna.utils.Shapes.trefoil","title":"<code>trefoil(radius=1, num_turns=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a trefoil knot.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Scaling factor.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>Number of traversals around the knot.</p> <code>1</code> <code>t_values</code> <code>ndarray</code> <p>Parameter values.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of sample points.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Points on the trefoil knot, shape <code>(num_points, 3)</code>.</p> Source code in <code>mdna/utils.py</code> <pre><code>@classmethod\ndef trefoil(cls, radius=1, num_turns=1,t_values=None,num_points=100):\n    \"\"\"Create a trefoil knot.\n\n    Args:\n        radius (float): Scaling factor.\n        num_turns (int): Number of traversals around the knot.\n        t_values (numpy.ndarray, optional): Parameter values.\n        num_points (int): Number of sample points.\n\n    Returns:\n        points (numpy.ndarray): Points on the trefoil knot, shape ``(num_points, 3)``.\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    x_values = np.sin(t_values) + 2 * np.sin(2 * t_values)\n    y_values = np.cos(t_values) - 2 * np.cos(2 * t_values)\n    z_values = -np.sin(3 * t_values)\n    parametric_function = lambda t_values: (\n        radius * x_values,\n        radius * y_values,\n        radius * z_values\n    )\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"api/spline/","title":"SplineFrames","text":"<p>Generates reference frames along a 3D spline path for DNA construction.</p>"},{"location":"api/spline/#mdna.spline.SplineFrames","title":"<code>mdna.spline.SplineFrames</code>","text":"Source code in <code>mdna/spline.py</code> <pre><code>class SplineFrames:\n\n    def __init__(self, control_points, degree=3, closed=False, up_vector=[0, 0, 1],frame_spacing=0.34, twist=True, bp_per_turn=10.5, frame_tolerance=0.5, verbose=False, num_points=1000, initial_frame=None, modified_ranges=[],n_bp=None,dLk=None):\n        \"\"\"Initialize a spline path with Bishop-frame coordinate systems.\n\n        The spline is fitted to the control points, evenly-spaced frames are\n        placed along the arc length, continuity is verified, and an optional\n        twist is applied.\n\n        Args:\n            control_points (numpy.ndarray): 3-D control points, shape ``(n, 3)``.\n            degree (int): B-spline degree (1\u20135).\n            closed (bool): If True, close the spline into a loop.\n            up_vector (list or numpy.ndarray): Reference up direction for\n                initial frame orientation.\n            frame_spacing (float): Target arc-length distance between frames\n                (nm).  Defaults to 0.34 nm (one base-pair rise).\n            twist (bool): Apply a helical twist to the frames.\n            bp_per_turn (float): Base pairs per helical turn (default 10.5).\n            frame_tolerance (float): Maximum allowed angular deviation when\n                testing frame continuity.\n            verbose (bool): Print diagnostic messages.\n            num_points (int): Number of spline evaluation points for internal\n                interpolation.\n            initial_frame (tuple or numpy.ndarray, optional): Explicit initial\n                frame ``(origin, d1, d2, d3)`` to align the first frame.\n            modified_ranges (list): List of ``(start, end, twist_angle)`` tuples\n                specifying local twist modifications.\n            n_bp (int, optional): Desired number of base pairs.  When set, the\n                spline is rescaled to match this count.\n            dLk (int, optional): Change in linking number applied via uniform\n                twist redistribution.\n        \"\"\"\n        self.control_points = control_points\n        self.n = num_points\n        self.twist = twist\n        self.degree = degree\n        self.closed = closed\n        self.up_vector = np.array(up_vector)\n        self.frame_spacing = frame_spacing\n        self.bp_per_turn = bp_per_turn\n        self.n_bp = n_bp\n        self.dLk = dLk\n        self.frame_tolerance = frame_tolerance\n        self.initial_frame = initial_frame  # Added variable for the initial frame if we need to align the first frame with a given frame\n        self.tck = None\n        self.curve = None\n        self.der1 = None\n        self.der2 = None\n        self.arc_length = None\n        self.point_indices = None\n        self.frames = []\n        self.verbose = verbose\n        self._initialize_spline()\n        self._evaluate_spline()\n        self.distribute_points()\n        self.test_frames()\n\n        if self.n_bp is not None:\n            print(f\"\"\"\\nStart rescaling spline based on requested number of base pairs.\\n\\tThis requires recomputation of the control points to match the desired number of base pairs.\"\"\")\n            self._scale_to_nbp()\n        else:\n            self.n_bp = self.frames.shape[0]\n\n        if self.twist:\n            self.twist_frames(modified_ranges=modified_ranges)\n\n    def update_initial_frame(self, initial_frame) -&gt; 'SplineFrames':\n        \"\"\"\n        Updates the initial frame.\n\n        Args:\n            initial_frame (tuple): Tuple containing the position, right, up, and forward vectors of the frame.\n\n        Returns:\n            SplineFrames: The updated instance.\n        \"\"\"\n        self.initial_frame = initial_frame\n        self._compute_frames()\n        return self\n\n    def update_control_points(self, control_points) -&gt; None:\n        \"\"\"\n        Updates the control points defining the path.\n\n        Args:\n            control_points (numpy.ndarray): Control points defining the path.\n        \"\"\"\n        self.control_points = control_points\n        self.frames = []\n        self._initialize_spline()\n        self._evaluate_spline()\n        self.distribute_points()\n        self.test_frames()\n        # return self\n\n    def update_spline_degree(self, degree) -&gt; 'SplineFrames':\n        \"\"\"\n        Updates the degree of the spline.\n\n        Args:\n            degree (int): Degree of the spline.\n\n        Returns:\n            SplineFrames: The updated instance.\n        \"\"\"\n        self.degree = degree\n        self._initialize_spline()\n        self._evaluate_spline()\n        return self\n\n    def update_closed(self, closed) -&gt; 'SplineFrames':\n        \"\"\"\n        Updates the closed property indicating if the path is closed.\n\n        Args:\n            closed (bool): Indicates if the path is closed.\n\n        Returns:\n            SplineFrames: The updated instance.\n        \"\"\"\n        self.closed = closed\n        self._initialize_spline()\n        self._evaluate_spline()\n        return self\n\n    def update_up_vector(self, up_vector) -&gt; 'SplineFrames':\n        \"\"\"\n        Updates the up vector used for frame computation. Not used at the moment.\n\n        Args:\n            up_vector (list or numpy.ndarray): Up vector for frame computation.\n\n        Returns:\n            SplineFrames: The updated instance.\n        \"\"\"\n        self.up_vector = np.array(up_vector)\n        self._compute_frames()\n        return self\n\n    def _initialize_spline(self) -&gt; 'SplineFrames':\n        \"\"\"\n        Initializes the spline with the control points.\n\n        Returns:\n            SplineFrames: The initialized instance.\n        \"\"\"\n        if self.verbose:\n            print(\"Initializing spline\")\n        control_points = self.control_points\n        # if self.closed:\n        #     control_points = np.vstack((self.control_points, self.control_points[0]))\n\n        #     # Calculate tangent vectors at the first and last control points\n        #     t_first = self.control_points[1] - self.control_points[0]\n        #     t_last = self.control_points[-1] - self.control_points[-2]\n\n        #     # Adjust the control points to ensure consistent tangent directions\n        #     if np.dot(t_first, t_last) &lt; 0:\n        #         control_points[-1] = control_points[-1] * -1\n\n        tck, _ = splprep(control_points.T, s=0, k=self.degree)#, per=self.closed)\n        self.tck = tck\n        return self\n\n    def _evaluate_spline(self) -&gt; 'SplineFrames':\n        \"\"\"\n        Evaluates the spline curve and its derivatives.\n\n        Returns:\n            SplineFrames: The evaluated instance with ``curve``, ``der1``, and ``arc_length`` attributes set.\n        \"\"\"\n        if self.verbose:\n            print(\"Evaluating spline\")\n        dt = 1 / self.n\n        self.v = np.arange(0, 1 + dt, dt)\n        self.curve = np.array(splev(self.v, self.tck)).T\n        self.der1 = np.array(splev(self.v, self.tck, der=1)).T\n        if self.verbose:\n            print(\"Calculating arc length\")\n        # Calculate the arc length of the spline\n        arc_diffs = np.diff(self.curve, axis=0)\n\n        arc = np.sqrt((arc_diffs**2).sum(axis=1))\n        self.arc_length = np.hstack([0, cumulative_trapezoid(arc)])\n        return self\n\n    def distribute_points(self) -&gt; 'SplineFrames':\n        \"\"\"\n        Distributes equidistant points along the spline and evaluates the derivatives\n        at these points. Adjusts the spacing to match the first and last points of the spline.\n\n        Returns:\n            SplineFrames: The instance with ``positions`` and ``derivatives`` attributes set.\n\n        Raises:\n            ValueError: If a suitable segment length cannot be found within the tolerance.\n        \"\"\"\n\n        # Calculate the new segment length within the specified tolerance\n        adjusted_arc_length = self.arc_length[-1] - self.frame_spacing  # Subtract the first and last segments\n        num_segments = np.round(adjusted_arc_length / self.frame_spacing)\n        new_segment_length = adjusted_arc_length / num_segments\n\n        # If the new segment length is within the tolerance, proceed with the distribution\n        if abs(new_segment_length - self.frame_spacing) &lt;= self.frame_tolerance:\n            self.segment_lengths = np.linspace(new_segment_length, adjusted_arc_length, int(num_segments))\n\n            # Including the first and last points (and not the last segment if closed topology)\n            self.t_values = [0] + list(np.interp(self.segment_lengths, self.arc_length, self.v[:len(self.arc_length)]))\n            if not self.closed:\n                self.t_values += [1] \n\n            if self.verbose:\n                print(f\"Evenly distributing {len(self.t_values)} points along the spline and computing derivatives.\")\n\n            # Evaluate the spline and its derivatives at the reparametrized t values\n            equidistant_points = np.array(splev(self.t_values, self.tck)).T\n            # Use difference vectors of equidistant points to calculate the derivatives\n            derivatives = np.diff(equidistant_points, axis=0)\n            #print(derivatives.shape,equidistant_points.shape)\n            # Add the last derivative to the end\n            derivatives = np.vstack([derivatives, derivatives[-1]])\n            # Last point some numerical error that inverts the direction of the last point? Need to do more testing...\n            #derivatives = np.array(splev(self.t_values, self.tck, der=1)).T\n        else:\n            raise ValueError(f\"Cannot find a suitable segment length within the tolerance of {self.frame_tolerance} nm rise.\")\n\n        # Store or return the results\n        self.positions = equidistant_points\n        self.derivatives = derivatives\n        # Assuming self._compute_frames() updates self with the new frames\n        self._compute_frames()\n        return self\n\n    def rotation_matrix_from_vectors(self,vec1, vec2):\n        \"\"\" Find the rotation matrix that aligns vec1 to vec2 \"\"\"\n        a, b = (vec1 / np.linalg.norm(vec1)).reshape(3), (vec2 / np.linalg.norm(vec2)).reshape(3)\n        v = np.cross(a, b)\n        c = np.dot(a, b)\n        s = np.linalg.norm(v)\n        kmat = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n        rotation_matrix = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s ** 2))\n        return rotation_matrix\n\n    def _compute_initial_frame(self):\n        # Compute the initial frame based on the first derivative and up_vector\n        T = self.derivatives[0] / np.linalg.norm(self.derivatives[0])\n        N = np.cross(T, self.up_vector)\n        if np.linalg.norm(N) &lt; 1e-6: # Fallback if T and up_vector are parallel\n            N = np.cross(T, np.array([1, 0, 0]) if abs(T[2]) &lt; 0.9 else np.array([0, 1, 0]))\n        N = N / np.linalg.norm(N)\n        B = np.cross(T,N)\n        #print('det initial frame',np.linalg.det(np.array([T,N,B])))\n        self.frames.append((self.positions[0], N, B, T))\n        #self.frames.append((self.positions[0], T, N, B))\n\n    def _slide_frames(self):\n        \"\"\"\n        Compute the coordinate frames along the curve by sliding the frame from the previous position to the current position.\n\n        This method iterates through each position along the curve and computes the coordinate frame (position, T', N', B') at each position.\n        The tangent vector (T') is computed as the normalized first derivative of the curve at the current position.\n        The normal vector (N') is computed by rotating the previous normal vector (N) using the computed axis and angle.\n        The binormal vector (B') is computed as the cross product of T' and N'.\n        The computed coordinate frames are stored in the `frames` list for later use.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Iterate through each position along the curve, starting from the second position\n        for i in range(1, len(self.positions)):\n            # Get the last tangent vector (T) from the previously computed frames\n            T_prev = self.frames[-1][3]  \n            # Compute the new tangent vector (T') analytically as the normalized first derivative of the curve at the current position\n            T = self.derivatives[i] / np.linalg.norm(self.derivatives[i])\n\n            # Compute the axis of rotation as the normalized cross product of T and T', indicating the direction to rotate N to N'\n            axis = np.cross(T_prev, T)\n            # Check if the axis is significant to avoid division by zero and unnecessary rotation calculations\n            if np.linalg.norm(axis) &gt; 1e-6:\n                axis = axis / np.linalg.norm(axis)  # Normalize the axis to ensure it has unit length\n                # Compute the angle of rotation by the arccos of the dot product of T and T', clipped to [-1, 1] to avoid numerical issues\n                angle = np.arccos(np.clip(np.dot(T_prev, T), -1.0, 1.0))\n                # Rotate the normal vector (N) using the computed axis and angle to find the new normal vector (N')\n                N = RigidBody.rotate_vector(self.frames[-1][1], axis, angle)\n            else:\n                # If the axis of rotation is negligible, use the previous normal vector (N) without rotation\n                N = self.frames[-1][1]\n\n            # Compute the binormal vector (B') as the cross product of T' and N', completing the coordinate frame\n            B = np.cross(T, N)\n            # Append the new coordinate frame (position, T', N', B') to the frames list for later use\n            # print('det slide:',i,np.linalg.det(np.array([T,N,B])))\n            self.frames.append((self.positions[i], N, B, T)) # original\n\n\n    def _compute_frames(self):\n        \"\"\"\n        Computes the coordinate frames on a spline with minimal torsion.\n        Source: https://jbrd.github.io/2011/06/19/computing-coordinate-frames-on-a-spline-with-minimal-torsion.html\n\n        \"\"\"\n        if self.initial_frame is not None:\n            # Directly use the provided custom initial frame\n            self.frames.append((self.positions[0], *self.initial_frame[1:]))\n        else:\n            # Compute the initial frame based on the first derivative and up_vector\n            self._compute_initial_frame()\n\n        # Compute frames for the rest of the points along the path\n        self._slide_frames()\n\n        # Convert the list of frames to a NumPy array for efficient storage and manipulation\n        self.frames = np.array(self.frames)\n        # # Swap the T and B vectors to match the expected order for the DNA generation\n        # self.frames[:, [1, 3]] = self.frames[:, [3, 1]] \n\n\n    def twist_frames(self, modified_ranges=[], plot=False):\n        self.twister = Twister(frames=self.frames, bp_per_turn=self.bp_per_turn, modified_ranges=modified_ranges, plot=plot, circular=self.closed,dLk=self.dLk)\n        # This can be a separate call if you don't want to twist immediately upon calling twist_frames\n        #self.twister._compute_and_plot_twists()\n\n    def _scale_to_nbp(self):\n        \"\"\"Recompute control points to scale the spline to match the number of base pairs\"\"\"\n\n        # Set the target number of base pairs, current number of base pairs, and total length of the spline\n        if self.closed:\n            target_bp = self.n_bp\n        else:\n            target_bp = self.n_bp - 1\n        current_n_bp = self.frames.shape[0]\n        total_length = self.arc_length[-1] \n\n        # Compute the ratio to scale the spline to match the target number of base pairs\n        ratio = target_bp*self.frame_spacing/total_length\n        new_control_points = self.control_points * ratio\n\n        # Update the control points and reinitialize the spline\n        self.update_control_points(new_control_points)  \n\n        # Check if the number of base pairs matches the target\n        if self.frames.shape[0] == self.n_bp:\n            print(f\"\\tSpline scaled to match the target number of base pairs: {self.n_bp}\\n\")\n        else:\n            print(f\"\\tError: Spline could not be scaled to match the target number of base pairs: {target_bp}\")\n            print(\"\\tNew number of base pairs:\", self.frames.shape[0])\n\n\n    def plot_frames(self, fig=False, equal_bounds=False, equal=True, spline=False, control_points=False, triads=True, transparent=False, legend=False) -&gt; None:\n        \"\"\"\n        Plots the frames along the spline.\n\n        Note:\n            This method needs to be called after the frames are computed.\n\n        Args:\n            fig (bool): If True, return the figure and axes objects instead of None.\n            equal_bounds (bool): If True, set equal axis bounds based on data extent.\n            equal (bool): If True, set equal aspect ratio on all axes.\n            spline (bool): If True, overlay the continuous spline curve.\n            control_points (bool): If True, plot the control points.\n            triads (bool): If True, draw the right/up/forward triads at each frame.\n            transparent (bool): If True, make the figure background transparent.\n            legend (bool): If True, suppress the automatic legend.\n        \"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n        if triads:\n            for frame in self.frames:\n                position, right, up, forward = frame\n                ax.quiver(*position, *right, length=0.2, color='g')\n                ax.quiver(*position, *up, length=0.2, color='b')\n                ax.quiver(*position, *forward, length=0.2, color='r')\n\n        _ = self.tck[0]  # Spline parameters for plotting\n        u = np.linspace(0, 1, 100)\n        spline_points = np.array(splev(u, self.tck)).T\n        if spline:\n            ax.plot(*spline_points.T, color='gray', label='Spline')\n        if equal_bounds:\n            # Compute bounds\n            all_points = np.vstack([spline_points, *[frame[0] for frame in self.frames]])\n            max_bound = np.max(np.abs(all_points))\n\n            ax.set_xlim([-max_bound, max_bound])\n            ax.set_ylim([-max_bound, max_bound])\n            ax.set_zlim([-max_bound, max_bound])\n        if control_points:\n            ax.scatter(*self.control_points.T, color='black', label='Control Points')\n        if equal:\n            ax.axis('equal')\n\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n\n        if spline or control_points:\n            if not legend:\n                ax.legend()\n\n\n\n        if transparent:\n            fig.patch.set_alpha(0)\n            ax.patch.set_alpha(0)\n            ax.grid(False)\n\n        if fig:\n            return fig, ax \n        else:\n            return None \n\n    def test_frames(self) -&gt; None:\n        \"\"\"\n        Tests the computed frames for correctness.\n\n        Checks consecutive frames for abrupt flips in the right and up vectors\n        and prints warnings when angle deviations exceed 90 degrees.\n        \"\"\"\n        for i in range(len(self.frames)-1):\n            frame1 = self.frames[i]\n            frame2 = self.frames[i+1]\n\n            right1, up1 = frame1[1:3]\n            right2, up2 = frame2[1:3]\n\n            # Check if right vectors have flipped\n            right_dot_product = np.dot(right1, right2)\n            if right_dot_product &lt; 0:\n                angle_deviation = np.degrees(np.arccos(np.clip(np.dot(right1, right2), -1.0, 1.0)))\n                print(f\"Warning: Right Vectors may have flipped. Frame {i+1} to Frame {i+2}. Angle Deviation: {angle_deviation:.2f} degrees\")\n\n            # Check if up vectors have flipped\n            up_dot_product = np.dot(up1, up2)\n            if up_dot_product &lt; 0:\n                angle_deviation = np.degrees(np.arccos(np.clip(np.dot(up1, up2), -1.0, 1.0)))\n                print(f\"Warning: Up Vectors may have flipped. Frame {i+1} to Frame {i+2}. Angle Deviation: {angle_deviation:.2f} degrees\")\n\n        return None\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.__init__","title":"<code>__init__(control_points, degree=3, closed=False, up_vector=[0, 0, 1], frame_spacing=0.34, twist=True, bp_per_turn=10.5, frame_tolerance=0.5, verbose=False, num_points=1000, initial_frame=None, modified_ranges=[], n_bp=None, dLk=None)</code>","text":"<p>Initialize a spline path with Bishop-frame coordinate systems.</p> <p>The spline is fitted to the control points, evenly-spaced frames are placed along the arc length, continuity is verified, and an optional twist is applied.</p> <p>Parameters:</p> Name Type Description Default <code>control_points</code> <code>ndarray</code> <p>3-D control points, shape <code>(n, 3)</code>.</p> required <code>degree</code> <code>int</code> <p>B-spline degree (1\u20135).</p> <code>3</code> <code>closed</code> <code>bool</code> <p>If True, close the spline into a loop.</p> <code>False</code> <code>up_vector</code> <code>list or ndarray</code> <p>Reference up direction for initial frame orientation.</p> <code>[0, 0, 1]</code> <code>frame_spacing</code> <code>float</code> <p>Target arc-length distance between frames (nm).  Defaults to 0.34 nm (one base-pair rise).</p> <code>0.34</code> <code>twist</code> <code>bool</code> <p>Apply a helical twist to the frames.</p> <code>True</code> <code>bp_per_turn</code> <code>float</code> <p>Base pairs per helical turn (default 10.5).</p> <code>10.5</code> <code>frame_tolerance</code> <code>float</code> <p>Maximum allowed angular deviation when testing frame continuity.</p> <code>0.5</code> <code>verbose</code> <code>bool</code> <p>Print diagnostic messages.</p> <code>False</code> <code>num_points</code> <code>int</code> <p>Number of spline evaluation points for internal interpolation.</p> <code>1000</code> <code>initial_frame</code> <code>tuple or ndarray</code> <p>Explicit initial frame <code>(origin, d1, d2, d3)</code> to align the first frame.</p> <code>None</code> <code>modified_ranges</code> <code>list</code> <p>List of <code>(start, end, twist_angle)</code> tuples specifying local twist modifications.</p> <code>[]</code> <code>n_bp</code> <code>int</code> <p>Desired number of base pairs.  When set, the spline is rescaled to match this count.</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in linking number applied via uniform twist redistribution.</p> <code>None</code> Source code in <code>mdna/spline.py</code> <pre><code>def __init__(self, control_points, degree=3, closed=False, up_vector=[0, 0, 1],frame_spacing=0.34, twist=True, bp_per_turn=10.5, frame_tolerance=0.5, verbose=False, num_points=1000, initial_frame=None, modified_ranges=[],n_bp=None,dLk=None):\n    \"\"\"Initialize a spline path with Bishop-frame coordinate systems.\n\n    The spline is fitted to the control points, evenly-spaced frames are\n    placed along the arc length, continuity is verified, and an optional\n    twist is applied.\n\n    Args:\n        control_points (numpy.ndarray): 3-D control points, shape ``(n, 3)``.\n        degree (int): B-spline degree (1\u20135).\n        closed (bool): If True, close the spline into a loop.\n        up_vector (list or numpy.ndarray): Reference up direction for\n            initial frame orientation.\n        frame_spacing (float): Target arc-length distance between frames\n            (nm).  Defaults to 0.34 nm (one base-pair rise).\n        twist (bool): Apply a helical twist to the frames.\n        bp_per_turn (float): Base pairs per helical turn (default 10.5).\n        frame_tolerance (float): Maximum allowed angular deviation when\n            testing frame continuity.\n        verbose (bool): Print diagnostic messages.\n        num_points (int): Number of spline evaluation points for internal\n            interpolation.\n        initial_frame (tuple or numpy.ndarray, optional): Explicit initial\n            frame ``(origin, d1, d2, d3)`` to align the first frame.\n        modified_ranges (list): List of ``(start, end, twist_angle)`` tuples\n            specifying local twist modifications.\n        n_bp (int, optional): Desired number of base pairs.  When set, the\n            spline is rescaled to match this count.\n        dLk (int, optional): Change in linking number applied via uniform\n            twist redistribution.\n    \"\"\"\n    self.control_points = control_points\n    self.n = num_points\n    self.twist = twist\n    self.degree = degree\n    self.closed = closed\n    self.up_vector = np.array(up_vector)\n    self.frame_spacing = frame_spacing\n    self.bp_per_turn = bp_per_turn\n    self.n_bp = n_bp\n    self.dLk = dLk\n    self.frame_tolerance = frame_tolerance\n    self.initial_frame = initial_frame  # Added variable for the initial frame if we need to align the first frame with a given frame\n    self.tck = None\n    self.curve = None\n    self.der1 = None\n    self.der2 = None\n    self.arc_length = None\n    self.point_indices = None\n    self.frames = []\n    self.verbose = verbose\n    self._initialize_spline()\n    self._evaluate_spline()\n    self.distribute_points()\n    self.test_frames()\n\n    if self.n_bp is not None:\n        print(f\"\"\"\\nStart rescaling spline based on requested number of base pairs.\\n\\tThis requires recomputation of the control points to match the desired number of base pairs.\"\"\")\n        self._scale_to_nbp()\n    else:\n        self.n_bp = self.frames.shape[0]\n\n    if self.twist:\n        self.twist_frames(modified_ranges=modified_ranges)\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.distribute_points","title":"<code>distribute_points()</code>","text":"<p>Distributes equidistant points along the spline and evaluates the derivatives at these points. Adjusts the spacing to match the first and last points of the spline.</p> <p>Returns:</p> Name Type Description <code>SplineFrames</code> <code>SplineFrames</code> <p>The instance with <code>positions</code> and <code>derivatives</code> attributes set.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a suitable segment length cannot be found within the tolerance.</p> Source code in <code>mdna/spline.py</code> <pre><code>def distribute_points(self) -&gt; 'SplineFrames':\n    \"\"\"\n    Distributes equidistant points along the spline and evaluates the derivatives\n    at these points. Adjusts the spacing to match the first and last points of the spline.\n\n    Returns:\n        SplineFrames: The instance with ``positions`` and ``derivatives`` attributes set.\n\n    Raises:\n        ValueError: If a suitable segment length cannot be found within the tolerance.\n    \"\"\"\n\n    # Calculate the new segment length within the specified tolerance\n    adjusted_arc_length = self.arc_length[-1] - self.frame_spacing  # Subtract the first and last segments\n    num_segments = np.round(adjusted_arc_length / self.frame_spacing)\n    new_segment_length = adjusted_arc_length / num_segments\n\n    # If the new segment length is within the tolerance, proceed with the distribution\n    if abs(new_segment_length - self.frame_spacing) &lt;= self.frame_tolerance:\n        self.segment_lengths = np.linspace(new_segment_length, adjusted_arc_length, int(num_segments))\n\n        # Including the first and last points (and not the last segment if closed topology)\n        self.t_values = [0] + list(np.interp(self.segment_lengths, self.arc_length, self.v[:len(self.arc_length)]))\n        if not self.closed:\n            self.t_values += [1] \n\n        if self.verbose:\n            print(f\"Evenly distributing {len(self.t_values)} points along the spline and computing derivatives.\")\n\n        # Evaluate the spline and its derivatives at the reparametrized t values\n        equidistant_points = np.array(splev(self.t_values, self.tck)).T\n        # Use difference vectors of equidistant points to calculate the derivatives\n        derivatives = np.diff(equidistant_points, axis=0)\n        #print(derivatives.shape,equidistant_points.shape)\n        # Add the last derivative to the end\n        derivatives = np.vstack([derivatives, derivatives[-1]])\n        # Last point some numerical error that inverts the direction of the last point? Need to do more testing...\n        #derivatives = np.array(splev(self.t_values, self.tck, der=1)).T\n    else:\n        raise ValueError(f\"Cannot find a suitable segment length within the tolerance of {self.frame_tolerance} nm rise.\")\n\n    # Store or return the results\n    self.positions = equidistant_points\n    self.derivatives = derivatives\n    # Assuming self._compute_frames() updates self with the new frames\n    self._compute_frames()\n    return self\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.plot_frames","title":"<code>plot_frames(fig=False, equal_bounds=False, equal=True, spline=False, control_points=False, triads=True, transparent=False, legend=False)</code>","text":"<p>Plots the frames along the spline.</p> Note <p>This method needs to be called after the frames are computed.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>bool</code> <p>If True, return the figure and axes objects instead of None.</p> <code>False</code> <code>equal_bounds</code> <code>bool</code> <p>If True, set equal axis bounds based on data extent.</p> <code>False</code> <code>equal</code> <code>bool</code> <p>If True, set equal aspect ratio on all axes.</p> <code>True</code> <code>spline</code> <code>bool</code> <p>If True, overlay the continuous spline curve.</p> <code>False</code> <code>control_points</code> <code>bool</code> <p>If True, plot the control points.</p> <code>False</code> <code>triads</code> <code>bool</code> <p>If True, draw the right/up/forward triads at each frame.</p> <code>True</code> <code>transparent</code> <code>bool</code> <p>If True, make the figure background transparent.</p> <code>False</code> <code>legend</code> <code>bool</code> <p>If True, suppress the automatic legend.</p> <code>False</code> Source code in <code>mdna/spline.py</code> <pre><code>def plot_frames(self, fig=False, equal_bounds=False, equal=True, spline=False, control_points=False, triads=True, transparent=False, legend=False) -&gt; None:\n    \"\"\"\n    Plots the frames along the spline.\n\n    Note:\n        This method needs to be called after the frames are computed.\n\n    Args:\n        fig (bool): If True, return the figure and axes objects instead of None.\n        equal_bounds (bool): If True, set equal axis bounds based on data extent.\n        equal (bool): If True, set equal aspect ratio on all axes.\n        spline (bool): If True, overlay the continuous spline curve.\n        control_points (bool): If True, plot the control points.\n        triads (bool): If True, draw the right/up/forward triads at each frame.\n        transparent (bool): If True, make the figure background transparent.\n        legend (bool): If True, suppress the automatic legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    if triads:\n        for frame in self.frames:\n            position, right, up, forward = frame\n            ax.quiver(*position, *right, length=0.2, color='g')\n            ax.quiver(*position, *up, length=0.2, color='b')\n            ax.quiver(*position, *forward, length=0.2, color='r')\n\n    _ = self.tck[0]  # Spline parameters for plotting\n    u = np.linspace(0, 1, 100)\n    spline_points = np.array(splev(u, self.tck)).T\n    if spline:\n        ax.plot(*spline_points.T, color='gray', label='Spline')\n    if equal_bounds:\n        # Compute bounds\n        all_points = np.vstack([spline_points, *[frame[0] for frame in self.frames]])\n        max_bound = np.max(np.abs(all_points))\n\n        ax.set_xlim([-max_bound, max_bound])\n        ax.set_ylim([-max_bound, max_bound])\n        ax.set_zlim([-max_bound, max_bound])\n    if control_points:\n        ax.scatter(*self.control_points.T, color='black', label='Control Points')\n    if equal:\n        ax.axis('equal')\n\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n\n    if spline or control_points:\n        if not legend:\n            ax.legend()\n\n\n\n    if transparent:\n        fig.patch.set_alpha(0)\n        ax.patch.set_alpha(0)\n        ax.grid(False)\n\n    if fig:\n        return fig, ax \n    else:\n        return None \n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.rotation_matrix_from_vectors","title":"<code>rotation_matrix_from_vectors(vec1, vec2)</code>","text":"<p>Find the rotation matrix that aligns vec1 to vec2</p> Source code in <code>mdna/spline.py</code> <pre><code>def rotation_matrix_from_vectors(self,vec1, vec2):\n    \"\"\" Find the rotation matrix that aligns vec1 to vec2 \"\"\"\n    a, b = (vec1 / np.linalg.norm(vec1)).reshape(3), (vec2 / np.linalg.norm(vec2)).reshape(3)\n    v = np.cross(a, b)\n    c = np.dot(a, b)\n    s = np.linalg.norm(v)\n    kmat = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n    rotation_matrix = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s ** 2))\n    return rotation_matrix\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.test_frames","title":"<code>test_frames()</code>","text":"<p>Tests the computed frames for correctness.</p> <p>Checks consecutive frames for abrupt flips in the right and up vectors and prints warnings when angle deviations exceed 90 degrees.</p> Source code in <code>mdna/spline.py</code> <pre><code>def test_frames(self) -&gt; None:\n    \"\"\"\n    Tests the computed frames for correctness.\n\n    Checks consecutive frames for abrupt flips in the right and up vectors\n    and prints warnings when angle deviations exceed 90 degrees.\n    \"\"\"\n    for i in range(len(self.frames)-1):\n        frame1 = self.frames[i]\n        frame2 = self.frames[i+1]\n\n        right1, up1 = frame1[1:3]\n        right2, up2 = frame2[1:3]\n\n        # Check if right vectors have flipped\n        right_dot_product = np.dot(right1, right2)\n        if right_dot_product &lt; 0:\n            angle_deviation = np.degrees(np.arccos(np.clip(np.dot(right1, right2), -1.0, 1.0)))\n            print(f\"Warning: Right Vectors may have flipped. Frame {i+1} to Frame {i+2}. Angle Deviation: {angle_deviation:.2f} degrees\")\n\n        # Check if up vectors have flipped\n        up_dot_product = np.dot(up1, up2)\n        if up_dot_product &lt; 0:\n            angle_deviation = np.degrees(np.arccos(np.clip(np.dot(up1, up2), -1.0, 1.0)))\n            print(f\"Warning: Up Vectors may have flipped. Frame {i+1} to Frame {i+2}. Angle Deviation: {angle_deviation:.2f} degrees\")\n\n    return None\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.update_closed","title":"<code>update_closed(closed)</code>","text":"<p>Updates the closed property indicating if the path is closed.</p> <p>Parameters:</p> Name Type Description Default <code>closed</code> <code>bool</code> <p>Indicates if the path is closed.</p> required <p>Returns:</p> Name Type Description <code>SplineFrames</code> <code>SplineFrames</code> <p>The updated instance.</p> Source code in <code>mdna/spline.py</code> <pre><code>def update_closed(self, closed) -&gt; 'SplineFrames':\n    \"\"\"\n    Updates the closed property indicating if the path is closed.\n\n    Args:\n        closed (bool): Indicates if the path is closed.\n\n    Returns:\n        SplineFrames: The updated instance.\n    \"\"\"\n    self.closed = closed\n    self._initialize_spline()\n    self._evaluate_spline()\n    return self\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.update_control_points","title":"<code>update_control_points(control_points)</code>","text":"<p>Updates the control points defining the path.</p> <p>Parameters:</p> Name Type Description Default <code>control_points</code> <code>ndarray</code> <p>Control points defining the path.</p> required Source code in <code>mdna/spline.py</code> <pre><code>def update_control_points(self, control_points) -&gt; None:\n    \"\"\"\n    Updates the control points defining the path.\n\n    Args:\n        control_points (numpy.ndarray): Control points defining the path.\n    \"\"\"\n    self.control_points = control_points\n    self.frames = []\n    self._initialize_spline()\n    self._evaluate_spline()\n    self.distribute_points()\n    self.test_frames()\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.update_initial_frame","title":"<code>update_initial_frame(initial_frame)</code>","text":"<p>Updates the initial frame.</p> <p>Parameters:</p> Name Type Description Default <code>initial_frame</code> <code>tuple</code> <p>Tuple containing the position, right, up, and forward vectors of the frame.</p> required <p>Returns:</p> Name Type Description <code>SplineFrames</code> <code>SplineFrames</code> <p>The updated instance.</p> Source code in <code>mdna/spline.py</code> <pre><code>def update_initial_frame(self, initial_frame) -&gt; 'SplineFrames':\n    \"\"\"\n    Updates the initial frame.\n\n    Args:\n        initial_frame (tuple): Tuple containing the position, right, up, and forward vectors of the frame.\n\n    Returns:\n        SplineFrames: The updated instance.\n    \"\"\"\n    self.initial_frame = initial_frame\n    self._compute_frames()\n    return self\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.update_spline_degree","title":"<code>update_spline_degree(degree)</code>","text":"<p>Updates the degree of the spline.</p> <p>Parameters:</p> Name Type Description Default <code>degree</code> <code>int</code> <p>Degree of the spline.</p> required <p>Returns:</p> Name Type Description <code>SplineFrames</code> <code>SplineFrames</code> <p>The updated instance.</p> Source code in <code>mdna/spline.py</code> <pre><code>def update_spline_degree(self, degree) -&gt; 'SplineFrames':\n    \"\"\"\n    Updates the degree of the spline.\n\n    Args:\n        degree (int): Degree of the spline.\n\n    Returns:\n        SplineFrames: The updated instance.\n    \"\"\"\n    self.degree = degree\n    self._initialize_spline()\n    self._evaluate_spline()\n    return self\n</code></pre>"},{"location":"api/spline/#mdna.spline.SplineFrames.update_up_vector","title":"<code>update_up_vector(up_vector)</code>","text":"<p>Updates the up vector used for frame computation. Not used at the moment.</p> <p>Parameters:</p> Name Type Description Default <code>up_vector</code> <code>list or ndarray</code> <p>Up vector for frame computation.</p> required <p>Returns:</p> Name Type Description <code>SplineFrames</code> <code>SplineFrames</code> <p>The updated instance.</p> Source code in <code>mdna/spline.py</code> <pre><code>def update_up_vector(self, up_vector) -&gt; 'SplineFrames':\n    \"\"\"\n    Updates the up vector used for frame computation. Not used at the moment.\n\n    Args:\n        up_vector (list or numpy.ndarray): Up vector for frame computation.\n\n    Returns:\n        SplineFrames: The updated instance.\n    \"\"\"\n    self.up_vector = np.array(up_vector)\n    self._compute_frames()\n    return self\n</code></pre>"},{"location":"concepts/architecture/","title":"Architecture &amp; How MDNA Works","text":"<p>This page explains how MDNA's classes and functions relate to each other, and describes the internal pipeline from input to atomic-resolution output.</p>"},{"location":"concepts/architecture/#class-relationship-diagram","title":"Class Relationship Diagram","text":"<pre><code>graph TD\n    subgraph \"Top-Level Functions\"\n        make[\"mdna.make()\"]\n        load[\"mdna.load()\"]\n        connect[\"mdna.connect()\"]\n        crp[\"mdna.compute_rigid_parameters()\"]\n    end\n\n    subgraph \"Core Class\"\n        NUC[\"Nucleic\"]\n    end\n\n    subgraph \"Build Pipeline\"\n        SP[\"SplineFrames\"]\n        SG[\"SequenceGenerator\"]\n        STG[\"StructureGenerator\"]\n    end\n\n    subgraph \"Geometry &amp; Analysis\"\n        RB[\"ReferenceBase\"]\n        NF[\"NucleicFrames\"]\n        GA[\"GrooveAnalysis\"]\n        TA[\"TorsionAnalysis\"]\n    end\n\n    subgraph \"Modification\"\n        MUT[\"Mutate\"]\n        METH[\"Methylate\"]\n        HOOG[\"Hoogsteen\"]\n    end\n\n    subgraph \"Relaxation\"\n        MIN[\"Minimizer\"]\n        MC[\"PMCpy Monte Carlo\"]\n    end\n\n    subgraph \"Utilities\"\n        SH[\"Shapes\"]\n        RBD[\"RigidBody\"]\n    end\n\n    make --&gt; SP\n    make --&gt; NUC\n    load --&gt; NUC\n    connect --&gt; NUC\n\n    SH --&gt;|control points| SP\n    SP --&gt;|frames| STG\n    SG --&gt;|topology| STG\n    STG --&gt;|MDTraj trajectory| NUC\n\n    NUC --&gt;|\".minimize()\"| MIN\n    MIN --&gt; MC\n    MC --&gt;|relaxed frames| NUC\n\n    NUC --&gt;|\".mutate()\"| MUT\n    NUC --&gt;|\".methylate()\"| METH\n    NUC --&gt;|\".flip()\"| HOOG\n    MUT --&gt;|updated traj| NUC\n    METH --&gt;|updated traj| NUC\n    HOOG --&gt;|updated traj| NUC\n\n    NUC --&gt;|\".get_rigid_object()\"| NF\n    crp --&gt; NF\n    NF --&gt;|uses| RB\n    NF --&gt;|parameters| NUC\n\n    GA --&gt;|groove widths| NUC\n    TA --&gt;|torsion angles| NUC</code></pre>"},{"location":"concepts/architecture/#the-build-pipeline","title":"The Build Pipeline","text":"<p>When you call <code>mdna.make(sequence, control_points)</code>, the following happens internally:</p>"},{"location":"concepts/architecture/#1-shape-spline-frames","title":"1. Shape \u2192 Spline Frames","text":"<p>The <code>SplineFrames</code> class takes control points (from <code>Shapes</code> or user-defined) and:</p> <ul> <li>Fits a B-spline through the points</li> <li>Distributes base pair origins along the spline at 0.34 nm spacing</li> <li>Computes orthonormal reference frames at each position using the Bishop frame method (minimal torsion)</li> <li>Applies DNA twist based on <code>bp_per_turn</code> (default 10.5) or a specified linking number difference <code>dLk</code></li> </ul> <p>Output: An array of frames with shape <code>(n_bp, 4, 3)</code> \u2014 origin + 3 basis vectors per base pair.</p>"},{"location":"concepts/architecture/#2-sequence-topology","title":"2. Sequence \u2192 Topology","text":"<p>The <code>SequenceGenerator</code> class:</p> <ul> <li>Loads reference base atom coordinates from the atomic library (<code>mdna/atomic/bases/</code>)</li> <li>Constructs the sense strand and complementary antisense strand</li> <li>Builds an MDTraj <code>Topology</code> with proper residue names, bonds, and chain assignments</li> </ul>"},{"location":"concepts/architecture/#3-frames-topology-trajectory","title":"3. Frames + Topology \u2192 Trajectory","text":"<p>The <code>StructureGenerator</code> class:</p> <ul> <li>Places each reference base into its corresponding frame using rigid body transformations</li> <li>Handles purine/pyrimidine placement geometry via the <code>ReferenceBase</code> class</li> <li>Produces a full atomic-resolution MDTraj <code>Trajectory</code></li> </ul>"},{"location":"concepts/architecture/#4-assembly-nucleic","title":"4. Assembly \u2192 Nucleic","text":"<p>The <code>Nucleic</code> class wraps everything into a single object holding:</p> <ul> <li><code>sequence</code> \u2014 the DNA sequence string</li> <li><code>frames</code> \u2014 reference frames array <code>(n_bp, n_timesteps, 4, 3)</code></li> <li><code>traj</code> \u2014 the MDTraj trajectory (lazy-generated when needed)</li> <li><code>circular</code> \u2014 topology flag</li> </ul>"},{"location":"concepts/architecture/#the-analysis-pipeline","title":"The Analysis Pipeline","text":"<p>When you call methods like <code>dna.get_parameters()</code>:</p>"},{"location":"concepts/architecture/#1-trajectory-base-frames","title":"1. Trajectory \u2192 Base Frames","text":"<p>The <code>NucleicFrames</code> class:</p> <ul> <li>Extracts individual nucleobase atoms from the trajectory</li> <li>Fits each base to a <code>ReferenceBase</code> coordinate frame using the Tsukuba convention</li> <li>Computes mid-step frames (average of consecutive base pair frames)</li> </ul>"},{"location":"concepts/architecture/#2-frames-parameters","title":"2. Frames \u2192 Parameters","text":"<p>From the base pair and step frames, <code>NucleicFrames</code> computes:</p> <ul> <li>Intra-base pair parameters: Shear, Stretch, Stagger, Buckle, Propeller, Opening</li> <li>Inter-base pair step parameters: Shift, Slide, Rise, Tilt, Roll, Twist</li> </ul> <p>These are derived from the rotation matrices and displacement vectors between frames using the <code>RigidBody</code> utility class (Euler vector decomposition).</p>"},{"location":"concepts/architecture/#modification-pipeline","title":"Modification Pipeline","text":"<p>Modifications operate on the MDTraj trajectory:</p> <ul> <li><code>Mutate</code>: Replaces atom coordinates and topology for specified residues using reference base structures</li> <li><code>Methylate</code>: Inserts a methyl carbon atom at the C5 (cytosine) or O6 (guanine) position</li> <li><code>Hoogsteen</code>: Rotates the nucleobase heavy atoms around the glycosidic bond axis</li> </ul> <p>All modifications clear cached frames and rigid parameters, since the atomic coordinates have changed.</p>"},{"location":"concepts/architecture/#the-nucleic-object-lifecycle","title":"The Nucleic Object Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Created: make() / load()\n    Created --&gt; HasFrames: get_frames()\n    Created --&gt; HasTraj: get_traj()\n    HasFrames --&gt; HasTraj: _frames_to_traj()\n    HasTraj --&gt; HasFrames: _traj_to_frames()\n    HasTraj --&gt; Analyzed: get_rigid_object()\n    HasTraj --&gt; Modified: mutate() / flip() / methylate()\n    Modified --&gt; HasTraj: (traj updated)\n    Modified --&gt; Created: (frames cleared)\n    HasFrames --&gt; Minimized: minimize()\n    Minimized --&gt; HasTraj: (traj regenerated)\n    Analyzed --&gt; HasTraj: (rigid params cached)</code></pre> <p>The <code>Nucleic</code> object lazily converts between frames and trajectory as needed. Modifications clear the frame/analysis cache, and minimization updates frames then regenerates the trajectory.</p>"},{"location":"concepts/architecture/#key-design-decisions","title":"Key Design Decisions","text":"<ol> <li> <p>Lazy evaluation: Trajectory and frames are computed on demand, not eagerly. This allows working with frames-only workflows (fast) or full atomic trajectories (when needed).</p> </li> <li> <p>In-place modification: Methods like <code>mutate()</code>, <code>flip()</code>, <code>methylate()</code>, <code>minimize()</code>, and <code>extend()</code> modify the <code>Nucleic</code> object in-place rather than returning new objects.</p> </li> <li> <p>MDTraj interoperability: The atomic representation is always an MDTraj <code>Trajectory</code>, ensuring compatibility with the broader MD ecosystem.</p> </li> <li> <p>Spline-based construction: DNA shape is defined by control points \u2192 spline \u2192 frames, decoupling geometry from sequence. This enables arbitrary shapes while maintaining correct base pair spacing and twist.</p> </li> </ol>"},{"location":"concepts/minimization/","title":"Monte Carlo Minimization","text":"<p>MDNA uses Monte Carlo (MC) simulations to relax DNA structures into physically consistent configurations.  The minimization engine is provided by PMCpy github, a vendored subpackage located at <code>mdna/PMCpy/</code>.</p>"},{"location":"concepts/minimization/#why-minimization","title":"Why Minimization?","text":"<p>When DNA is built from spline control points, the resulting structure captures the desired global shape but may contain local strain \u2014 overlapping atoms, unrealistic backbone geometries, or violated steric constraints.  MC minimization resolves these issues by sampling thermal fluctuations around the reference configuration while respecting an elastic energy model.</p>"},{"location":"concepts/minimization/#the-rigid-base-pair-model","title":"The Rigid Base-Pair Model","text":"<p>PMCpy treats each base-pair step as a rigid body connected to its neighbors through a harmonic elastic potential parameterized by the six rigid base-pair step parameters (shift, slide, rise, tilt, roll, twist).  The stiffness matrices are sequence-dependent and derived from atomistic MD simulations.</p> <pre><code>graph LR\n    A[\"BP i\"] -- \"elastic&lt;br/&gt;potential\" --&gt; B[\"BP i+1\"]\n    B -- \"elastic&lt;br/&gt;potential\" --&gt; C[\"BP i+2\"]\n    C -- \"...\" --&gt; D[\"BP n\"]\n    style A fill:#4051b5,color:#fff\n    style B fill:#4051b5,color:#fff\n    style C fill:#4051b5,color:#fff\n    style D fill:#4051b5,color:#fff</code></pre> <p>Each MC move proposes a small random perturbation to a base-pair step, computes the energy change, and accepts or rejects the move using the Metropolis criterion at the specified temperature.</p>"},{"location":"concepts/minimization/#equilibration-modes","title":"Equilibration Modes","text":"<p>The <code>minimize()</code> method supports three equilibration strategies:</p>"},{"location":"concepts/minimization/#full-equilibration-default","title":"Full Equilibration (default)","text":"<pre><code>dna.minimize()\n</code></pre> <p>Runs the full PMCpy equilibration protocol.  This iteratively adjusts both the step parameters and global configuration until convergence is reached.  The equilibration monitors the energy trace and terminates when fluctuations stabilize.</p>"},{"location":"concepts/minimization/#simple-equilibration","title":"Simple Equilibration","text":"<pre><code>dna.minimize(simple=True)\n</code></pre> <p>A lighter-weight equilibration that performs a fixed set of MC sweeps without the adaptive convergence check.  Faster but may not fully relax highly strained configurations.</p>"},{"location":"concepts/minimization/#writhe-equilibration","title":"Writhe Equilibration","text":"<pre><code>dna.minimize(simple=True, equilibrate_writhe=True)\n</code></pre> <p>Special mode for circular DNA that additionally equilibrates the writhe (\\(Wr\\)) while maintaining the target linking number (\\(Lk\\)).  This requires the simple equilibration path and uses the PyLk Cython extensions for efficient writhe computation.</p> <p>Writhe equilibration requires compiled PyLk</p> <p>See Building PyLk Cython Extensions for compilation instructions.</p>"},{"location":"concepts/minimization/#key-parameters","title":"Key Parameters","text":"Parameter Default Description <code>frame</code> <code>-1</code> Which stored frame to minimize (index into the frames array) <code>exvol_rad</code> <code>2.0</code> Excluded-volume radius in nm \u2014 prevents base-pair overlap <code>temperature</code> <code>300</code> Temperature in Kelvin for the Metropolis criterion <code>simple</code> <code>False</code> Use simple (fixed-sweep) equilibration <code>equilibrate_writhe</code> <code>False</code> Equilibrate writhe for circular DNA <code>endpoints_fixed</code> <code>True</code> Keep the first and last base pairs fixed <code>fixed</code> <code>[]</code> List of base-pair indices to keep fixed during minimization <code>dump_every</code> <code>20</code> Save a snapshot every n MC sweeps <code>plot</code> <code>False</code> Plot the energy trace during equilibration"},{"location":"concepts/minimization/#accessing-the-mc-trajectory","title":"Accessing the MC Trajectory","text":"<p>After minimization you can retrieve the full MC trajectory as an MDTraj <code>Trajectory</code> object:</p> <pre><code>dna.minimize()\ntraj = dna.get_MC_traj()\ntraj.save_pdb('mc_trajectory.pdb')\n</code></pre> <p>Each frame in the trajectory contains:</p> <ul> <li>Argon atoms at the base-pair center positions</li> <li>Helium (dummy) atoms offset along the major-groove vector</li> </ul> <p>This encoding lets you visualize the MC sampling path and inspect how the structure relaxes over the course of the simulation.</p>"},{"location":"concepts/minimization/#architecture","title":"Architecture","text":"<pre><code>flowchart TD\n    N[\"Nucleic\"] --&gt;|\".minimize()\"| M[\"Minimizer\"]\n    M --&gt;|\"copies frames\"| MC[\"PMCpy Run engine\"]\n    MC --&gt;|\"MC sweeps\"| OUT[\"positions + triads\"]\n    OUT --&gt;|\"update\"| N\n    MC --&gt;|\"snapshots\"| TRAJ[\"get_MC_traj() \u2192 MDTraj\"]\n    style N fill:#4051b5,color:#fff\n    style M fill:#7c4dff,color:#fff\n    style MC fill:#00897b,color:#fff\n    style OUT fill:#00897b,color:#fff\n    style TRAJ fill:#ff6d00,color:#fff</code></pre>"},{"location":"concepts/minimization/#see-also","title":"See Also","text":"<ul> <li>API Reference \u2014 Minimizer</li> <li>User Guide \u2014 Building DNA (includes minimization examples)</li> <li>Concepts \u2014 Architecture for how Minimizer fits into the overall pipeline</li> </ul>"},{"location":"concepts/rigid-base/","title":"Rigid Base Parameters","text":"<p>This page explains the rigid base formalism used by MDNA for describing DNA geometry.</p>"},{"location":"concepts/rigid-base/#overview","title":"Overview","text":"<p>The rigid base model treats each nucleobase as a rigid body with a well-defined reference frame. DNA geometry is then described by the relative positions and orientations of these frames, yielding 12 parameters per base pair step.</p>"},{"location":"concepts/rigid-base/#reference-frames","title":"Reference Frames","text":"<p>Each base has a local coordinate system (reference frame) defined by the Tsukuba convention:</p> <ul> <li>Origin (\\(\\mathbf{b}_R\\)): The base reference point, computed from the glycosidic nitrogen and C1' sugar atom</li> <li>Long axis (\\(\\hat{b}_L\\)): Points roughly along the base pair hydrogen bonds</li> <li>Short axis (\\(\\hat{b}_D\\)): Perpendicular to the long axis, in the base plane</li> <li>Normal (\\(\\hat{b}_N\\)): Perpendicular to the base plane (right-hand rule)</li> </ul> <p>The mid-step frame (average of two consecutive base pair frames) serves as the reference for computing step parameters.</p>"},{"location":"concepts/rigid-base/#base-pair-parameters","title":"Base Pair Parameters","text":"<p>These describe the relative geometry of two bases within a Watson-Crick pair:</p> Parameter Description Axis Unit Shear Lateral displacement Along \\(\\hat{b}_L\\) nm Stretch Separation along H-bond direction Along \\(\\hat{b}_D\\) nm Stagger Vertical offset Along \\(\\hat{b}_N\\) nm Buckle Rotation opening the base pair like a book Around \\(\\hat{b}_L\\) degrees Propeller Rotation of bases in opposite directions Around \\(\\hat{b}_D\\) degrees Opening Rotation that opens the Watson-Crick edge Around \\(\\hat{b}_N\\) degrees"},{"location":"concepts/rigid-base/#base-pair-step-parameters","title":"Base Pair Step Parameters","text":"<p>These describe the relative geometry between consecutive base pair steps:</p> Parameter Description Axis Unit Shift Lateral displacement of one step relative to the next Along \\(\\hat{b}_L\\) nm Slide Displacement along the short axis Along \\(\\hat{b}_D\\) nm Rise Vertical separation between steps Along \\(\\hat{b}_N\\) nm Tilt Rotation around the long axis Around \\(\\hat{b}_L\\) degrees Roll Rotation around the short axis (bending) Around \\(\\hat{b}_D\\) degrees Twist Rotation around the helical axis Around \\(\\hat{b}_N\\) degrees"},{"location":"concepts/rigid-base/#computation-method","title":"Computation Method","text":"<p>MDNA computes these parameters through the following steps:</p> <ol> <li>Base identification: Extract nucleobase heavy atoms from the MDTraj trajectory</li> <li>Frame fitting: Fit each base to a canonical reference frame using the <code>ReferenceBase</code> class</li> <li>Mid-pair frames: Average the two base frames within each pair</li> <li>Euler decomposition: Compute the rotation matrix and displacement between consecutive mid-pair frames</li> <li>Parameter extraction: Decompose the rotation into Euler angles (Tilt, Roll, Twist) and project the displacement onto the local axes (Shift, Slide, Rise)</li> </ol> <p>The rotation decomposition uses the <code>RigidBody.extract_omega_values()</code> method, which handles edge cases near \\(\\pm\\pi\\) rotation angles.</p>"},{"location":"concepts/rigid-base/#typical-values-for-b-dna","title":"Typical Values for B-DNA","text":"Parameter Typical Range Shift -0.5 to 0.5 nm Slide -0.5 to 0.5 nm Rise 0.31 to 0.37 nm Tilt -10\u00b0 to 10\u00b0 Roll -10\u00b0 to 10\u00b0 Twist 30\u00b0 to 40\u00b0 (mean ~36\u00b0) Shear -0.5 to 0.5 nm Stretch -0.3 to 0.3 nm Stagger -0.5 to 0.5 nm Buckle -20\u00b0 to 20\u00b0 Propeller -25\u00b0 to -5\u00b0 Opening -5\u00b0 to 5\u00b0"},{"location":"concepts/rigid-base/#references","title":"References","text":"<ul> <li>Olson, W. K., et al. (2001). A standard reference frame for the description of nucleic acid base-pair geometry. J. Mol. Biol., 313(1), 229\u2013237.</li> <li>Lu, X. J., &amp; Olson, W. K. (2003). 3DNA: a software package for the analysis, rebuilding and visualization of three-dimensional nucleic acid structures. Nucleic Acids Res., 31(17), 5108\u20135121.</li> </ul>"},{"location":"concepts/splines/","title":"Splines &amp; Geometry","text":"<p>This page explains how MDNA uses spline interpolation to map arbitrary 3D shapes onto DNA structures.</p>"},{"location":"concepts/splines/#from-control-points-to-dna","title":"From Control Points to DNA","text":"<p>MDNA's construction pipeline converts a set of 3D control points into a full atomic DNA structure through spline-based frame generation.</p> <pre><code>graph LR\n    CP[\"Control Points&lt;br/&gt;(n \u00d7 3)\"] --&gt; SPL[\"B-Spline&lt;br/&gt;Interpolation\"]\n    SPL --&gt; ARC[\"Arc-Length&lt;br/&gt;Parameterization\"]\n    ARC --&gt; FR[\"Frame Distribution&lt;br/&gt;(0.34 nm spacing)\"]\n    FR --&gt; TW[\"Twist Application&lt;br/&gt;(bp_per_turn / dLk)\"]\n    TW --&gt; OUT[\"Reference Frames&lt;br/&gt;(n_bp \u00d7 4 \u00d7 3)\"]</code></pre>"},{"location":"concepts/splines/#spline-interpolation","title":"Spline Interpolation","text":"<p>The <code>SplineFrames</code> class uses B-spline interpolation (via <code>scipy.interpolate.splprep</code>) to create a smooth 3D curve through the control points.</p> <p>Key parameters:</p> Parameter Default Description <code>degree</code> 3 Spline degree (cubic) <code>closed</code> False Whether the spline forms a closed loop <code>num_points</code> 1000 Internal evaluation resolution <p>For closed DNA (<code>circular=True</code>), the spline is made periodic so the curve smoothly connects back to the start.</p>"},{"location":"concepts/splines/#arc-length-parameterization","title":"Arc-Length Parameterization","text":"<p>After fitting the spline, MDNA reparameterizes it by arc length. This ensures that base pair origins are distributed at equal spacing along the curve, regardless of how the control points are distributed.</p> <p>The arc length is computed by numerical integration of the spline derivative magnitude.</p>"},{"location":"concepts/splines/#frame-generation-bishop-frames","title":"Frame Generation (Bishop Frames)","text":"<p>At each distributed point, MDNA computes an orthonormal frame (origin + 3 basis vectors) using the Bishop frame method:</p> <ol> <li>Tangent (\\(\\hat{T}\\)): First derivative of the spline (normalized)</li> <li>Normal (\\(\\hat{N}\\)): Derived from a reference \"up\" direction, orthogonalized against the tangent</li> <li>Binormal (\\(\\hat{B}\\)): Cross product of tangent and normal</li> </ol> <p>The Bishop frame method is preferred over the Frenet-Serret frame because:</p> <ul> <li>It avoids singularities at inflection points (where curvature is zero)</li> <li>It produces minimal torsion \u2014 frames rotate smoothly along the curve without sudden flips</li> <li>It is well-defined even for straight segments</li> </ul> <p>The initial frame orientation is propagated incrementally along the curve, ensuring continuity.</p>"},{"location":"concepts/splines/#twist-application","title":"Twist Application","text":"<p>After generating untwisted frames, DNA twist is applied:</p>"},{"location":"concepts/splines/#default-twist","title":"Default Twist","text":"\\[\\theta_{\\text{twist}} = \\frac{360\u00b0}{\\text{bp\\_per\\_turn}} \\approx 34.3\u00b0 \\text{ per step}\\] <p>with <code>bp_per_turn = 10.5</code> (canonical B-DNA).</p>"},{"location":"concepts/splines/#linking-number-control","title":"Linking Number Control","text":"<p>For circular DNA, the total twist can be modified by specifying \\(\\Delta Lk\\):</p> \\[Lk = Tw + Wr\\] <p>where \\(Tw\\) is twist and \\(Wr\\) is writhe. The <code>dLk</code> parameter adds extra twist that, after minimization, redistributes into twist and writhe according to the elastic properties of the structure.</p>"},{"location":"concepts/splines/#frame-format","title":"Frame Format","text":"<p>The output frames have shape <code>(n_bp, 4, 3)</code>:</p> Row Content Description 0 Origin Position of the base pair center (nm) 1 \\(\\hat{b}_L\\) Long axis (roughly along H-bonds) 2 \\(\\hat{b}_D\\) Short axis (in base plane) 3 \\(\\hat{b}_N\\) Normal to the base plane <p>These frames serve as the coordinate systems into which atomic base structures are placed by the <code>StructureGenerator</code>.</p>"},{"location":"concepts/splines/#predefined-shapes","title":"Predefined Shapes","text":"<p>The <code>Shapes</code> class provides factory methods returning control point arrays:</p> Shape Method Key Parameters Straight line <code>Shapes.line(length)</code> <code>length</code> Circle <code>Shapes.circle(radius)</code> <code>radius</code> Helix <code>Shapes.helix(...)</code> <code>height</code>, <code>pitch</code>, <code>radius</code>, <code>num_turns</code> <p>All return numpy arrays of shape <code>(n, 3)</code> suitable for passing to <code>mdna.make(control_points=...)</code>.</p>"},{"location":"concepts/splines/#practical-tips","title":"Practical Tips","text":"<p>Number of control points</p> <p>You need at least 4 control points for cubic spline interpolation. More points give finer control over the shape.</p> <p>Scaling</p> <p>When you provide both <code>control_points</code> and <code>n_bp</code> (or <code>sequence</code>), the spline is scaled so that exactly <code>n_bp</code> base pairs fit along the curve at 0.34 nm spacing.</p> <p>Inferring n_bp</p> <p>If you provide only <code>control_points</code> without <code>sequence</code> or <code>n_bp</code>, MDNA automatically determines the number of base pairs from the spline arc length.</p>"},{"location":"explanation/explanation/","title":"Background","text":""},{"location":"explanation/explanation/#background-and-context","title":"Background and Context","text":"<p>MDNA was created to support molecular dynamics simulations that require precise construction and analysis of double stranded DNA and DNA protein assemblies. In contrast to proteins, where experimentally resolved structures are often available, DNA systems frequently need to be built from first principles, particularly when introducing non canonical nucleotides, methylation patterns, altered linking numbers, or Hoogsteen base pairing. MDNA addresses this challenge by enabling atomic resolution DNA generation from sequence and geometry, producing reliable starting configurations for simulation studies.</p> <p>Many existing nucleic acid tools focus either on visualization, coarse grained modeling, or rigid body analysis, and often lack flexibility for constructing arbitrarily shaped DNA or integrating seamlessly into simulation pipelines. MDNA was therefore designed as a unified Python framework that combines spline based structure generation, Monte Carlo relaxation, sequence editing, and rigid base analysis within a single ecosystem. It interoperates directly with widely used simulation libraries such as MDTraj and OpenMM, enabling smooth transitions from model building to production simulations and trajectory analysis.</p>"},{"location":"explanation/explanation/#working-with-mdna","title":"Working with MDNA","text":"<p>MDNA provides a flexible workflow for constructing and interrogating DNA structures. Users can generate models from sequence alone, define custom geometries through control points, enforce circular topologies with prescribed linking number differences, or extend and connect existing fragments to build large heterogeneous assemblies. Optional Monte Carlo minimization relaxes elastic deformations and steric clashes while preserving topological constraints when required.</p> <p>For structural analysis, MDNA implements the full rigid base formalism natively in Python. Intra base pair parameters include shear, stretch, stagger, buckle, propeller, and opening. Inter base pair step parameters include shift, slide, rise, tilt, roll, and twist. The toolkit also provides direct computation of linking number, including its decomposition into twist and writhe.</p> <p>Although MDNA does not currently include dedicated curvature or persistence length functions, the rigid base frames and step parameters it generates provide all required geometric information to compute such quantities externally. Users can derive curvature from base pair frame orientations and estimate persistence length from tangent correlation analysis using the exported trajectory data.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#quick-install-pip","title":"Quick Install (pip)","text":"<pre><code>pip install mdna\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>Clone the repository (including submodules for the Monte Carlo engine):</p> <pre><code>git clone --recurse-submodules -j8 git@github.com:heezch/mdna.git\ncd mdna\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>MDNA requires Python 3.9+ and depends on:</p> Package Purpose numpy Numerical arrays and linear algebra scipy Spline interpolation, rotations mdtraj Molecular trajectory I/O and topology matplotlib Visualization and plotting numba JIT-compiled geometry routines"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"Package Purpose openmm Molecular dynamics simulation via <code>sequence_to_md()</code> nglview Interactive 3D molecular visualization in notebooks joblib Parallel computation in groove analysis"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import mdna\nprint(mdna.__version__)\n\n# Quick smoke test \u2014 generate a 12-bp DNA\ndna = mdna.make(sequence='CGCGAATTCGCG')\ndna.describe()\n</code></pre> <p>If this prints the DNA structure info without errors, you're ready to go.</p>"},{"location":"getting-started/installation/#building-pylk-cython-extensions","title":"Building PyLk Cython Extensions","text":"<p>MDNA vendors <code>PyLk</code> (inside <code>mdna/PMCpy/pmcpy/Evals/PyLk</code>) for linking-number and writhe calculations. Without the compiled Cython extensions you may see warnings like \"Cython version of writhemap/linkingnumber not compiled\". The pure-Python fallback still works, but the compiled version is significantly faster.</p>"},{"location":"getting-started/installation/#1-install-cython","title":"1. Install Cython","text":"<pre><code># conda / mamba\nmamba install -n mdna cython\n\n# or pip\npip install Cython\n</code></pre>"},{"location":"getting-started/installation/#2-compile-in-place","title":"2. Compile in-place","text":"<pre><code># from the repository root\ncd mdna/PMCpy/pmcpy/Evals/PyLk\npython setup.py build_ext --inplace\n</code></pre> <p>If you use conda/mamba, you can run with your environment explicitly:</p> <pre><code>mamba run -n mdna python mdna/PMCpy/pmcpy/Evals/PyLk/setup.py build_ext --inplace\n</code></pre>"},{"location":"getting-started/installation/#3-verify","title":"3. Verify","text":"<pre><code>from mdna.PMCpy.pmcpy.Evals.PyLk.pylk import writhemap, eval_link\nprint(\"PyLk OK:\", writhemap.__name__, eval_link.__name__)\n</code></pre>"},{"location":"getting-started/installation/#filament-dataset-for-notebooks","title":"Filament Dataset (for notebooks)","text":"<p>Several Jupyter notebooks (e.g. the filament tutorial) require an external dataset hosted on Figshare. To download it:</p> <pre><code>cd docs/notebooks\nexport MDNA_FILAMENT_DATASET_URL='https://doi.org/10.6084/m9.figshare.31423193'\npython ./scripts/fetch_filament_dataset.py --output-root ./data\n</code></pre> <p>The fetch script resolves the DOI to the direct download URL, downloads the archive, and unpacks it into <code>data/filament_dataset/</code>.</p> <p>Optional integrity check</p> <p>If you have the published SHA256 hash of the archive, you can verify:</p> <pre><code>export MDNA_FILAMENT_DATASET_SHA256='&lt;REAL_SHA256&gt;'\npython ./scripts/fetch_filament_dataset.py --output-root ./data --force\n</code></pre> <p>If you do not have the hash, leave <code>MDNA_FILAMENT_DATASET_SHA256</code> unset and run without checksum verification.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>This page gets you from zero to a generated, minimized, and analyzed DNA structure in under five minutes.</p>"},{"location":"getting-started/quickstart/#1-generate-a-dna-structure","title":"1. Generate a DNA Structure","text":"<pre><code>import mdna\n\n# From a sequence\ndna = mdna.make(sequence='ATCGATCGGT')\ndna.describe()\n</code></pre> <p>MDNA returns a <code>Nucleic</code> object \u2014 the central data structure that holds the sequence, reference frames, and (optionally) an atomic-resolution MDTraj trajectory.</p>"},{"location":"getting-started/quickstart/#2-visualize","title":"2. Visualize","text":"<pre><code>dna.draw()\n</code></pre> <p>This produces a 3D matplotlib plot showing the helical axis and backbone.</p>"},{"location":"getting-started/quickstart/#3-minimize-the-structure","title":"3. Minimize the Structure","text":"<p>Monte Carlo relaxation removes steric clashes and elastic strain:</p> <pre><code>dna.minimize()\ndna.draw()\n</code></pre> <p>Note</p> <p><code>minimize()</code> updates the internal trajectory and frames in-place.</p>"},{"location":"getting-started/quickstart/#4-analyze-rigid-base-parameters","title":"4. Analyze Rigid Base Parameters","text":"<pre><code>params, names = dna.get_parameters()\nprint(\"Parameter names:\", names)\nprint(\"Shape:\", params.shape)  # (n_frames, n_bp, n_params)\n</code></pre> <p>Or retrieve a single parameter:</p> <pre><code>twist = dna.get_parameter('twist')\n</code></pre>"},{"location":"getting-started/quickstart/#5-export-to-pdb","title":"5. Export to PDB","text":"<pre><code>dna.save_pdb('my_dna.pdb')\n</code></pre> <p>Or get the MDTraj trajectory directly:</p> <pre><code>traj = dna.get_traj()\n</code></pre>"},{"location":"getting-started/quickstart/#whats-next","title":"What's Next?","text":"Goal Page Build custom shapes, circular DNA, extend &amp; connect Building DNA Mutate, methylate, flip bases Modifying DNA Analyze trajectories and rigid base parameters Analyzing DNA Understand how the classes fit together Architecture Full function/class reference API Reference"},{"location":"guide/analyzing/","title":"Analyzing DNA Structures","text":"<p>MDNA provides tools for computing rigid base parameters, linking numbers, and groove widths from DNA structures and MD trajectories.</p>"},{"location":"guide/analyzing/#loading-a-trajectory","title":"Loading a Trajectory","text":"<pre><code>import mdna\n\n# From files\ndna = mdna.load(filename='trajectory.xtc', top='topology.pdb')\n\n# Or from an existing MDTraj trajectory\nimport mdtraj as md\ntraj = md.load('trajectory.xtc', top='topology.pdb')\ndna = mdna.load(traj=traj, chainids=[0, 1])\n\ndna.describe()\n</code></pre>"},{"location":"guide/analyzing/#rigid-base-parameters","title":"Rigid Base Parameters","text":"<p>The rigid base formalism describes DNA geometry through 12 parameters split into two groups:</p>"},{"location":"guide/analyzing/#base-pair-parameters-intra-base-pair","title":"Base Pair Parameters (intra-base pair)","text":"<p>Describe the relative position/orientation of two bases within a pair:</p> Parameter Type Unit Shear Translation nm Stretch Translation nm Stagger Translation nm Buckle Rotation degrees Propeller Rotation degrees Opening Rotation degrees"},{"location":"guide/analyzing/#base-pair-step-parameters-inter-base-pair","title":"Base Pair Step Parameters (inter-base pair)","text":"<p>Describe the relative position/orientation between consecutive base pair steps:</p> Parameter Type Unit Shift Translation nm Slide Translation nm Rise Translation nm Tilt Rotation degrees Roll Rotation degrees Twist Rotation degrees"},{"location":"guide/analyzing/#computing-parameters","title":"Computing Parameters","text":"<pre><code># Get all 12 parameters\nparams, names = dna.get_parameters()\nprint(names)   # List of parameter names\nprint(params.shape)  # (n_frames, n_bp, 12)\n\n# Get only step parameters\nstep_params, step_names = dna.get_parameters(step=True)\n\n# Get only base pair parameters\nbp_params, bp_names = dna.get_parameters(base=True)\n\n# Get a single parameter by name\ntwist = dna.get_parameter('twist')\nroll = dna.get_parameter('roll')\n</code></pre>"},{"location":"guide/analyzing/#plotting-parameters","title":"Plotting Parameters","text":"<p>The <code>NucleicFrames</code> object provides built-in plotting:</p> <pre><code>rigid = dna.get_rigid_object()\nrigid.plot_parameters()\n</code></pre>"},{"location":"guide/analyzing/#custom-visualization","title":"Custom Visualization","text":"<pre><code>import matplotlib.pyplot as plt\n\nparams, names = dna.get_parameters(step=True)\n\nfig, axes = plt.subplots(2, 3, figsize=(12, 6))\nfor i, (ax, name) in enumerate(zip(axes.flat, names)):\n    data = params[:, :, i]\n    ax.plot(data.mean(axis=0))\n    ax.fill_between(\n        range(data.shape[1]),\n        data.mean(axis=0) - data.std(axis=0),\n        data.mean(axis=0) + data.std(axis=0),\n        alpha=0.3\n    )\n    ax.set_title(name)\nplt.tight_layout()\n</code></pre>"},{"location":"guide/analyzing/#rigid-base-parameters-from-a-trajectory","title":"Rigid Base Parameters from a Trajectory","text":"<p>For standalone analysis without creating a <code>Nucleic</code> object:</p> <pre><code>import mdtraj as md\n\ntraj = md.load('dna.pdb')\nrigid = mdna.compute_rigid_parameters(traj, chainids=[0, 1])\n</code></pre> <p>This returns a <code>NucleicFrames</code> object with the same interface as <code>dna.get_rigid_object()</code>.</p>"},{"location":"guide/analyzing/#base-reference-frames","title":"Base Reference Frames","text":"<p>Access the individual base reference frames (useful for custom geometry analysis):</p> <pre><code>base_frames = dna.get_base_frames()\n# Returns dict: {residue_topology: frames (n_frames, 4, 3)}\n</code></pre> <p>The frame rows are: origin, \\(\\hat{b}_L\\) (long axis), \\(\\hat{b}_D\\) (short axis), \\(\\hat{b}_N\\) (normal).</p>"},{"location":"guide/analyzing/#linking-number","title":"Linking Number","text":"<p>For circular DNA, compute the linking number and its decomposition into writhe and twist:</p> <pre><code>dna = mdna.make(n_bp=200, circular=True, dLk=2)\nLk, Wr, Tw = dna.get_linking_number()\nprint(f'Lk = {Lk:.2f}, Wr = {Wr:.2f}, Tw = {Tw:.2f}')\n</code></pre> <p>The linking number is computed using Gauss's linking integral via the PyLk library.</p>"},{"location":"guide/analyzing/#groove-width-analysis","title":"Groove Width Analysis","text":"<p>The <code>GrooveAnalysis</code> class computes major and minor groove widths by fitting cubic splines through phosphorus atom positions:</p> <pre><code>import mdtraj as md\n\ntraj = md.load('dna_trajectory.xtc', top='dna.pdb')\ngrooves = mdna.GrooveAnalysis(traj)\n\n# Plot groove widths\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots(figsize=(6, 3))\ngrooves.plot_groove_widths(ax=ax)\n</code></pre>"},{"location":"guide/analyzing/#torsion-angle-analysis","title":"Torsion Angle Analysis","text":"<p>The <code>TorsionAnalysis</code> class computes backbone torsion angles:</p> <pre><code>torsions = mdna.TorsionAnalysis(traj)\n</code></pre>"},{"location":"guide/analyzing/#summary","title":"Summary","text":"Analysis Function / Method Returns All rigid base parameters <code>nucleic.get_parameters()</code> <code>(params, names)</code> Single parameter <code>nucleic.get_parameter('twist')</code> <code>np.ndarray</code> NucleicFrames object <code>nucleic.get_rigid_object()</code> <code>NucleicFrames</code> Standalone rigid params <code>mdna.compute_rigid_parameters(traj)</code> <code>NucleicFrames</code> Base frames <code>nucleic.get_base_frames()</code> <code>dict</code> Linking number <code>nucleic.get_linking_number()</code> <code>[Lk, Wr, Tw]</code> Groove widths <code>mdna.GrooveAnalysis(traj)</code> <code>GrooveAnalysis</code> Torsion angles <code>mdna.TorsionAnalysis(traj)</code> <code>TorsionAnalysis</code>"},{"location":"guide/building/","title":"Building DNA Structures","text":"<p>This guide covers all the ways to create DNA structures with MDNA: from simple sequences to custom-shaped assemblies.</p>"},{"location":"guide/building/#basic-construction","title":"Basic Construction","text":""},{"location":"guide/building/#from-a-sequence","title":"From a Sequence","text":"<pre><code>import mdna\n\ndna = mdna.make(sequence='GCGCGCGCGC')\ndna.describe()\ndna.draw()\n</code></pre>"},{"location":"guide/building/#from-a-number-of-base-pairs","title":"From a Number of Base Pairs","text":"<p>When no sequence is provided, a random sequence is generated:</p> <pre><code>dna = mdna.make(n_bp=50)\nprint(dna.sequence)\n</code></pre>"},{"location":"guide/building/#from-existing-data","title":"From Existing Data","text":"<p>Load from an MDTraj trajectory or PDB file:</p> <pre><code>import mdtraj as md\n\n# From a PDB file\ndna = mdna.load(filename='my_dna.pdb')\n\n# From an MDTraj trajectory\ntraj = md.load('trajectory.xtc', top='topology.pdb')\ndna = mdna.load(traj=traj, chainids=[0, 1])\n</code></pre> <p>Or from precomputed reference frames:</p> <pre><code>import numpy as np\nframes = np.load('frames.npy')  # shape (n_bp, 4, 3)\ndna = mdna.load(frames=frames, sequence='ATCG...')\n</code></pre>"},{"location":"guide/building/#custom-shapes","title":"Custom Shapes","text":"<p>MDNA uses spline interpolation through control points to define arbitrary DNA paths.</p>"},{"location":"guide/building/#built-in-shapes","title":"Built-in Shapes","text":"<p>The <code>Shapes</code> class provides common geometries:</p> <pre><code># Straight line (default)\npoints = mdna.Shapes.line(length=5)\n\n# Circle\npoints = mdna.Shapes.circle(radius=3)\n\n# Helix / supercoil\npoints = mdna.Shapes.helix(height=3, pitch=5, radius=7, num_turns=4)\n</code></pre> <p>Use them with <code>make()</code>:</p> <pre><code>dna = mdna.make(n_bp=300, control_points=mdna.Shapes.helix())\ndna.draw()\n</code></pre>"},{"location":"guide/building/#custom-control-points","title":"Custom Control Points","text":"<p>Define any 3D path with at least 4 points:</p> <pre><code>import numpy as np\n\ncontrol_points = np.array([\n    [0, 0, 0],\n    [30, 10, -10],\n    [50, 10, 20],\n    [3, 4, 30]\n])\n\ndna = mdna.make(n_bp=100, control_points=control_points)\ndna.draw()\n</code></pre> <p>Tip</p> <p>When only <code>control_points</code> are provided (no <code>sequence</code> or <code>n_bp</code>), MDNA infers <code>n_bp</code> from the spline arc length using the standard 0.34 nm rise per base pair.</p>"},{"location":"guide/building/#circular-dna","title":"Circular DNA","text":"<p>Create closed minicircles with optional linking number control:</p> <pre><code># Relaxed minicircle\ndna = mdna.make(n_bp=200, circular=True)\nprint('Lk, Wr, Tw:', dna.get_linking_number())\ndna.draw()\n\n# Supercoiled minicircle (overwound by 8 turns)\ndna = mdna.make(n_bp=200, circular=True, dLk=8)\nprint('Lk, Wr, Tw:', dna.get_linking_number())\n</code></pre> <p>Note</p> <p>When minimizing supercoiled DNA, use <code>equilibrate_writhe=True</code> to allow the writhe to equilibrate: <pre><code>dna.minimize(equilibrate_writhe=True)\n</code></pre></p>"},{"location":"guide/building/#minimization","title":"Minimization","text":"<p>Monte Carlo relaxation resolves steric clashes and elastic strain:</p> <pre><code>dna = mdna.make(n_bp=100)\ndna.minimize(\n    temperature=300,      # Kelvin\n    exvol_rad=2.0,        # Excluded volume radius\n    endpoints_fixed=True  # Pin the ends\n)\n</code></pre> <p>You can also fix specific base pairs:</p> <pre><code>dna.minimize(fixed=[0, 1, 2, 97, 98, 99])\n</code></pre> <p>To view the Monte Carlo trajectory:</p> <pre><code>mc_traj = dna.get_MC_traj()\n</code></pre>"},{"location":"guide/building/#extending-dna","title":"Extending DNA","text":"<p>Add base pairs to the 3' or 5' end of an existing structure:</p> <pre><code>dna = mdna.make(n_bp=50)\n\n# Extend forward (3' direction)\ndna.extend(sequence='G' * 30, forward=True)\n\n# Extend backward (5' direction)\ndna.extend(sequence='C' * 20, forward=False)\n\ndna.draw()\n</code></pre>"},{"location":"guide/building/#connecting-two-dna-structures","title":"Connecting Two DNA Structures","text":"<p>Join two <code>Nucleic</code> objects with an automatically optimized linker:</p> <pre><code>import numpy as np\n\ndna0 = mdna.make(sequence='AAAAAAAAA')\ndna1 = mdna.make(\n    sequence='GGGGGGGGG',\n    control_points=mdna.Shapes.line(1) + np.array([4, 0, -5])\n)\n\n# connect() finds the optimal number of linker base pairs\nconnected = mdna.connect(dna0, dna1)\nconnected.describe()\nconnected.draw()\n</code></pre> <p>The <code>connect()</code> function:</p> <ol> <li>Computes the twist difference between the two end frames</li> <li>Finds the optimal number of linking base pairs to achieve neutral twist</li> <li>Interpolates a connecting path between the two structures</li> <li>Optionally minimizes the resulting assembly</li> </ol>"},{"location":"guide/building/#exporting-structures","title":"Exporting Structures","text":""},{"location":"guide/building/#save-as-pdb","title":"Save as PDB","text":"<pre><code>dna.save_pdb('output.pdb')\n</code></pre>"},{"location":"guide/building/#get-mdtraj-trajectory","title":"Get MDTraj Trajectory","text":"<pre><code>traj = dna.get_traj()\ntraj.save('output.h5')\n</code></pre>"},{"location":"guide/building/#direct-pdb-generation","title":"Direct PDB Generation","text":"<p>For one-shot PDB generation without creating a <code>Nucleic</code> object:</p> <pre><code>traj = mdna.sequence_to_pdb(\n    sequence='CGCGAATTCGCG',\n    filename='my_dna',\n    output='GROMACS'\n)\n</code></pre>"},{"location":"guide/building/#summary","title":"Summary","text":"Task Function / Method Generate from sequence/shape <code>mdna.make()</code> Load from trajectory/frames <code>mdna.load()</code> Relax structure <code>nucleic.minimize()</code> Extend DNA <code>nucleic.extend()</code> Join two structures <code>mdna.connect()</code> Export PDB <code>nucleic.save_pdb()</code> One-shot PDB <code>mdna.sequence_to_pdb()</code> MD simulation <code>mdna.sequence_to_md()</code>"},{"location":"guide/modifying/","title":"Modifying DNA Structures","text":"<p>MDNA supports three types of modifications on existing DNA structures: mutation, methylation, and Hoogsteen flipping. All modifications update the <code>Nucleic</code> object in-place.</p>"},{"location":"guide/modifying/#mutations","title":"Mutations","text":"<p>Replace nucleobases at specific positions using a dictionary of <code>{index: new_base}</code>:</p> <pre><code>import mdna\n\ndna = mdna.make(sequence='AGCGATATAGA')\n\n# Mutate position 0 \u2192 G, position 10 \u2192 C\ndna.mutate({0: 'G', dna.n_bp - 1: 'C'})\n\ndna.describe()\n</code></pre>"},{"location":"guide/modifying/#complementary-strand","title":"Complementary Strand","text":"<p>By default, the complementary strand is updated automatically (<code>complementary=True</code>). To mutate only the leading strand:</p> <pre><code>dna.mutate({0: 'G'}, complementary=False)\n</code></pre>"},{"location":"guide/modifying/#supported-bases","title":"Supported Bases","text":"<p>MDNA supports canonical and non-canonical nucleobases:</p> Code Name Pairs With Category A Adenine T Canonical T Thymine A Canonical G Guanine C Canonical C Cytosine G Canonical U Uracil A RNA incorporation E 2-Aminopurine (2AP) T Fluorescent D tC (tricyclic cytosine) G Fluorescent L d5SICS M Hydrophobic UBP M dNaM L Hydrophobic UBP B A-analogue S Hachimoji S T-analogue B Hachimoji Z G-analogue P Hachimoji P C-analogue Z Hachimoji <p>For more details on non-canonical bases, see Non-Canonical Bases.</p> <p>Note</p> <p>Mutation clears cached frames, rigid parameters, and minimizer state. Call <code>get_frames()</code> or <code>get_traj()</code> after mutating to regenerate them.</p>"},{"location":"guide/modifying/#methylation","title":"Methylation","text":"<p>Add methyl groups to cytosine (C5 position) or guanine (O6 position):</p> <pre><code>dna = mdna.make(sequence='GCGCGCGAGCGA')\n\n# Methylate specific residue indices\ndna.methylate(methylations=[0, 2, 4])\n</code></pre>"},{"location":"guide/modifying/#cpg-methylation","title":"CpG Methylation","text":"<p>Automatically methylate all cytosines in CpG context:</p> <pre><code>dna.methylate(CpG=True, leading_strand=0)\n</code></pre> <p>Warning</p> <p>Only C and G residues can be methylated. Attempting to methylate A or T will be silently skipped with a warning message.</p>"},{"location":"guide/modifying/#hoogsteen-flipping","title":"Hoogsteen Flipping","text":"<p>Rotate nucleobases around the glycosidic bond to switch between Watson-Crick and Hoogsteen base pairing:</p> <pre><code>dna = mdna.make(sequence='GCAAAGC')\n\n# Flip base pairs 3 and 4 by 180 degrees (Hoogsteen)\ndna.flip(fliplist=[3, 4], deg=180)\n</code></pre> <p>The <code>deg</code> parameter controls the rotation angle. A 180\u00b0 flip produces the canonical Hoogsteen configuration.</p>"},{"location":"guide/modifying/#chaining-modifications","title":"Chaining Modifications","text":"<p>Modifications can be applied sequentially:</p> <pre><code>dna = mdna.make(sequence='GCGCAATTGCGC')\n\n# 1. Mutate\ndna.mutate({0: 'A', 11: 'T'})\n\n# 2. Methylate CpG sites\ndna.methylate(CpG=True, leading_strand=0)\n\n# 3. Flip a base pair\ndna.flip(fliplist=[5], deg=180)\n\n# 4. Export the modified structure\ndna.save_pdb('modified_dna.pdb')\n</code></pre>"},{"location":"guide/modifying/#summary","title":"Summary","text":"Modification Method Key Arguments Base substitution <code>nucleic.mutate()</code> <code>mutations</code> dict, <code>complementary</code> Methylation <code>nucleic.methylate()</code> <code>methylations</code> list or <code>CpG=True</code> Hoogsteen flip <code>nucleic.flip()</code> <code>fliplist</code>, <code>deg</code>"},{"location":"guide/noncanonical/","title":"Non-Canonical Nucleobases","text":"<p>MDNA supports a wide range of non-canonical and synthetic nucleobases beyond the standard A, T, G, C alphabet. This page describes all supported bases and how to use them.</p>"},{"location":"guide/noncanonical/#complementary-base-pairing-map","title":"Complementary Base Pairing Map","text":"<pre><code>complementary_map = {\n    'A': 'T',  'T': 'A',  'G': 'C',  'C': 'G',   # Canonical\n    'U': 'A',                                        # RNA\n    'E': 'T',  'D': 'G',                            # Fluorescent\n    'L': 'M',  'M': 'L',                            # Hydrophobic UBP\n    'B': 'S',  'S': 'B',  'Z': 'P',  'P': 'Z'      # Hachimoji\n}\n</code></pre>"},{"location":"guide/noncanonical/#base-categories","title":"Base Categories","text":""},{"location":"guide/noncanonical/#canonical-bases","title":"Canonical Bases","text":"Code Name Pairs With A Adenine T T Thymine A G Guanine C C Cytosine G"},{"location":"guide/noncanonical/#rna-incorporation","title":"RNA Incorporation","text":"Code Name Pairs With Reference U Uracil A \u2014 <p>Represents RNA incorporation into a DNA duplex.</p>"},{"location":"guide/noncanonical/#fluorescent-bases","title":"Fluorescent Bases","text":"Code Name Pairs With Reference E 2-Aminopurine (2AP) T Ward et al., 1969 D tC (tricyclic cytosine) G Wilhelmsson et al., 2003 <p>2-Aminopurine is widely used as a fluorescent probe due to its sensitivity to the local environment. The tricyclic cytosine analogue (tC) is known for its unique photophysical properties and high quantum yield.</p>"},{"location":"guide/noncanonical/#hydrophobic-unnatural-base-pairs","title":"Hydrophobic Unnatural Base Pairs","text":"Code Name Pairs With Reference L d5SICS M Malyshev et al., 2014 M dNaM L Malyshev et al., 2014 <p>These hydrophobic pairs maintain duplex stability without hydrogen bonding, demonstrating that shape complementarity alone can support base pairing.</p>"},{"location":"guide/noncanonical/#hachimoji-bases","title":"Hachimoji Bases","text":"Code Name Pairs With Reference B A-analogue (isoG) S Hoshika et al., 2019 S T-analogue (isoC) B Hoshika et al., 2019 Z G-analogue P Hoshika et al., 2019 P C-analogue Z Hoshika et al., 2019 <p>The Hachimoji (\"eight-letter\") DNA system extends the genetic alphabet from 4 to 8 bases, forming two new orthogonal pairs (B\u2013S and P\u2013Z).</p>"},{"location":"guide/noncanonical/#usage","title":"Usage","text":""},{"location":"guide/noncanonical/#constructing-with-non-canonical-bases","title":"Constructing with Non-Canonical Bases","text":"<p>You can include non-canonical bases directly in the sequence:</p> <pre><code>import mdna\n\n# DNA with hachimoji bases\ndna = mdna.make(sequence='ATBSCGPZ')\ndna.describe()\n</code></pre>"},{"location":"guide/noncanonical/#mutating-to-non-canonical-bases","title":"Mutating to Non-Canonical Bases","text":"<pre><code>dna = mdna.make(sequence='AGCGATATAGA')\n\n# Introduce fluorescent base at position 0 and hydrophobic pair at position 5\ndna.mutate({0: 'E', 5: 'L'}, complementary=True)\ndna.describe()\n</code></pre>"},{"location":"guide/noncanonical/#inspecting-the-complementary-map","title":"Inspecting the Complementary Map","text":"<pre><code># The Nucleic object carries the pairing map\nprint(dna.base_pair_map)\n</code></pre>"},{"location":"guide/noncanonical/#structural-notes","title":"Structural Notes","text":"<p>All non-canonical bases use reference geometries stored as HDF5 files in <code>mdna/atomic/bases/</code>. The reference frame convention follows the Tsukuba convention, with the glycosidic bond atom varying by base type:</p> <ul> <li>Purines (A, G, E, B, P): N9\u2013C4 convention</li> <li>Pyrimidines (C, T, U, D): N1\u2013C2 convention</li> <li>Hachimoji pyrimidines (S, Z): C1\u2013C2 convention</li> <li>Hydrophobic (L): N1\u2013C5 convention</li> <li>Hydrophobic (M): C1\u2013C6 convention</li> </ul> <p>These conventions ensure correct frame placement and base pair geometry for all supported nucleotides.</p>"},{"location":"guide/overview/","title":"User Guide Overview","text":"<p>The User Guide walks you through MDNA's three core workflows: Build, Modify, and Analyse. Each section contains task-oriented examples showing how to use the toolkit in practice.</p> <pre><code>graph LR\n    B[Build] --&gt; M[Modify] --&gt; A[Analyse]\n    B --&gt; A</code></pre>"},{"location":"guide/overview/#build","title":"Build","text":"<p>Create DNA structures from sequence, shape, or both. Generate linear strands, circular minicircles, custom-shaped DNA, and multi-segment assemblies.</p> <p>Building DNA \u2192</p>"},{"location":"guide/overview/#modify","title":"Modify","text":"<p>Edit existing structures: mutate bases (canonical and non-canonical), add methylation, flip nucleobases into Hoogsteen configuration.</p> <p>Modifying DNA \u2192</p>"},{"location":"guide/overview/#analyse","title":"Analyse","text":"<p>Load MD trajectories and compute rigid base parameters, linking numbers, groove widths, and torsion angles.</p> <p>Analyzing DNA \u2192</p>"},{"location":"guide/overview/#non-canonical-bases","title":"Non-Canonical Bases","text":"<p>Work with fluorescent, hachimoji, and hydrophobic base pairs beyond the standard A/T/G/C alphabet.</p> <p>Non-Canonical Bases \u2192</p>"},{"location":"guide/overview/#key-entry-points","title":"Key Entry Points","text":"<p>All high-level functions are available directly from <code>import mdna</code>:</p> Function Purpose <code>mdna.make()</code> Generate DNA from sequence and/or shape <code>mdna.load()</code> Load DNA from MDTraj trajectory or frames <code>mdna.connect()</code> Join two DNA structures <code>mdna.compute_rigid_parameters()</code> Compute rigid base parameters from a trajectory <code>mdna.sequence_to_pdb()</code> Generate PDB file from sequence <code>mdna.Shapes</code> Library of predefined DNA shapes"},{"location":"notebooks/0_structure_tutorial/","title":"DNA Structure Generation Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport nglview as nv\nimport seaborn as sns\n\nimport mdna\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import nglview as nv import seaborn as sns  import mdna <pre></pre> In\u00a0[2]: Copied! <pre># Build DNA with nothing, will output Drew Dickerson dodecamer DDD sequence\ndna = mdna.make()\ndna.describe()\n</pre> # Build DNA with nothing, will output Drew Dickerson dodecamer DDD sequence dna = mdna.make() dna.describe() <pre>Default sequence: CGCGAATTCGCG\nNumber of base pairs: 12 \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\nDNA structure with 12 base pairs\nSequence: CGCGAATTCGCG\nTrajectory not loaded\nFrames:  (12, 1, 4, 3)\n</pre> In\u00a0[3]: Copied! <pre>view = nv.show_mdtraj(dna.get_traj().atom_slice(dna.get_traj().top.select('resid 1 22')))\nview\n</pre> view = nv.show_mdtraj(dna.get_traj().atom_slice(dna.get_traj().top.select('resid 1 22'))) view <pre>NGLWidget()</pre> In\u00a0[4]: Copied! <pre># Or provide a sequence\ndna = mdna.make(sequence='GCGCGCGCGC')\ndna.describe()\n</pre> # Or provide a sequence dna = mdna.make(sequence='GCGCGCGCGC') dna.describe() <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 10\n\nDNA structure with 10 base pairs\nSequence: GCGCGCGCGC\nTrajectory not loaded\nFrames:  (10, 1, 4, 3)\n</pre> In\u00a0[5]: Copied! <pre># Or provide a number of basepairs, resulting in a random sequence\ndna = mdna.make(n_bp=10)\ndna.describe()\n</pre> # Or provide a number of basepairs, resulting in a random sequence dna = mdna.make(n_bp=10) dna.describe() <pre>Random sequence: ACTAGCTTAA \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 10\n\nDNA structure with 10 base pairs\nSequence: ACTAGCTTAA\nTrajectory not loaded\nFrames:  (10, 1, 4, 3)\n</pre> In\u00a0[6]: Copied! <pre># Or make a minicircle DNA in circular form\ndna = mdna.make(n_bp=200, circular=True)\n\ndna.draw()\nprint('Lk, Wr, Tw', dna.get_linking_number())\n</pre> # Or make a minicircle DNA in circular form dna = mdna.make(n_bp=200, circular=True)  dna.draw() print('Lk, Wr, Tw', dna.get_linking_number()) <pre>Random sequence: ACAGCGAAAACAGGCTTCTGGGTAGCAGCAGACCGACCACACCCGACGACCATGATTGGGGGAGGCACCCCCAAAAGAGACCGACATCAATGTAAAGAATACCTTTCCAATGGGTAGCCGTAGTGAGGCTTTGCTCACGGGGTTTGTCATGATTGTGCCCATCGTCCCCACCACGGTAAAACTTTGGCTAAAGTGTTCTG \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 200\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 1.71 degrees\n\tNew twist angle per base pair: 36.0 \n\nusing cython\nLk, Wr, Tw [20.  0. 20.]\n</pre> In\u00a0[7]: Copied! <pre># Let's also minimize the DNA configuration\ndna.minimize()\n\n# See the final configuration\ndna.draw()\n\n# Or save it to a file\ndna.save_pdb('./pdbs/minimized_nbp_200_closed')\n</pre> # Let's also minimize the DNA configuration dna.minimize()  # See the final configuration dna.draw()  # Or save it to a file dna.save_pdb('./pdbs/minimized_nbp_200_closed') <pre>Minimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: True\n####################################\nInitiating Excluded Volume...\nEV_bead mismatch: including additional boundary checks.\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 29\n   bp per EV bead:     7\n   Effective size:     3.57\n   Exclusion distance: 4.0\n######################################\n</pre> In\u00a0[8]: Copied! <pre># Also change the linking number by under or overwinding the DNA using the dLk parameter\ndna = mdna.make(n_bp=200, circular=True, dLk=8)\ndna.describe()\ndna.get_linking_number()\n\n# Minimize the DNA configuration,\ndna.minimize(equilibrate_writhe=True)\ndna.get_linking_number()\n</pre> # Also change the linking number by under or overwinding the DNA using the dLk parameter dna = mdna.make(n_bp=200, circular=True, dLk=8) dna.describe() dna.get_linking_number()  # Minimize the DNA configuration, dna.minimize(equilibrate_writhe=True) dna.get_linking_number() <pre>Random sequence: GCGTACACTGTTGACCAGATCTGATTAAGGGGAGGTACGTGGCGAATTACGTCCTACAATGATATTGTTATAGGACACGGCAGGTACGCGCAAACGCACTCCACGCAGAGTGCTAGATGAGGTCCCGTCCGTTTTACTACCACAAGAAGCATGAGTTTATTAATTTAGTATCAATCAGGTAATGACCACTGGGTAGGATG \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 200\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 1.71 degrees\n\tNew twist angle per base pair: 36.0 \n\nAdjusting twist angles to match the given Delta linking number: 8\n\tCurrent twist number: 20.00\n\tOld twist angle per base pair: 36.00 degrees\n\tAdjusted twist angle per base pair: 50.40 degrees\n\nCircular DNA structure with 200 base pairs\nSequence: GCGTACACTGTTGACCAGATCTGATTAAGGGGAGGTACGTGGCGAATTACGTCCTACAATGATATTGTTATAGGACACGGCAGGTACGCGCAAACGCACTCCACGCAGAGTGCTAGATGAGGTCCCGTCCGTTTTACTACCACAAGAAGCATGAGTTTATTAATTTAGTATCAATCAGGTAATGACCACTGGGTAGGATG\nTrajectory not loaded\nFrames:  (200, 1, 4, 3)\nusing cython\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = True \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: True\n####################################\nInitiating Excluded Volume...\nEV_bead mismatch: including additional boundary checks.\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 29\n   bp per EV bead:     7\n   Effective size:     3.57\n   Exclusion distance: 4.0\n######################################\nE1 = 1666.92 kT\nE2 = 1453.95 kT\nwr_equi=False\nwr1 = 1.09\nwr2 = 2.28\nE = 1429.26 kT\nE_num_below=0\nwr = 2.37\nwr_num_below=0\nE = 1418.81 kT\nE_num_below=0\nwr = 2.41\nwr_num_below=0\nE = 1423.58 kT\nE_num_below=1\nwr = 2.43\nwr_num_below=0\nE = 1430.80 kT\nE_num_below=2\nwr = 2.51\nwr_num_below=0\nE = 1399.57 kT\nE_num_below=0\nwr = 2.43\nwr_num_below=1\nE = 1374.64 kT\nE_num_below=0\nwr = 2.43\nwr_num_below=2\nE = 1385.98 kT\nE_num_below=1\nwr = 2.40\nwr_num_below=3\nE = 1382.21 kT\nE_num_below=2\nE = 1390.28 kT\nE_num_below=3\nusing cython\n</pre> Out[8]: <pre>array([28.        ,  2.36204173, 25.63795827])</pre> In\u00a0[9]: Copied! <pre># visualize using nglview MC minimization\nmc_traj = dna.get_MC_traj()\nview = nv.show_mdtraj(mc_traj)\nview.clear()\nview.add_ball_and_stick()\nview\n</pre> # visualize using nglview MC minimization mc_traj = dna.get_MC_traj() view = nv.show_mdtraj(mc_traj) view.clear() view.add_ball_and_stick() view <pre>NGLWidget(max_frame=1020)</pre> In\u00a0[10]: Copied! <pre># We can also use custom shapes using the Shape class\ncontrol_points = mdna.Shapes.helix(height=3, pitch=5, radius=7, num_turns=4)\ndna = mdna.make(n_bp=300, control_points=control_points)\ndna.draw()\n</pre> # We can also use custom shapes using the Shape class control_points = mdna.Shapes.helix(height=3, pitch=5, radius=7, num_turns=4) dna = mdna.make(n_bp=300, control_points=control_points) dna.draw() <pre>Random sequence: AATCGATTCGTACGGTGAGCGCGAGAACAGCAAGAACAGTTTAGCGACAACGGCATTCGTCCTGCAGTATTTGCACTGACTAACAAGCCTTCAGCGTTGTTCTTCAATAAATGATTGGCGGGCGAGTTGCAGGGGCTCGTCCACCGTCCAGGCGTCACTTACTAAGGCCATATTAGTTCCCTTTAGCGATCGTCCGCACTCCAGGGGGCCTTGCGTACGACGCGGGGTACGCTGATTGAAGCTGGAGCATTCGACATACAAGTGCAGTATATTCCTTAATTTCGTCGATTATCTTTATTC \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 300\n\n</pre> In\u00a0[11]: Copied! <pre># Or use the control points to define a custom shape\ncontrol_points = np.array([[0,0,0],[30,10,-10],[50,10,20],[20,4,60]])\ndna = mdna.make(n_bp=100, control_points=control_points, sequence=['A']*100)\ndna.draw()\ndna.describe()\ndna.sequence\n</pre> # Or use the control points to define a custom shape control_points = np.array([[0,0,0],[30,10,-10],[50,10,20],[20,4,60]]) dna = mdna.make(n_bp=100, control_points=control_points, sequence=['A']*100) dna.draw() dna.describe() dna.sequence <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 100\n\nDNA structure with 100 base pairs\nSequence: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 4100 atoms, 200 residues, without unitcells&gt;\nFrames:  (100, 1, 4, 3)\n</pre> Out[11]: <pre>'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'</pre> In\u00a0[12]: Copied! <pre># We can also extend our DNA \ndna.extend(sequence=['G']*40)\n\n# Or extend it in the opposite direction\ndna.extend(sequence=['C']*40, forward=False)\ndna.draw()\n</pre> # We can also extend our DNA  dna.extend(sequence=['G']*40)  # Or extend it in the opposite direction dna.extend(sequence=['C']*40, forward=False) dna.draw() <pre>Minimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: False\n####################################\nInitiating Excluded Volume...\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 20\n   bp per EV bead:     7\n   Effective size:     3.573\n   Exclusion distance: 4.0\n######################################\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 2.0 \ntemperature = 300\nCircular: False\n####################################\nInitiating Excluded Volume...\n\n######################################\n#### INITIALIZING EXCLUDED VOLUME ####\n######################################\n Excluded Volume Beads: \n   number of EV beads: 26\n   bp per EV bead:     7\n   Effective size:     3.591\n   Exclusion distance: 4.0\n######################################\n</pre> In\u00a0[13]: Copied! <pre># Lets generate two strands of DNA and displace the second one away from the first one\ndna0 = mdna.make(sequence='AAAAAAAAA', control_points=mdna.Shapes.line(1))\ndna1 = mdna.make(sequence='GGGGGGGGG', control_points=mdna.Shapes.line(1)+np.array([4,0,-5]))\n\n# Now we can connect the two strands\ndna2 = mdna.connect(dna0, dna1)\ndna2.draw()\ndna2.describe()\n</pre> # Lets generate two strands of DNA and displace the second one away from the first one dna0 = mdna.make(sequence='AAAAAAAAA', control_points=mdna.Shapes.line(1)) dna1 = mdna.make(sequence='GGGGGGGGG', control_points=mdna.Shapes.line(1)+np.array([4,0,-5]))  # Now we can connect the two strands dna2 = mdna.connect(dna0, dna1) dna2.draw() dna2.describe() <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 9\n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 9\n\nOptimal BP: 54, Twist Difference per BP: 0.002 degrees\nOptimal number of base pairs: 54\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 56\n\nRandom sequence: GACATTACAGGCCTTTCTACAGCAGTGGCGTGTGTGTTCGCACCTCGTATCCAT \n\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 0.0 \ntemperature = 300\nCircular: False\nDNA structure with 72 base pairs\nSequence: AAAAAAAAAGACATTACAGGCCTTTCTACAGCAGTGGCGTGTGTGTTCGCACCTCGTATCCATGGGGGGGGG\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 2952 atoms, 144 residues, without unitcells&gt;\nFrames:  (72, 1, 4, 3)\n</pre> In\u00a0[14]: Copied! <pre># Decision-matrix scenarios for mdna.make()\nimport pandas as pd\n\ncontrol_points_demo = np.array([\n    [0.0, 0.0, 0.0],\n    [0.5, 0.2, 0.2],\n    [1.0, 0.4, 0.0],\n    [1.5, 0.0, -0.2],\n])*10\n\nscenarios = [\n    ('default', {}),\n    ('sequence_only', {'sequence': 'GCGCGCGCGC'}),\n    ('n_bp_only', {'n_bp': 14}),\n    ('control_points_only', {'control_points': control_points_demo}),\n    ('control_points_sequence', {'control_points': control_points_demo, 'sequence': 'ATGCATGCATGC'}),\n    ('control_points_n_bp', {'control_points': control_points_demo, 'n_bp': 18}),\n    ('sequence_n_bp_match', {'sequence': 'ATGCATGC', 'n_bp': 8}),\n    ('circular_template', {'n_bp': 24, 'circular': True}),\n    ('sequence_n_bp_mismatch', {'sequence': 'ATGC', 'n_bp': 6}),\n]\n\nrows = []\nfor label, kwargs in scenarios:\n    row = {\n        'scenario': label,\n        'has_sequence': int('sequence' in kwargs and kwargs['sequence'] is not None),\n        'has_n_bp': int('n_bp' in kwargs and kwargs['n_bp'] is not None),\n        'has_control_points': int('control_points' in kwargs and kwargs['control_points'] is not None),\n        'circular': int(kwargs.get('circular', False)),\n    }\n    try:\n        dna_case = mdna.make(**kwargs)\n        row.update({\n            'status': 'ok',\n            'resolved_n_bp': dna_case.n_bp,\n            'sequence_len': len(dna_case.sequence),\n            'resolved_circular': int(dna_case.circular),\n        })\n    except Exception as exc:\n        row.update({\n            'status': f'error: {type(exc).__name__}',\n            'resolved_n_bp': np.nan,\n            'sequence_len': np.nan,\n            'resolved_circular': np.nan,\n        })\n    rows.append(row)\n\ndecision_df = pd.DataFrame(rows)\ndecision_df\n</pre> # Decision-matrix scenarios for mdna.make() import pandas as pd  control_points_demo = np.array([     [0.0, 0.0, 0.0],     [0.5, 0.2, 0.2],     [1.0, 0.4, 0.0],     [1.5, 0.0, -0.2], ])*10  scenarios = [     ('default', {}),     ('sequence_only', {'sequence': 'GCGCGCGCGC'}),     ('n_bp_only', {'n_bp': 14}),     ('control_points_only', {'control_points': control_points_demo}),     ('control_points_sequence', {'control_points': control_points_demo, 'sequence': 'ATGCATGCATGC'}),     ('control_points_n_bp', {'control_points': control_points_demo, 'n_bp': 18}),     ('sequence_n_bp_match', {'sequence': 'ATGCATGC', 'n_bp': 8}),     ('circular_template', {'n_bp': 24, 'circular': True}),     ('sequence_n_bp_mismatch', {'sequence': 'ATGC', 'n_bp': 6}), ]  rows = [] for label, kwargs in scenarios:     row = {         'scenario': label,         'has_sequence': int('sequence' in kwargs and kwargs['sequence'] is not None),         'has_n_bp': int('n_bp' in kwargs and kwargs['n_bp'] is not None),         'has_control_points': int('control_points' in kwargs and kwargs['control_points'] is not None),         'circular': int(kwargs.get('circular', False)),     }     try:         dna_case = mdna.make(**kwargs)         row.update({             'status': 'ok',             'resolved_n_bp': dna_case.n_bp,             'sequence_len': len(dna_case.sequence),             'resolved_circular': int(dna_case.circular),         })     except Exception as exc:         row.update({             'status': f'error: {type(exc).__name__}',             'resolved_n_bp': np.nan,             'sequence_len': np.nan,             'resolved_circular': np.nan,         })     rows.append(row)  decision_df = pd.DataFrame(rows) decision_df <pre>Default sequence: CGCGAATTCGCG\nNumber of base pairs: 12 \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 10\n\nRandom sequence: CACTAGCGGACATG \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 14\n\nRandom sequence: CTAGTAGGTACAGCCGTTTGATAGAGAACCCTTTGATCTGGAAGACGTCAACAGGGT \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\nRandom sequence: ACCTTGGGAGCACCTAGG \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 18\n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 8\n\nRandom sequence: CGCGATAACCAGGAGCCCGTTGAT \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 24\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 10.71 degrees\n\tNew twist angle per base pair: 45.0 \n\n</pre> Out[14]: scenario has_sequence has_n_bp has_control_points circular status resolved_n_bp sequence_len resolved_circular 0 default 0 0 0 0 ok 12.0 12.0 0.0 1 sequence_only 1 0 0 0 ok 10.0 10.0 0.0 2 n_bp_only 0 1 0 0 ok 14.0 14.0 0.0 3 control_points_only 0 0 1 0 ok 57.0 57.0 0.0 4 control_points_sequence 1 0 1 0 ok 12.0 12.0 0.0 5 control_points_n_bp 0 1 1 0 ok 18.0 18.0 0.0 6 sequence_n_bp_match 1 1 0 0 ok 8.0 8.0 0.0 7 circular_template 0 1 0 1 ok 24.0 24.0 1.0 8 sequence_n_bp_mismatch 1 1 0 0 error: ValueError NaN NaN NaN In\u00a0[15]: Copied! <pre># Visualize inputs -&gt; outcomes for make() scenarios\ninput_cols = ['has_sequence', 'has_n_bp', 'has_control_points', 'circular']\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw={'width_ratios': [1.2, 1]})\n\n# Left: input decision matrix\nsns.heatmap(\n    decision_df[input_cols],\n    ax=axes[0],\n    cmap='Blues',\n    cbar=False,\n    linewidths=0.5,\n    linecolor='white',\n    annot=True,\n    fmt='.0f',\n    yticklabels=decision_df['scenario']\n )\naxes[0].set_title('Input flags per scenario')\naxes[0].set_xlabel('input provided')\naxes[0].set_ylabel('scenario')\n\n# Right: resolved size and status\nresolved = decision_df.copy()\nok_mask = resolved['status'].eq('ok')\nx = np.arange(len(resolved))\n\naxes[1].bar(x[ok_mask], resolved.loc[ok_mask, 'resolved_n_bp'], color='tab:green', alpha=0.8, label='resolved_n_bp')\nif (~ok_mask).any():\n    axes[1].scatter(x[~ok_mask], np.zeros((~ok_mask).sum()), color='tab:red', marker='x', s=80, label='error')\n\naxes[1].plot(x[ok_mask], resolved.loc[ok_mask, 'sequence_len'], 'o', color='tab:orange', label='sequence_len')\naxes[1].set_xticks(x)\naxes[1].set_xticklabels(resolved['scenario'], rotation=45, ha='right')\naxes[1].set_ylabel('base pairs')\naxes[1].set_title('Resolved outputs')\naxes[1].legend(frameon=False)\n\nfig.tight_layout()\n\ndecision_df[['scenario', 'status', 'resolved_n_bp', 'sequence_len', 'resolved_circular']]\n</pre> # Visualize inputs -&gt; outcomes for make() scenarios input_cols = ['has_sequence', 'has_n_bp', 'has_control_points', 'circular']  fig, axes = plt.subplots(1, 2, figsize=(12, 4), gridspec_kw={'width_ratios': [1.2, 1]})  # Left: input decision matrix sns.heatmap(     decision_df[input_cols],     ax=axes[0],     cmap='Blues',     cbar=False,     linewidths=0.5,     linecolor='white',     annot=True,     fmt='.0f',     yticklabels=decision_df['scenario']  ) axes[0].set_title('Input flags per scenario') axes[0].set_xlabel('input provided') axes[0].set_ylabel('scenario')  # Right: resolved size and status resolved = decision_df.copy() ok_mask = resolved['status'].eq('ok') x = np.arange(len(resolved))  axes[1].bar(x[ok_mask], resolved.loc[ok_mask, 'resolved_n_bp'], color='tab:green', alpha=0.8, label='resolved_n_bp') if (~ok_mask).any():     axes[1].scatter(x[~ok_mask], np.zeros((~ok_mask).sum()), color='tab:red', marker='x', s=80, label='error')  axes[1].plot(x[ok_mask], resolved.loc[ok_mask, 'sequence_len'], 'o', color='tab:orange', label='sequence_len') axes[1].set_xticks(x) axes[1].set_xticklabels(resolved['scenario'], rotation=45, ha='right') axes[1].set_ylabel('base pairs') axes[1].set_title('Resolved outputs') axes[1].legend(frameon=False)  fig.tight_layout()  decision_df[['scenario', 'status', 'resolved_n_bp', 'sequence_len', 'resolved_circular']] Out[15]: scenario status resolved_n_bp sequence_len resolved_circular 0 default ok 12.0 12.0 0.0 1 sequence_only ok 10.0 10.0 0.0 2 n_bp_only ok 14.0 14.0 0.0 3 control_points_only ok 57.0 57.0 0.0 4 control_points_sequence ok 12.0 12.0 0.0 5 control_points_n_bp ok 18.0 18.0 0.0 6 sequence_n_bp_match ok 8.0 8.0 0.0 7 circular_template ok 24.0 24.0 1.0 8 sequence_n_bp_mismatch error: ValueError NaN NaN NaN In\u00a0[16]: Copied! <pre># Interactive molecular viewer for representative make() scenarios\nimport ipywidgets as widgets\nfrom IPython.display import display\n\nviz_scenarios = {\n    'default': {},\n    'sequence_only': {'sequence': 'GCGCGCGCGC'},\n    'n_bp_only': {'n_bp': 14},\n    'control_points_only': {'control_points': control_points_demo},\n    'control_points + sequence': {'control_points': control_points_demo, 'sequence': 'ATGCATGCATGC'},\n    'control_points + n_bp': {'control_points': control_points_demo, 'n_bp': 18},\n    'circular_template': {'n_bp': 24, 'circular': True},\n}\n\nviz_dna = {name: mdna.make(**kwargs) for name, kwargs in viz_scenarios.items()}\n\nselector = widgets.Dropdown(\n    options=list(viz_dna.keys()),\n    value='default',\n    description='scenario:',\n    layout=widgets.Layout(width='420px')\n)\nout = widgets.Output()\n\ndef render_case(change=None):\n    with out:\n        out.clear_output(wait=True)\n        case_name = selector.value\n        dna_case = viz_dna[case_name]\n        traj_case = dna_case.get_traj()\n        view_case = nv.show_mdtraj(traj_case)\n        view_case.clear_representations()\n        view_case.add_cartoon(color='residueindex')\n        view_case.add_licorice()\n        display(view_case)\n        print(f\"scenario={case_name} | n_bp={dna_case.n_bp} | circular={dna_case.circular} | sequence_length={len(dna_case.sequence)}\")\n\nselector.observe(render_case, names='value')\nrender_case()\nwidgets.VBox([selector, out])\n</pre> # Interactive molecular viewer for representative make() scenarios import ipywidgets as widgets from IPython.display import display  viz_scenarios = {     'default': {},     'sequence_only': {'sequence': 'GCGCGCGCGC'},     'n_bp_only': {'n_bp': 14},     'control_points_only': {'control_points': control_points_demo},     'control_points + sequence': {'control_points': control_points_demo, 'sequence': 'ATGCATGCATGC'},     'control_points + n_bp': {'control_points': control_points_demo, 'n_bp': 18},     'circular_template': {'n_bp': 24, 'circular': True}, }  viz_dna = {name: mdna.make(**kwargs) for name, kwargs in viz_scenarios.items()}  selector = widgets.Dropdown(     options=list(viz_dna.keys()),     value='default',     description='scenario:',     layout=widgets.Layout(width='420px') ) out = widgets.Output()  def render_case(change=None):     with out:         out.clear_output(wait=True)         case_name = selector.value         dna_case = viz_dna[case_name]         traj_case = dna_case.get_traj()         view_case = nv.show_mdtraj(traj_case)         view_case.clear_representations()         view_case.add_cartoon(color='residueindex')         view_case.add_licorice()         display(view_case)         print(f\"scenario={case_name} | n_bp={dna_case.n_bp} | circular={dna_case.circular} | sequence_length={len(dna_case.sequence)}\")  selector.observe(render_case, names='value') render_case() widgets.VBox([selector, out]) <pre>Default sequence: CGCGAATTCGCG\nNumber of base pairs: 12 \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 10\n\nRandom sequence: AACGGACATGGGTG \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 14\n\nRandom sequence: GGCCGAGCAACGCTGTAAAGCGTAGGCAACCAACGACCGTTAGAATGCCCTAATTGT \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\nRandom sequence: AAACAGCAATTATACCGT \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 18\n\nRandom sequence: GCCTCTTAGAAGCCCGCCTCTCTC \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 24\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 10.71 degrees\n\tNew twist angle per base pair: 45.0 \n\n</pre> Out[16]: <pre>VBox(children=(Dropdown(description='scenario:', layout=Layout(width='420px'), options=('default', 'sequence_o\u2026</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/0_structure_tutorial/#dna-structure-generation-tutorial","title":"DNA Structure Generation Tutorial\u00b6","text":"<p>Welcome to the DNA structure generation tutorial using the MDNA module. This notebook will guide you through various ways to generate and manipulate DNA structures. You'll learn to:</p> <ul> <li>Generate DNA sequences from scratch.</li> <li>Use custom sequences and define DNA topology to manipulate the linking number</li> <li>Apply custom shapes using control points</li> <li>Visualize and save DNA structures.</li> </ul>"},{"location":"notebooks/0_structure_tutorial/#basic-dna-structure-generation","title":"Basic DNA Structure Generation\u00b6","text":"<p>We start by generating a basic DNA structure using default settings, which outputs a DNA sequence known as the Drew Dickerson dodecamer.</p>"},{"location":"notebooks/0_structure_tutorial/#specifying-a-sequence","title":"Specifying a Sequence\u00b6","text":"<p>You can specify a DNA sequence directly when generating the structure. Note, this will by default generate a linear strand of DNA.</p>"},{"location":"notebooks/0_structure_tutorial/#generating-dna-with-specific-base-pairs","title":"Generating DNA with Specific Base Pairs\u00b6","text":"<p>Generate a DNA structure with a defined number of base pairs, resulting in a random sequence.</p>"},{"location":"notebooks/0_structure_tutorial/#creating-circular-dna-structures","title":"Creating Circular DNA Structures\u00b6","text":"<p>Generate circular DNA structures, commonly known as minicircles.</p>"},{"location":"notebooks/0_structure_tutorial/#minimizing-the-dna-structure","title":"Minimizing the DNA structure\u00b6","text":"<p>After generating the structure, you can minimize it to find a more energetically favorable conformation. The resulting structure is an idealized minicircle, however, if we can also minimize the DNA configuration using Monte Carlo (MC) simulations using a twistable worm like chain (TWLC) model of dsDNA.</p>"},{"location":"notebooks/0_structure_tutorial/#modifying-linking-number","title":"Modifying Linking Number\u00b6","text":"<p>Change the linking number by underwinding or overwinding the DNA using the <code>dLk</code> parameter. Note, to equilibrate the writhe use <code>equilibrate_writhe=True</code>, otherwise the linking number of the topology will not be conserved.</p>"},{"location":"notebooks/0_structure_tutorial/#visualizing-dna-minimization","title":"Visualizing DNA Minimization\u00b6","text":"<p>Use NGLview to visualize molecular dynamics and in our case the results of Monte Carlo minimization.</p>"},{"location":"notebooks/0_structure_tutorial/#using-custom-shapes","title":"Using Custom Shapes\u00b6","text":"<p>Explore the use of custom shapes for DNA structures through control points, allowing complex configurations. The <code>Shapes</code> class contains many predefined parametric functions that describe common shapes in 3D space. Utilize custom shapes for DNA structure generation, including helical shapes and more.</p>"},{"location":"notebooks/0_structure_tutorial/#defining-complex-custom-shapes","title":"Defining Complex Custom Shapes\u00b6","text":"<p>Define intricate shapes by specifying control points manually. The points are used to fit a B-spline that goes through each of these points. Note, the minimum number of <code>control_points</code> to fit a spline through is 4.</p>"},{"location":"notebooks/0_structure_tutorial/#extending-dna-sequences","title":"Extending DNA Sequences\u00b6","text":"<p>We can use the custom shaped DNA structure to learn how to extend DNA sequences from both ends. By default the minimization is on using the <code>.extend()</code> function.</p>"},{"location":"notebooks/0_structure_tutorial/#connecting-two-dna-strands","title":"Connecting Two DNA Strands\u00b6","text":"<p>Connect two separate DNA strands and visualize the configuration. This function will find the optimal number of basepairs to connect the two strands to minimize the twist. Alternatively you can also pass the <code>n_bp</code> or <code>control_points</code>.</p>"},{"location":"notebooks/0_structure_tutorial/#understanding-make-decision-logic","title":"Understanding <code>make()</code> Decision Logic\u00b6","text":"<p>The behavior of <code>mdna.make()</code> depends on which inputs are provided (<code>sequence</code>, <code>n_bp</code>, <code>control_points</code>, <code>circular</code>). The next cells run a set of representative scenarios and visualize how those inputs resolve into the final DNA object. For <code>control_points</code>-only input (<code>sequence=None</code>, <code>n_bp=None</code>), the number of base pairs is inferred from the spline/frame spacing (shape-dependent), not from the default dodecamer.</p> <p>Scenarios include:</p> <ul> <li>default call (no inputs)</li> <li>sequence only</li> <li>n_bp only</li> <li>control points only (infer <code>n_bp</code>)</li> <li>control points + sequence</li> <li>control points + <code>n_bp</code></li> <li>matching <code>sequence</code> + <code>n_bp</code></li> <li>circular template</li> <li>mismatched <code>sequence</code> + <code>n_bp</code> (expected error)</li> </ul>"},{"location":"notebooks/0_structure_tutorial/#molecular-visualization-of-make-decision-outcomes","title":"Molecular visualization of <code>make()</code> decision outcomes\u00b6","text":"<p>Use the selector below to interactively compare 3D structures produced by different <code>make()</code> input combinations. This makes it easier to connect the decision matrix to actual structural outcomes.</p>"},{"location":"notebooks/1_visualization_tutorial/","title":"Visualization Tutorial","text":"In\u00a0[1]: Copied! <pre>import mdna\n</pre> import mdna <p>Welcome to the DNA visualization tutorial using the MDNA module. This notebook will demonstrate different ways to visualize DNA structures. You'll learn to:</p> <ul> <li>Perform basic DNA drawing.</li> <li>Customize drawing styles and visual aspects of DNA structures.</li> <li>Integrate multiple DNA visualizations in a single plot.</li> </ul> In\u00a0[2]: Copied! <pre># Basic drawing\ndna = mdna.make(n_bp=24)\ndna.draw()\n</pre> # Basic drawing dna = mdna.make(n_bp=24) dna.draw() <pre>Random sequence: GGAATCAGTTGCTGTGAGGAAGCC \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 24\n\n</pre> In\u00a0[3]: Copied! <pre># Change styling\ndna.draw(backbone=True, triads=False, helical_axis=True, lw=3, markersize=4, color_anti='red', color_lead='blue', color_axis='green')\n</pre> # Change styling dna.draw(backbone=True, triads=False, helical_axis=True, lw=3, markersize=4, color_anti='red', color_lead='blue', color_axis='green') In\u00a0[4]: Copied! <pre># Draw mean reference frames of base pairs\ndna.draw(backbone=False, triads=True)\n\n# Change styling\ndna.draw(backbone=False, triads=True, length=1)\n</pre> # Draw mean reference frames of base pairs dna.draw(backbone=False, triads=True)  # Change styling dna.draw(backbone=False, triads=True, length=1) In\u00a0[5]: Copied! <pre># Add multiple drawings to the same figure\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\ndna1 = mdna.make(n_bp=100, circular=True)\ndna1.draw(ax=ax, lw=1, color_anti='blue')\n\nshape = np.array([[15,5,5],[3,3,3],[2,2,2],[0,0,0]])\ndna2 = mdna.make(control_points=shape,n_bp=50)\ndna2.draw(ax=ax, color_anti='red')\n</pre> # Add multiple drawings to the same figure import matplotlib.pyplot as plt import numpy as np  fig = plt.figure() ax = fig.add_subplot(111, projection='3d')  dna1 = mdna.make(n_bp=100, circular=True) dna1.draw(ax=ax, lw=1, color_anti='blue')  shape = np.array([[15,5,5],[3,3,3],[2,2,2],[0,0,0]]) dna2 = mdna.make(control_points=shape,n_bp=50) dna2.draw(ax=ax, color_anti='red') <pre>Random sequence: CTTGTTCACTGGAACGCAAAGCTGCTGTCTACGCTATGCCGGATCGTAAAGTCGTATTTTAGAGTAATCGAGGACTAGAATTTTGGGCTTTCGCATGTAT \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 100\n\nStructure is requested to be circular:\n\tExcess twist per base to make ends meet: 1.71 degrees\n\tNew twist angle per base pair: 36.0 \n\nRandom sequence: AGAGCACCATATTCGACGACTCTAAATCGTGCTCCATGACCTCACTCACG \n\n\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 50\n\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/1_visualization_tutorial/#visualization-tutorial","title":"Visualization Tutorial\u00b6","text":""},{"location":"notebooks/1_visualization_tutorial/#basic-dna-drawing","title":"Basic DNA Drawing\u00b6","text":"<p>Start by generating a simple DNA structure and drawing it using default settings.</p>"},{"location":"notebooks/1_visualization_tutorial/#advanced-drawing-options","title":"Advanced Drawing Options\u00b6","text":"<p>Customize the drawing by adjusting styles and adding components like helical axes.</p>"},{"location":"notebooks/1_visualization_tutorial/#drawing-mean-reference-frames-of-base-pairs","title":"Drawing Mean Reference Frames of Base Pairs\u00b6","text":"<p>Visualize only the reference frames without the backbone for clarity.</p>"},{"location":"notebooks/1_visualization_tutorial/#combining-multiple-dna-structures-in-one-figure","title":"Combining Multiple DNA Structures in One Figure\u00b6","text":"<p>Combine multiple DNA structures in a single 3D plot using matplotlib.</p>"},{"location":"notebooks/2_modification_tutorial/","title":"Modification Tutorial","text":"<p>Welcome to the DNA modification tutorial using the MDNA module. This notebook will demonstrate how to modify DNA structures using mutation, methylation, and flipping techniques. You'll learn to:</p> <ul> <li>Mutate specific bases in a DNA sequence.</li> <li>Apply methylation to DNA bases and explore its effects.</li> <li>Perform Hoogsteen base flipping to study alternative DNA structures.</li> <li>Save and visualize the modified DNA structures.</li> </ul> In\u00a0[1]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport nglview as nv\n\nimport mdna\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import nglview as nv  import mdna <pre></pre> In\u00a0[2]: Copied! <pre># Here we make a DNA with the following sequence\ndna = mdna.make(sequence='AGCGATATAGA')\n</pre> # Here we make a DNA with the following sequence dna = mdna.make(sequence='AGCGATATAGA') <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 11\n\n</pre> In\u00a0[3]: Copied! <pre># Let's save the original structure\ntraj = dna.get_traj()\ntraj.save_pdb('./pdbs/dna_original.pdb')\n</pre> # Let's save the original structure traj = dna.get_traj() traj.save_pdb('./pdbs/dna_original.pdb') In\u00a0[4]: Copied! <pre># Let's mutate the first base to a G and the last base to a C\ndna.mutate(mutations={0: 'G', dna.n_bp-1: 'C'})\n\n# Get information about the DNA and see the mutated sequence\ndna.describe()\n</pre> # Let's mutate the first base to a G and the last base to a C dna.mutate(mutations={0: 'G', dna.n_bp-1: 'C'})  # Get information about the DNA and see the mutated sequence dna.describe() <pre>hello\nPre-deletion residue atoms : [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N9'), (12, 'C8'), (13, 'N7'), (14, 'C5'), (15, 'C6'), (16, 'N6'), (17, 'N1'), (18, 'C2'), (19, 'N3'), (20, 'C4')]\nPre-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\")]\nPost-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N9'), (12, 'C8'), (13, 'N7'), (14, 'C5'), (15, 'C6'), (16, 'O6'), (17, 'N1'), (18, 'C2'), (19, 'N2'), (20, 'N3'), (21, 'C4')]\nOriginal trajectory shape: (1, 451, 3)\nxyz1 shape: (1, 11, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 430, 3)\nConcatenated shape: 452\nPre-deletion residue atoms : [(210, 'P'), (211, 'OP1'), (212, 'OP2'), (213, \"O5'\"), (214, \"C5'\"), (215, \"C4'\"), (216, \"O4'\"), (217, \"C3'\"), (218, \"O3'\"), (219, \"C2'\"), (220, \"C1'\"), (221, 'N9'), (222, 'C8'), (223, 'N7'), (224, 'C5'), (225, 'C6'), (226, 'N6'), (227, 'N1'), (228, 'C2'), (229, 'N3'), (230, 'C4')]\nPre-insertion residue atoms: [(210, 'P'), (211, 'OP1'), (212, 'OP2'), (213, \"O5'\"), (214, \"C5'\"), (215, \"C4'\"), (216, \"O4'\"), (217, \"C3'\"), (218, \"O3'\"), (219, \"C2'\"), (220, \"C1'\")]\nPost-insertion residue atoms: [(210, 'P'), (211, 'OP1'), (212, 'OP2'), (213, \"O5'\"), (214, \"C5'\"), (215, \"C4'\"), (216, \"O4'\"), (217, \"C3'\"), (218, \"O3'\"), (219, \"C2'\"), (220, \"C1'\"), (221, 'N1'), (222, 'C2'), (223, 'O2'), (224, 'N3'), (225, 'C4'), (226, 'N4'), (227, 'C5'), (228, 'C6')]\nOriginal trajectory shape: (1, 452, 3)\nxyz1 shape: (1, 221, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 221, 3)\nConcatenated shape: 450\nPre-deletion residue atoms : [(430, 'P'), (431, 'OP1'), (432, 'OP2'), (433, \"O5'\"), (434, \"C5'\"), (435, \"C4'\"), (436, \"O4'\"), (437, \"C3'\"), (438, \"O3'\"), (439, \"C2'\"), (440, \"C1'\"), (441, 'N1'), (442, 'C2'), (443, 'O2'), (444, 'N3'), (445, 'C4'), (446, 'O4'), (447, 'C5'), (448, 'C7'), (449, 'C6')]\nPre-insertion residue atoms: [(430, 'P'), (431, 'OP1'), (432, 'OP2'), (433, \"O5'\"), (434, \"C5'\"), (435, \"C4'\"), (436, \"O4'\"), (437, \"C3'\"), (438, \"O3'\"), (439, \"C2'\"), (440, \"C1'\")]\nPost-insertion residue atoms: [(430, 'P'), (431, 'OP1'), (432, 'OP2'), (433, \"O5'\"), (434, \"C5'\"), (435, \"C4'\"), (436, \"O4'\"), (437, \"C3'\"), (438, \"O3'\"), (439, \"C2'\"), (440, \"C1'\"), (442, 'N1'), (444, 'C2'), (446, 'O2'), (448, 'N3'), (450, 'C4'), (452, 'N4'), (454, 'C5'), (456, 'C6')]\nOriginal trajectory shape: (1, 450, 3)\nxyz1 shape: (1, 441, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 0, 3)\nConcatenated shape: 449\nPre-deletion residue atoms : [(229, 'P'), (230, 'OP1'), (231, 'OP2'), (232, \"O5'\"), (233, \"C5'\"), (234, \"C4'\"), (235, \"O4'\"), (236, \"C3'\"), (237, \"O3'\"), (238, \"C2'\"), (239, \"C1'\"), (240, 'N1'), (241, 'C2'), (242, 'O2'), (243, 'N3'), (244, 'C4'), (245, 'O4'), (246, 'C5'), (247, 'C7'), (248, 'C6')]\nPre-insertion residue atoms: [(229, 'P'), (230, 'OP1'), (231, 'OP2'), (232, \"O5'\"), (233, \"C5'\"), (234, \"C4'\"), (235, \"O4'\"), (236, \"C3'\"), (237, \"O3'\"), (238, \"C2'\"), (239, \"C1'\")]\nPost-insertion residue atoms: [(229, 'P'), (230, 'OP1'), (231, 'OP2'), (232, \"O5'\"), (233, \"C5'\"), (234, \"C4'\"), (235, \"O4'\"), (236, \"C3'\"), (237, \"O3'\"), (238, \"C2'\"), (239, \"C1'\"), (240, 'N9'), (241, 'C8'), (242, 'N7'), (243, 'C5'), (244, 'C6'), (245, 'O6'), (246, 'N1'), (247, 'C2'), (248, 'N2'), (249, 'N3'), (250, 'C4')]\nOriginal trajectory shape: (1, 449, 3)\nxyz1 shape: (1, 240, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 200, 3)\nConcatenated shape: 451\nDNA structure with 11 base pairs\nSequence: GGCGATATAGC\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 451 atoms, 22 residues, without unitcells&gt;\nFrames not loaded\n</pre> In\u00a0[5]: Copied! <pre># Use methylation list, here we methylate the 5th position, which is T, so methylation won't work but is caught by the function\ndna.methylate(methylations=[5])\n\n# Or use the methylation function to methylate all CpG sites\ndna.methylate(CpG=True)\n</pre> # Use methylation list, here we methylate the 5th position, which is T, so methylation won't work but is caught by the function dna.methylate(methylations=[5])  # Or use the methylation function to methylate all CpG sites dna.methylate(CpG=True) <pre>Residue DT6 with methylations index 5 could not be methylated.\nMethylate all C in CpG context, superseeds methylations list.\nMethtylating: [2]\n</pre> In\u00a0[6]: Copied! <pre># Hoogsteen flip can be done at any base pair, here we flip the 5th base pair\ndna.flip(fliplist=[5], deg=180)\n</pre> # Hoogsteen flip can be done at any base pair, here we flip the 5th base pair dna.flip(fliplist=[5], deg=180) <pre>Flipped residues [5] by 3.141592653589793 radians\n</pre> In\u00a0[7]: Copied! <pre># Get trajectory or save as pdb\ntraj_mod = dna.get_traj()\ntraj_mod.save_pdb('./pdbs/dna_modified.pdb')\n</pre> # Get trajectory or save as pdb traj_mod = dna.get_traj() traj_mod.save_pdb('./pdbs/dna_modified.pdb') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/2_modification_tutorial/#modification-tutorial","title":"Modification Tutorial\u00b6","text":""},{"location":"notebooks/2_modification_tutorial/#initial-dna-structure-generation","title":"Initial DNA Structure Generation\u00b6","text":"<p>We begin by generating a DNA structure with a specific sequence to prepare it for modifications.</p>"},{"location":"notebooks/2_modification_tutorial/#saving-the-original-dna-structure","title":"Saving the Original DNA Structure\u00b6","text":"<p>It's often useful to save the original DNA structure before modifications for comparison purposes.</p>"},{"location":"notebooks/2_modification_tutorial/#dna-mutation","title":"DNA Mutation\u00b6","text":"<p>Modify specific bases within the DNA sequence to see how mutations affect the structure and properties.</p>"},{"location":"notebooks/2_modification_tutorial/#dna-methylation","title":"DNA Methylation\u00b6","text":"<p>Apply methylation to specific bases or patterns within the DNA sequence.</p>"},{"location":"notebooks/2_modification_tutorial/#hoogsteen-base-flipping","title":"Hoogsteen Base Flipping\u00b6","text":"<p>Perform Hoogsteen flips on specific bases to explore alternative DNA configurations.</p>"},{"location":"notebooks/2_modification_tutorial/#saving-and-viewing-modified-dna-structures","title":"Saving and Viewing Modified DNA Structures\u00b6","text":"<p>After modification, save the new DNA structure and compare it to the original.</p>"},{"location":"notebooks/3_analysis_tutorial/","title":"Analysis Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport mdna\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import seaborn as sns  import mdna  In\u00a0[2]: Copied! <pre># Initiate a DNA simulation using OpenMM \ntraj = mdna.sequence_to_md(sequence='GCAATATATTGC', time=1, time_unit='picoseconds', solvated=True, save_location='./data/')\ntraj.center_coordinates()\n</pre> # Initiate a DNA simulation using OpenMM  traj = mdna.sequence_to_md(sequence='GCAATATATTGC', time=1, time_unit='picoseconds', solvated=True, save_location='./data/') traj.center_coordinates() <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 12\n\n</pre> <pre>Initialize DNA openMM simulation at 310 K for 1 ps time units\nSolvate DNA with padding of 1.0 nm and 0.1 M KCl\nMinimize energy\nRun simulation for 500 steps\nSimulation completed\nSaved trajectory as: ./data/my_dna.h5\n</pre> Out[2]: <pre>&lt;mdtraj.Trajectory with 5 frames, 17169 atoms, 5521 residues, and unitcells at 0x17c8a88c0&gt;</pre> In\u00a0[3]: Copied! <pre># Find index of residue in the middle of the DNA structure\nindices = traj.top.select('resid 4')\nresidx = traj.topology.atom(indices[0]).residue.index\nanchor_molecules=[set(traj.topology.residue(residx).atoms)]\n\n# Put everything in the same box based on the anchor residue\ntraj = traj.image_molecules(anchor_molecules=anchor_molecules)\ntraj = traj.superpose(traj, 0)\n</pre> # Find index of residue in the middle of the DNA structure indices = traj.top.select('resid 4') residx = traj.topology.atom(indices[0]).residue.index anchor_molecules=[set(traj.topology.residue(residx).atoms)]  # Put everything in the same box based on the anchor residue traj = traj.image_molecules(anchor_molecules=anchor_molecules) traj = traj.superpose(traj, 0) In\u00a0[4]: Copied! <pre># Load the trajectory\ndna = mdna.load(traj)\n\n# Extract mean reference frames and base reference frames\nmean_frames = dna.get_frames()\nprint(mean_frames.shape)\n\nbase_frames = dna.get_base_frames()\nfor res, ref in base_frames.items():\n    print(res, ref.shape)\n    break\n</pre> # Load the trajectory dna = mdna.load(traj)  # Extract mean reference frames and base reference frames mean_frames = dna.get_frames() print(mean_frames.shape)  base_frames = dna.get_base_frames() for res, ref in base_frames.items():     print(res, ref.shape)     break <pre>(12, 5, 4, 3)\nDG1 (5, 4, 3)\n</pre> In\u00a0[5]: Copied! <pre># Extract and visualize parameters\nbase, names = dna.get_parameters(base=True)\nprint(base.shape, names)\n\nstep, names = dna.get_parameters(step=True)\nprint(step.shape, names)\n\nparams, names = dna.get_parameters()\nprint(params.shape, names)\n</pre> # Extract and visualize parameters base, names = dna.get_parameters(base=True) print(base.shape, names)  step, names = dna.get_parameters(step=True) print(step.shape, names)  params, names = dna.get_parameters() print(params.shape, names) <pre>(5, 12, 6) ['shear', 'stretch', 'stagger', 'buckle', 'propeller', 'opening']\n(5, 12, 6) ['shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n(5, 12, 12) ['shear', 'stretch', 'stagger', 'buckle', 'propeller', 'opening', 'shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n</pre> <p>We can also extract just a single parameter</p> In\u00a0[6]: Copied! <pre>name = 'twist'\npara = dna.get_parameter(name)\nprint(para.shape)\n</pre> name = 'twist' para = dna.get_parameter(name) print(para.shape) <pre>(5, 12)\n</pre> <p>Next we plot</p> In\u00a0[7]: Copied! <pre># Plot the twist parameter with overlay of fitted-reference analysis\nfig, ax = plt.subplots(figsize=[6,3])\n\n# Original (no fitting)\nname = 'twist'\npara = dna.get_parameter(name)\nmean = np.mean(para, axis=0)\nstd = np.std(para, axis=0)\nx = np.arange(len(mean))\nax.fill_between(x, mean-std, mean+std, color='tab:orange', alpha=0.20)\nax.plot(x, mean, color='tab:orange', lw=1.5, label='no fitting')\nax.scatter(x=x, y=mean, color='tab:orange', s=10)\n\n# Fitted (canonical-base alignment)\nrigid_fit = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=True)\npara_fit = rigid_fit.get_parameter(name)\nmean_fit = np.mean(para_fit, axis=0)\nstd_fit = np.std(para_fit, axis=0)\nax.fill_between(x, mean_fit-std_fit, mean_fit+std_fit, color='tab:blue', alpha=0.20)\nax.plot(x, mean_fit, color='tab:blue', lw=1.5, label='fitted')\nax.scatter(x=x, y=mean_fit, color='tab:blue', s=10)\n\nax.set_title(f'{name}: no fitting vs fitted')\nax.set_ylabel(f'{name} [degrees]')\nax.set_xlabel('Base pair step')\nbase_map = dna.base_pair_map\nanti_sequence = [base_map[c] for c in dna.sequence]\nbase_pairs = [f'{i}-{j}' for i, j in zip(dna.sequence, anti_sequence)]\nax.set_xticks(x)\n_ = ax.set_xticklabels(base_pairs, rotation=45)\nax.legend(frameon=False)\nfig.tight_layout()\n</pre> # Plot the twist parameter with overlay of fitted-reference analysis fig, ax = plt.subplots(figsize=[6,3])  # Original (no fitting) name = 'twist' para = dna.get_parameter(name) mean = np.mean(para, axis=0) std = np.std(para, axis=0) x = np.arange(len(mean)) ax.fill_between(x, mean-std, mean+std, color='tab:orange', alpha=0.20) ax.plot(x, mean, color='tab:orange', lw=1.5, label='no fitting') ax.scatter(x=x, y=mean, color='tab:orange', s=10)  # Fitted (canonical-base alignment) rigid_fit = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=True) para_fit = rigid_fit.get_parameter(name) mean_fit = np.mean(para_fit, axis=0) std_fit = np.std(para_fit, axis=0) ax.fill_between(x, mean_fit-std_fit, mean_fit+std_fit, color='tab:blue', alpha=0.20) ax.plot(x, mean_fit, color='tab:blue', lw=1.5, label='fitted') ax.scatter(x=x, y=mean_fit, color='tab:blue', s=10)  ax.set_title(f'{name}: no fitting vs fitted') ax.set_ylabel(f'{name} [degrees]') ax.set_xlabel('Base pair step') base_map = dna.base_pair_map anti_sequence = [base_map[c] for c in dna.sequence] base_pairs = [f'{i}-{j}' for i, j in zip(dna.sequence, anti_sequence)] ax.set_xticks(x) _ = ax.set_xticklabels(base_pairs, rotation=45) ax.legend(frameon=False) fig.tight_layout() In\u00a0[8]: Copied! <pre># Per-base-pair distribution comparison (box + KDE) + inference time analysis\nimport time\n\ntarget_name = 'twist'\n\n# Collect parameter trajectories for the selected parameter\npara_no_fit = dna.get_parameter(target_name)\nrigid_fit = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=True)\npara_fit = rigid_fit.get_parameter(target_name)\n\nn_bp = para_no_fit.shape[1]\nx = np.arange(n_bp)\nbase_map = dna.base_pair_map\nanti_sequence = [base_map[c] for c in dna.sequence]\nbase_pairs = [f'{i}-{j}' for i, j in zip(dna.sequence, anti_sequence)]\n\n# --- Distribution per base pair (across trajectory frames): boxplots ---\nfig, ax = plt.subplots(figsize=(max(7, 0.45*n_bp), 3.5))\nwidth = 0.35\n\nbp_no = ax.boxplot(\n    [para_no_fit[:, i] for i in range(n_bp)],\n    positions=x - width/2, widths=width, patch_artist=True, showfliers=False\n )\nbp_fit = ax.boxplot(\n    [para_fit[:, i] for i in range(n_bp)],\n    positions=x + width/2, widths=width, patch_artist=True, showfliers=False\n )\n\nfor patch in bp_no['boxes']:\n    patch.set_facecolor('tab:orange')\n    patch.set_alpha(0.35)\nfor patch in bp_fit['boxes']:\n    patch.set_facecolor('tab:blue')\n    patch.set_alpha(0.35)\n\nax.set_title(f'Distribution per base pair (boxplot): {target_name}')\nax.set_ylabel(f'{target_name} [degrees]')\nax.set_xlabel('Base pair step')\nax.set_xticks(x)\nax.set_xticklabels(base_pairs, rotation=45)\nax.legend([bp_no['boxes'][0], bp_fit['boxes'][0]], ['no fitting', 'fitted'], frameon=False)\nfig.tight_layout()\n\n# --- Distribution per base pair (across trajectory frames): KDE overlays ---\nn_cols = min(4, n_bp)\nn_rows = int(np.ceil(n_bp / n_cols))\nfig_kde, axes = plt.subplots(n_rows, n_cols, figsize=(3.2*n_cols, 2.2*n_rows), sharex=False, sharey=False)\naxes = np.atleast_1d(axes).ravel()\n\nfor i in range(n_bp):\n    ax_i = axes[i]\n    sns.kdeplot(para_no_fit[:, i], ax=ax_i, color='tab:orange', fill=True, alpha=0.25, lw=1.2, label='no fitting' if i == 0 else None)\n    sns.kdeplot(para_fit[:, i], ax=ax_i, color='tab:blue', fill=True, alpha=0.25, lw=1.2, label='fitted' if i == 0 else None)\n    ax_i.set_title(base_pairs[i], fontsize=9)\n    ax_i.set_xlabel(target_name if i // n_cols == n_rows - 1 else '')\n    ax_i.set_ylabel('density' if i % n_cols == 0 else '')\n\nfor j in range(n_bp, len(axes)):\n    axes[j].axis('off')\n\nhandles, labels = axes[0].get_legend_handles_labels()\nif handles:\n    fig_kde.legend(handles, labels, loc='upper right', frameon=False)\nfig_kde.suptitle(f'Per-base-pair KDE: {target_name}', y=1.02)\nfig_kde.tight_layout()\n\n# --- Inference time analysis ---\nn_repeats = 5\ntime_no_fit = []\ntime_fit = []\n\nfor _ in range(n_repeats):\n    t0 = time.perf_counter()\n    _ = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=False)\n    time_no_fit.append(time.perf_counter() - t0)\n\n    t0 = time.perf_counter()\n    _ = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=True)\n    time_fit.append(time.perf_counter() - t0)\n\nmean_no, std_no = np.mean(time_no_fit), np.std(time_no_fit)\nmean_fit, std_fit = np.mean(time_fit), np.std(time_fit)\nslowdown = mean_fit / mean_no if mean_no &gt; 0 else np.nan\n\nfig_t, ax_t = plt.subplots(figsize=(4.2, 3))\nax_t.bar(['no fitting', 'fitted'], [mean_no, mean_fit], yerr=[std_no, std_fit],\n         color=['tab:orange', 'tab:blue'], alpha=0.8, capsize=4)\nax_t.set_ylabel('time [s]')\nax_t.set_title(f'Runtime over {n_repeats} runs')\nfig_t.tight_layout()\n\nprint(f'no fitting: {mean_no:.4f} \u00b1 {std_no:.4f} s')\nprint(f'fitted:    {mean_fit:.4f} \u00b1 {std_fit:.4f} s')\nprint(f'slowdown (fitted/no fitting): {slowdown:.2f}x')\n</pre> # Per-base-pair distribution comparison (box + KDE) + inference time analysis import time  target_name = 'twist'  # Collect parameter trajectories for the selected parameter para_no_fit = dna.get_parameter(target_name) rigid_fit = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=True) para_fit = rigid_fit.get_parameter(target_name)  n_bp = para_no_fit.shape[1] x = np.arange(n_bp) base_map = dna.base_pair_map anti_sequence = [base_map[c] for c in dna.sequence] base_pairs = [f'{i}-{j}' for i, j in zip(dna.sequence, anti_sequence)]  # --- Distribution per base pair (across trajectory frames): boxplots --- fig, ax = plt.subplots(figsize=(max(7, 0.45*n_bp), 3.5)) width = 0.35  bp_no = ax.boxplot(     [para_no_fit[:, i] for i in range(n_bp)],     positions=x - width/2, widths=width, patch_artist=True, showfliers=False  ) bp_fit = ax.boxplot(     [para_fit[:, i] for i in range(n_bp)],     positions=x + width/2, widths=width, patch_artist=True, showfliers=False  )  for patch in bp_no['boxes']:     patch.set_facecolor('tab:orange')     patch.set_alpha(0.35) for patch in bp_fit['boxes']:     patch.set_facecolor('tab:blue')     patch.set_alpha(0.35)  ax.set_title(f'Distribution per base pair (boxplot): {target_name}') ax.set_ylabel(f'{target_name} [degrees]') ax.set_xlabel('Base pair step') ax.set_xticks(x) ax.set_xticklabels(base_pairs, rotation=45) ax.legend([bp_no['boxes'][0], bp_fit['boxes'][0]], ['no fitting', 'fitted'], frameon=False) fig.tight_layout()  # --- Distribution per base pair (across trajectory frames): KDE overlays --- n_cols = min(4, n_bp) n_rows = int(np.ceil(n_bp / n_cols)) fig_kde, axes = plt.subplots(n_rows, n_cols, figsize=(3.2*n_cols, 2.2*n_rows), sharex=False, sharey=False) axes = np.atleast_1d(axes).ravel()  for i in range(n_bp):     ax_i = axes[i]     sns.kdeplot(para_no_fit[:, i], ax=ax_i, color='tab:orange', fill=True, alpha=0.25, lw=1.2, label='no fitting' if i == 0 else None)     sns.kdeplot(para_fit[:, i], ax=ax_i, color='tab:blue', fill=True, alpha=0.25, lw=1.2, label='fitted' if i == 0 else None)     ax_i.set_title(base_pairs[i], fontsize=9)     ax_i.set_xlabel(target_name if i // n_cols == n_rows - 1 else '')     ax_i.set_ylabel('density' if i % n_cols == 0 else '')  for j in range(n_bp, len(axes)):     axes[j].axis('off')  handles, labels = axes[0].get_legend_handles_labels() if handles:     fig_kde.legend(handles, labels, loc='upper right', frameon=False) fig_kde.suptitle(f'Per-base-pair KDE: {target_name}', y=1.02) fig_kde.tight_layout()  # --- Inference time analysis --- n_repeats = 5 time_no_fit = [] time_fit = []  for _ in range(n_repeats):     t0 = time.perf_counter()     _ = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=False)     time_no_fit.append(time.perf_counter() - t0)      t0 = time.perf_counter()     _ = mdna.compute_rigid_parameters(traj, chainids=[0, 1], fit_reference=True)     time_fit.append(time.perf_counter() - t0)  mean_no, std_no = np.mean(time_no_fit), np.std(time_no_fit) mean_fit, std_fit = np.mean(time_fit), np.std(time_fit) slowdown = mean_fit / mean_no if mean_no &gt; 0 else np.nan  fig_t, ax_t = plt.subplots(figsize=(4.2, 3)) ax_t.bar(['no fitting', 'fitted'], [mean_no, mean_fit], yerr=[std_no, std_fit],          color=['tab:orange', 'tab:blue'], alpha=0.8, capsize=4) ax_t.set_ylabel('time [s]') ax_t.set_title(f'Runtime over {n_repeats} runs') fig_t.tight_layout()  print(f'no fitting: {mean_no:.4f} \u00b1 {std_no:.4f} s') print(f'fitted:    {mean_fit:.4f} \u00b1 {std_fit:.4f} s') print(f'slowdown (fitted/no fitting): {slowdown:.2f}x') <pre>/var/folders/n2/v5z2p1nn4f3bx7dhf2zlzdjw0000gn/T/ipykernel_51011/68300235.py:53: UserWarning: Dataset has 0 variance; skipping density estimate. Pass `warn_singular=False` to disable this warning.\n  sns.kdeplot(para_no_fit[:, i], ax=ax_i, color='tab:orange', fill=True, alpha=0.25, lw=1.2, label='no fitting' if i == 0 else None)\n/var/folders/n2/v5z2p1nn4f3bx7dhf2zlzdjw0000gn/T/ipykernel_51011/68300235.py:54: UserWarning: Dataset has 0 variance; skipping density estimate. Pass `warn_singular=False` to disable this warning.\n  sns.kdeplot(para_fit[:, i], ax=ax_i, color='tab:blue', fill=True, alpha=0.25, lw=1.2, label='fitted' if i == 0 else None)\n</pre> <pre>no fitting: 0.2959 \u00b1 0.0273 s\nfitted:    0.3691 \u00b1 0.0325 s\nslowdown (fitted/no fitting): 1.25x\n</pre> In\u00a0[9]: Copied! <pre># Example on how to plot KDE's of all parameters\nimport matplotlib as mpl, matplotlib.font_manager as font_manager\nimport seaborn as sns\nmpl.rcParams['font.family'] = 'serif'\ncmfont = font_manager.FontProperties(fname=mpl.get_data_path() + '/fonts/ttf/cmr10.ttf')\nmpl.rcParams['font.serif'] = cmfont.get_name()\nmpl.rcParams['mathtext.fontset'] = 'cm'\nmpl.rcParams['axes.unicode_minus'] = False\nmpl.rcParams['axes.formatter.use_mathtext'] = True\n\ncolors = sns.color_palette('twilight', 12)\nlims = [(-2,2), (-2,2), (-2,2), (-65,65), (-65,65), (-65,65)] + [(-3,3), (-3,3), (1.25,5), (-50,50), (-50,50), (0,60)]\nfig, ax = plt.subplots(3, 4, figsize=(6, 2.5), sharey='col')\n# ax = ax.flatten()\nidx, jdx = 0, 0\nfor _, name in enumerate(names):\n    para = params[:, 1:, names.index(name)]\n    sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color='white', lw=5)  # density=True\n    sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color=colors[_], alpha=1, lw=1)  # density=True\n    ax[idx][jdx].set_title(name, x=0, y=0, color=colors[_], fontsize=10)\n    ax[idx][jdx].set_xlim(lims[_])\n\n    ax[idx][jdx].set_facecolor('none')\n    ax[idx][jdx].set_yticklabels([])\n    ax[idx][jdx].set_yticks([])\n    ax[idx][jdx].set_ylabel('')\n    if name in ['shear', 'buckle', 'shift', 'tilt', 'stretch', 'propeller']:\n        ax[idx][jdx].set_xticks([])\n    idx += 1\n    if idx == 3:\n        idx = 0\n        jdx += 1\n    if jdx == 4:\n        jdx = 0\n\n    if idx == 0 and jdx in [0, 1, 2, 3]:\n        ax[idx][jdx].set_xticklabels([])\n    if idx == 1 and jdx in [0, 1]:\n        ax[idx][jdx].set_xticklabels([])\n\nax[-1][0].set_xlabel('[nm]', fontsize=11)\nax[-1][1].set_xlabel('[degrees]', fontsize=11)\nax[-1][2].set_xlabel('[nm]', fontsize=11)\nax[-1][3].set_xlabel('[degrees]', fontsize=11)\nfig.tight_layout()\nfig.subplots_adjust(hspace=-.25)\n\nsns.despine(bottom=True, left=True)\nfig.text(0.25, 0.85, 'Pair Parameters', ha='center', fontsize=10)\nfig.text(0.75, 0.85, 'Step Parameters', ha='center', fontsize=10)\n</pre> # Example on how to plot KDE's of all parameters import matplotlib as mpl, matplotlib.font_manager as font_manager import seaborn as sns mpl.rcParams['font.family'] = 'serif' cmfont = font_manager.FontProperties(fname=mpl.get_data_path() + '/fonts/ttf/cmr10.ttf') mpl.rcParams['font.serif'] = cmfont.get_name() mpl.rcParams['mathtext.fontset'] = 'cm' mpl.rcParams['axes.unicode_minus'] = False mpl.rcParams['axes.formatter.use_mathtext'] = True  colors = sns.color_palette('twilight', 12) lims = [(-2,2), (-2,2), (-2,2), (-65,65), (-65,65), (-65,65)] + [(-3,3), (-3,3), (1.25,5), (-50,50), (-50,50), (0,60)] fig, ax = plt.subplots(3, 4, figsize=(6, 2.5), sharey='col') # ax = ax.flatten() idx, jdx = 0, 0 for _, name in enumerate(names):     para = params[:, 1:, names.index(name)]     sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color='white', lw=5)  # density=True     sns.kdeplot(para.flatten(), ax=ax[idx][jdx], fill=True, color=colors[_], alpha=1, lw=1)  # density=True     ax[idx][jdx].set_title(name, x=0, y=0, color=colors[_], fontsize=10)     ax[idx][jdx].set_xlim(lims[_])      ax[idx][jdx].set_facecolor('none')     ax[idx][jdx].set_yticklabels([])     ax[idx][jdx].set_yticks([])     ax[idx][jdx].set_ylabel('')     if name in ['shear', 'buckle', 'shift', 'tilt', 'stretch', 'propeller']:         ax[idx][jdx].set_xticks([])     idx += 1     if idx == 3:         idx = 0         jdx += 1     if jdx == 4:         jdx = 0      if idx == 0 and jdx in [0, 1, 2, 3]:         ax[idx][jdx].set_xticklabels([])     if idx == 1 and jdx in [0, 1]:         ax[idx][jdx].set_xticklabels([])  ax[-1][0].set_xlabel('[nm]', fontsize=11) ax[-1][1].set_xlabel('[degrees]', fontsize=11) ax[-1][2].set_xlabel('[nm]', fontsize=11) ax[-1][3].set_xlabel('[degrees]', fontsize=11) fig.tight_layout() fig.subplots_adjust(hspace=-.25)  sns.despine(bottom=True, left=True) fig.text(0.25, 0.85, 'Pair Parameters', ha='center', fontsize=10) fig.text(0.75, 0.85, 'Step Parameters', ha='center', fontsize=10) Out[9]: <pre>Text(0.75, 0.85, 'Step Parameters')</pre>"},{"location":"notebooks/3_analysis_tutorial/#analysis-tutorial","title":"Analysis Tutorial\u00b6","text":"<p>Welcome to the DNA analysis tutorial using the MDNA module. This notebook will demonstrate different techniques to analyze DNA structures, including simulations, parameter extractions, and visualization of dynamics. You'll learn to:</p> <ul> <li>Simulate DNA structures using OpenMM.</li> <li>Extract and analyze different structural parameters.</li> <li>Visualize these parameters to understand DNA behavior.</li> </ul>"},{"location":"notebooks/3_analysis_tutorial/#dna-simulation-with-openmm","title":"DNA Simulation with OpenMM\u00b6","text":"<p>Molecular Dynamics (MD) simulations are computational methods used to study the physical movements of atoms and molecules over time. By simulating the interactions and dynamics of molecular structures, MD provides insights into the structural, dynamic, and thermodynamic properties of biological molecules like DNA.</p>"},{"location":"notebooks/3_analysis_tutorial/#about-openmm","title":"About OpenMM\u00b6","text":"<p>OpenMM is a toolkit for molecular simulations, designed to be extremely flexible and highly efficient. It allows for the rapid development of algorithms and the construction of custom molecular dynamics applications. It is especially optimized for high-performance simulations, making it ideal for studies that require complex, large-scale computations.</p>"},{"location":"notebooks/3_analysis_tutorial/#simulation-process","title":"Simulation Process\u00b6","text":"<ol> <li><p>Initialization: We start by creating a DNA simulation from a given sequence. This involves setting up the initial conditions, such as the DNA sequence itself, simulation time, and whether the system should be solvated (surrounded by a solvent, typically water).</p> </li> <li><p>Centering Coordinates: To ensure that the DNA structure is properly oriented and centered in the simulation box, we adjust the coordinates. This is crucial for avoiding any boundary issues during the simulation.</p> </li> <li><p>Imaging Molecules: This step involves adjusting the positions of molecules relative to each other based on an anchor molecule. Typically, this helps in maintaining the integrity of the structure throughout the simulation, preventing it from drifting apart across periodic boundaries.</p> </li> <li><p>Superposition: Finally, the trajectory is superposed to a reference frame (usually the first frame) to eliminate any rotational and translational movements that are not intrinsic to the molecule's dynamics.</p> </li> </ol>"},{"location":"notebooks/3_analysis_tutorial/#note","title":"Note\u00b6","text":"<p>This simulation might take a while to run, depending on the complexity of the DNA sequence and the computational resources available. It's performed to understand the dynamic behavior of the DNA molecule in a simulated physiological environment. Alternatively, you might load your own MD trajectory containing a DNA structure for the purpose of this tutorial.</p>"},{"location":"notebooks/3_analysis_tutorial/#managing-dna-coordinates","title":"Managing DNA Coordinates\u00b6","text":"<p>Find a residue in the middle, anchor molecules, and adjust the DNA in the simulation box.</p>"},{"location":"notebooks/3_analysis_tutorial/#loading-and-analyzing-dna-structure","title":"Loading and Analyzing DNA Structure\u00b6","text":"<p>Load the trajectory, extract mean reference frames, and view base reference frames.</p>"},{"location":"notebooks/3_analysis_tutorial/#extracting-and-visualizing-rigid-base-parameters","title":"Extracting and Visualizing Rigid Base Parameters\u00b6","text":"<p>Show how to extract and parameters</p>"},{"location":"notebooks/3_analysis_tutorial/#why-fit-bases-before-defining-reference-frames","title":"Why fit bases before defining reference frames?\u00b6","text":"<p>Low-resolution structures and MD snapshots can contain small base deformations. If we compute base frames directly from deformed atoms, those deformations can leak into rigid-base parameters as extra noise.</p> <p>Following the Curves+ idea, we can first perform a least-squares fit of a standard (canonical) base geometry to the observed base atoms, then define the base frame from the fitted canonical geometry.</p> <p>How the fitting works here (step by step):</p> <ol> <li>Choose a canonical base template (A, C, G, T; U is mapped to T in this implementation).</li> <li>Select common heavy atoms between template and observed residue (hydrogens excluded).</li> <li>Build two paired point clouds: template coordinates and observed coordinates.</li> <li>Remove translation by centering both point clouds at their centroids.</li> <li>Compute the optimal rotation with the Kabsch least-squares solution (via <code>scipy.spatial.transform.Rotation.align_vectors</code>).</li> <li>Apply that rotation to the canonical base frame vectors.</li> <li>Place the fitted origin by rotating the canonical origin offset and translating to the observed centroid.</li> <li>Use the transformed canonical frame as the residue frame for parameter analysis.</li> </ol> <p>This is analogous to Curves+ least-squares fitting to standard bases (with fitting optionally enabled/disabled). Here, fitting is controlled by the <code>fit_reference</code> flag in rigid-parameter analysis.</p>"},{"location":"notebooks/3_analysis_tutorial/#advanced-visualization-of-dna-parameters","title":"Advanced Visualization of DNA Parameters\u00b6","text":"<p>Use statistical visualization to understand distributions of DNA parameters.</p>"},{"location":"notebooks/4_filament_tutorial/","title":"Constructing DNA Along a Protein Filament","text":"In\u00a0[1]: Copied! <pre># Load necessary libraries and retrieve the trajectory object\nimport mdtraj as md\nimport numpy as np\nimport nglview as nv\nimport matplotlib.pyplot as plt\nimport sys\nfrom tqdm import tqdm\nimport mdna\n\nsys.path.append('./modules/')\nfrom filament import *\n%load_ext autoreload\n%autoreload 2\n</pre> # Load necessary libraries and retrieve the trajectory object import mdtraj as md import numpy as np import nglview as nv import matplotlib.pyplot as plt import sys from tqdm import tqdm import mdna  sys.path.append('./modules/') from filament import * %load_ext autoreload %autoreload 2 <pre></pre> In\u00a0[2]: Copied! <pre># Load MD data (`filament_minimal` is bundled; set to False to use full trajectories)\nminimal_mode = False\nminimal_dir = './data/filament_minimal/'\n\nif not minimal_mode:\n    # Load H-NS s1s1 dimers\n    loc_dimers = './data/filament_dataset/0_s1s1/'\n    short_trajs = [md.load(loc_dimers+f'dry_{i}.xtc', top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]\n    s1s1 = md.join(short_trajs)\n\n    # Load H-NS s2s2 dimers\n    loc_dimers = './data/filament_dataset/1_s2s2/'\n    short_trajs = [md.load(loc_dimers+f'dry_{i}.xtc', top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]\n    s2s2 = md.join(short_trajs)\n\n    # Load H-NS dbd to DNA complex\n    loc_dbd = './data/filament_dataset/FI/'\n    traj = [md.load(loc_dbd+f'dry_{i}.xtc', top=loc_dbd+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]\n    dna_complex = md.join(traj)\n</pre> # Load MD data (`filament_minimal` is bundled; set to False to use full trajectories) minimal_mode = False minimal_dir = './data/filament_minimal/'  if not minimal_mode:     # Load H-NS s1s1 dimers     loc_dimers = './data/filament_dataset/0_s1s1/'     short_trajs = [md.load(loc_dimers+f'dry_{i}.xtc', top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]     s1s1 = md.join(short_trajs)      # Load H-NS s2s2 dimers     loc_dimers = './data/filament_dataset/1_s2s2/'     short_trajs = [md.load(loc_dimers+f'dry_{i}.xtc', top=loc_dimers+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]     s2s2 = md.join(short_trajs)      # Load H-NS dbd to DNA complex     loc_dbd = './data/filament_dataset/FI/'     traj = [md.load(loc_dbd+f'dry_{i}.xtc', top=loc_dbd+f'dry_{i}.pdb').remove_solvent() for i in range(0,2)]     dna_complex = md.join(traj) In\u00a0[3]: Copied! <pre>from pathlib import Path\n\nif not minimal_mode and not Path('./data/filament_dataset').exists():\n    print('Full dataset not found.')\n    print('Minimal mode is bundled and available at ./data/filament_minimal/.')\n    print('Optional download for full mode:')\n    print(\"  export MDNA_FILAMENT_DATASET_URL='https://doi.org/10.6084/m9.figshare.31423193'\")\n    print('  python ./scripts/fetch_filament_dataset.py --output-root ./data')\n    print('Optional checksum verification (real hash only):')\n    print(\"  export MDNA_FILAMENT_DATASET_SHA256='&lt;REAL_SHA256&gt;'\")\n</pre> from pathlib import Path  if not minimal_mode and not Path('./data/filament_dataset').exists():     print('Full dataset not found.')     print('Minimal mode is bundled and available at ./data/filament_minimal/.')     print('Optional download for full mode:')     print(\"  export MDNA_FILAMENT_DATASET_URL='https://doi.org/10.6084/m9.figshare.31423193'\")     print('  python ./scripts/fetch_filament_dataset.py --output-root ./data')     print('Optional checksum verification (real hash only):')     print(\"  export MDNA_FILAMENT_DATASET_SHA256=''\") In\u00a0[4]: Copied! <pre>if not minimal_mode:\n    view = nv.show_mdtraj(dna_complex)\n    view\nelse:\n    print('Minimal mode enabled: skipping full dataset preview cell.')\n</pre> if not minimal_mode:     view = nv.show_mdtraj(dna_complex)     view else:     print('Minimal mode enabled: skipping full dataset preview cell.') In\u00a0[5]: Copied! <pre># Define segments of the protein\nn = 2  # Overlap of residues between segments\n\nsegments = {\n    's1': np.arange(0, 41 + n),\n    'h3': np.arange(41 - n, 53 + n),\n    's2': np.arange(53 - n, 82 + n),\n    'l2': np.arange(82 - n, 95 + n),\n    'dbd': np.arange(95 - n, 137),\n}\n\nif minimal_mode:\n    site_map = Assembler.load_minimal_site_map(minimal_dir=minimal_dir, segments=segments, n_overlap=n)\nelse:\n    # Site map contains a dictionary with the (sub)trajectories of different sites\n    mapper = SiteMapper(s1s1, s2s2, segments=segments, k=100)\n    site_map = mapper.get_site_map()\n    site_map['complex'] = dna_complex\n</pre> # Define segments of the protein n = 2  # Overlap of residues between segments  segments = {     's1': np.arange(0, 41 + n),     'h3': np.arange(41 - n, 53 + n),     's2': np.arange(53 - n, 82 + n),     'l2': np.arange(82 - n, 95 + n),     'dbd': np.arange(95 - n, 137), }  if minimal_mode:     site_map = Assembler.load_minimal_site_map(minimal_dir=minimal_dir, segments=segments, n_overlap=n) else:     # Site map contains a dictionary with the (sub)trajectories of different sites     mapper = SiteMapper(s1s1, s2s2, segments=segments, k=100)     site_map = mapper.get_site_map()     site_map['complex'] = dna_complex In\u00a0[6]: Copied! <pre># Parameters to make filament\nn_dimers = 6\nchains_to_dna = [0, 4, 7, 11]\nsave = True\n\n# Initialize class to assemble the filament\nassembler = Assembler(site_map=site_map)\nsegment_mode = 'minimal' if minimal_mode else 'fixed' # Other options is 'random' if full trajectories are available\n\n# Add dimers\nprint(f'Assembling {n_dimers} H-NS dimers:')\nfor idx in tqdm(range(n_dimers)):\n    assembler.add_dimer(segment=segment_mode, verbose=True)\n\n# Add DNA oligo's\nn_dna = len(chains_to_dna)\nif n_dna &gt; 0:\n    print(f\"Assembling {n_dna} DNA oligo's:\")\n    for chainid in tqdm(chains_to_dna):\n        assembler.add_dna(chainid=chainid)\n\n# Retrieve the trajectory from the assembled complex\ntraj = assembler.get_traj()\n</pre> # Parameters to make filament n_dimers = 6 chains_to_dna = [0, 4, 7, 11] save = True  # Initialize class to assemble the filament assembler = Assembler(site_map=site_map) segment_mode = 'minimal' if minimal_mode else 'fixed' # Other options is 'random' if full trajectories are available  # Add dimers print(f'Assembling {n_dimers} H-NS dimers:') for idx in tqdm(range(n_dimers)):     assembler.add_dimer(segment=segment_mode, verbose=True)  # Add DNA oligo's n_dna = len(chains_to_dna) if n_dna &gt; 0:     print(f\"Assembling {n_dna} DNA oligo's:\")     for chainid in tqdm(chains_to_dna):         assembler.add_dna(chainid=chainid)  # Retrieve the trajectory from the assembled complex traj = assembler.get_traj() <pre>Assembling 6 H-NS dimers:\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:12&lt;00:00,  2.01s/it]\n</pre> <pre>Assembling 4 DNA oligo's:\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:03&lt;00:00,  1.18it/s]\n</pre> <p>Identify chains associated with DNA based on residue names typical for DNA nucleotides</p> In\u00a0[7]: Copied! <pre>DNA_residue_names = ['DG','DC','DT','DA']\nDNA_chainids = []\nfor chain in traj.top.chains:\n    for res in chain._residues:\n        if str(res.name) in DNA_residue_names:\n            DNA_chainids.append(res.chain.index)\nDNA_chainids = np.unique(DNA_chainids)\nDNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)])\n</pre> DNA_residue_names = ['DG','DC','DT','DA'] DNA_chainids = [] for chain in traj.top.chains:     for res in chain._residues:         if str(res.name) in DNA_residue_names:             DNA_chainids.append(res.chain.index) DNA_chainids = np.unique(DNA_chainids) DNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)])  <p>Calculate specific control points based on the center of mass and other structural features of identified DNA segments This follows the previously described scientific model for assembling H-NS filaments</p> In\u00a0[8]: Copied! <pre>COM_primes = []\nidx = 0\nfor chainids in DNA_chainids:\n    nuc = mdna.load(traj, chainids=chainids)\n    frames = nuc.get_frames()\n\n    # Adding control points based on the specific arrangements in the filament model\n    if idx == 0:\n        COM_primes.append(frames[0][0][0] - np.array([3, -1, 0]))\n        COM_primes.append(frames[0][0][0])\n    elif idx == 3:\n        COM_primes.append(frames[-1][0][0] + np.array([0, -2, 0]))\n        COM_primes.append(frames[-1][0][0] + np.array([10, -3, 0]))\n    else:\n        COM_primes.append(frames[6][0][0])\n    idx += 1\n\nCOM_primes = np.array(COM_primes)\npoints = COM_primes\n</pre> COM_primes = [] idx = 0 for chainids in DNA_chainids:     nuc = mdna.load(traj, chainids=chainids)     frames = nuc.get_frames()      # Adding control points based on the specific arrangements in the filament model     if idx == 0:         COM_primes.append(frames[0][0][0] - np.array([3, -1, 0]))         COM_primes.append(frames[0][0][0])     elif idx == 3:         COM_primes.append(frames[-1][0][0] + np.array([0, -2, 0]))         COM_primes.append(frames[-1][0][0] + np.array([10, -3, 0]))     else:         COM_primes.append(frames[6][0][0])     idx += 1  COM_primes = np.array(COM_primes) points = COM_primes  In\u00a0[9]: Copied! <pre>dna = mdna.make(control_points=points)\ndna.draw()\n</pre> dna = mdna.make(control_points=points) dna.draw() <pre>Random sequence: TAGAAAACATGCAGCCTCGTTAGCAAGCTGGGCCGCGGACTACCCCTGTTTTCGTGTCTGGGTATTCCGTCTCTTCCATTTTCTGCTCTCCCTTCGAGTGGGTAGCCCGTCAGAATACCAGGTTGACTGGGCACGCAGATAAGTCCTACACTGTGGGGCTATACGATCTGGTACTCATAATTCGGCGTGCGACCGAGGACGGAATCTGACCA \n\n</pre> <p>Save result</p> In\u00a0[10]: Copied! <pre># Save the structures for further analysis\ndna_traj = dna.get_traj()\nprotein = traj.atom_slice(traj.top.select('protein'))\nprotein.save('./pdbs/lateral_filament_unoptimized_noDNA.pdb')\nnew_traj = dna_traj.stack(protein)\nnew_traj.save('./pdbs/lateral_filament_unoptimized.pdb')\n\n# Visualize the final combined structure\nview = nv.show_mdtraj(new_traj)\nview\n</pre> # Save the structures for further analysis dna_traj = dna.get_traj() protein = traj.atom_slice(traj.top.select('protein')) protein.save('./pdbs/lateral_filament_unoptimized_noDNA.pdb') new_traj = dna_traj.stack(protein) new_traj.save('./pdbs/lateral_filament_unoptimized.pdb')  # Visualize the final combined structure view = nv.show_mdtraj(new_traj) view <pre>NGLWidget()</pre>"},{"location":"notebooks/4_filament_tutorial/#constructing-dna-along-a-protein-filament","title":"Constructing DNA Along a Protein Filament\u00b6","text":"<p>This tutorial demonstrates how to construct DNA structures along a protein filament, specifically focusing on the lateral H-NS filament assembly process. This technique involves modeling interactions between DNA and protein structures, providing a method to visualize complex biological assemblies.</p>"},{"location":"notebooks/4_filament_tutorial/#scientific-context","title":"Scientific Context:\u00b6","text":"<ul> <li>The process starts with a H-NS decamer homodimer, which serves as the initial protein scaffold.</li> <li>Four DNA Binding Domains (DBD) are fitted with 12 bp DNA strands using the H-NS DNA complex structures from previous studies (PDB: 1HNS).</li> <li>The reference frames of the 4 DNA oligomers are then used as control points to generate new DNA strands spanning the complete H-NS filament.</li> </ul>"},{"location":"notebooks/4_filament_tutorial/#objective","title":"Objective:\u00b6","text":"<ul> <li>Highlight the capability of the <code>.make()</code> function to create DNA structures by using anchor points of specific domains as control points.</li> <li>Demonstrate the flexibility of structure generation where the protein filament serves as a scaffold, enabling the generation of a DNA configuration along a reference structure.</li> </ul>"},{"location":"notebooks/4_filament_tutorial/#steps-covered","title":"Steps Covered:\u00b6","text":"<ul> <li>Retrieve and process the trajectory object to identify DNA chains.</li> <li>Calculate control points based on the reference frames of identified DNA segments and the scientific model.</li> <li>Generate DNA along these control points and integrate with the protein structure.</li> <li>Visualize and save the new combined structure.</li> </ul>"},{"location":"notebooks/4_filament_tutorial/#load-md-data","title":"Load MD data\u00b6","text":""},{"location":"notebooks/4_filament_tutorial/#optional-full-dataset-download-figshare","title":"Optional full dataset download (Figshare)\u00b6","text":"<p><code>filament_minimal</code> is bundled and used by default in this tutorial. <code>filament_dataset</code> is optional and only needed for full-trajectory mode.</p> <p>If you do not have the full dataset yet, run:</p> <pre>export MDNA_FILAMENT_DATASET_URL='https://doi.org/10.6084/m9.figshare.31423193'\npython ./scripts/fetch_filament_dataset.py --output-root ./data\n</pre> <p>The fetch script accepts DOI/landing-page URLs and resolves the direct Figshare download automatically.</p> <p>Optional integrity check (only if you know the real archive hash):</p> <pre>export MDNA_FILAMENT_DATASET_SHA256='&lt;REAL_SHA256&gt;'\npython ./scripts/fetch_filament_dataset.py --output-root ./data --force\n</pre> <p>After download, full data will be available at <code>./data/filament_dataset/</code>.</p>"},{"location":"notebooks/4_filament_tutorial/#construct-h-ns-filament","title":"Construct H-NS filament\u00b6","text":""},{"location":"notebooks/4_filament_tutorial/#analyze-filament","title":"Analyze filament\u00b6","text":""},{"location":"notebooks/4_filament_tutorial/#generate-dna-along-filement","title":"Generate DNA along filement\u00b6","text":"<p>Generate the DNA along defined control points and integrate with the protein structure This step visualizes the flexibility and utility of the .make() function in creating specified DNA shapes</p>"},{"location":"notebooks/5_extension_tutorial/","title":"Extending DNA Structures and Integration with Protein Data","text":"In\u00a0[1]: Copied! <pre>import mdtraj as md\nimport nglview as nv\nimport mdna\n\n\n# Load PDB file\npdb = md.load('./pdbs/1kx5.pdb')\nview = nv.show_mdtraj(pdb)\nview\n</pre> import mdtraj as md import nglview as nv import mdna   # Load PDB file pdb = md.load('./pdbs/1kx5.pdb') view = nv.show_mdtraj(pdb) view <pre></pre> <pre>NGLWidget()</pre> In\u00a0[2]: Copied! <pre># Load DNA part from traj object\ndna = mdna.load(pdb)\ndna.describe()\n\n# Add random linker DNA in forward and reverse direction. Note the exvol_rad parameter set to zero, because due to the wrapping of around the core protein, the exvol beads overlap. This is not allowed in the current implementation of the MC algorithm.\ndna.extend(n_bp=36, exvol_rad=0)\ndna.extend(n_bp=36, exvol_rad=0, forward=False)\n\n# Visualize the extended DNA\ndna.draw()\n</pre> # Load DNA part from traj object dna = mdna.load(pdb) dna.describe()  # Add random linker DNA in forward and reverse direction. Note the exvol_rad parameter set to zero, because due to the wrapping of around the core protein, the exvol beads overlap. This is not allowed in the current implementation of the MC algorithm. dna.extend(n_bp=36, exvol_rad=0) dna.extend(n_bp=36, exvol_rad=0, forward=False)  # Visualize the extended DNA dna.draw() <pre>DNA structure with 147 base pairs\nSequence: ATCAATATCCACCTGCAGATACTACCAAAAGTGTATTTGGAAACTGCTCCATCAAAAGGCATGTTCAGCTGGAATCCAGCTGAACATGCCTTTTGATGGAGCAGTTTCCAAATACACTTTTGGTAGTATCTGCAGGTGGATATTGAT\nTrajectory: &lt;mdtraj.Trajectory with 1 frames, 16755 atoms, 4416 residues, and unitcells&gt;\nFrames:  (147, 1, 4, 3)\nRandom sequence: ACTGCATGTAAACCGCCCTAGCGTCGGTGCTACGGG \n\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 0 \ntemperature = 300\nCircular: False\nRandom sequence: AACTCTTCCCTACACGAGTACTGCTGGCTGTTGACC \n\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 0 \ntemperature = 300\nCircular: False\n</pre> In\u00a0[3]: Copied! <pre># Stack extended DNA and protein back together\nprotein = pdb.atom_slice(pdb.top.select('not chainid 0 1'))\ndna_traj = dna.get_traj()\nextended_traj = dna_traj.stack(protein)\n\nview = nv.show_mdtraj(extended_traj)\nview\n</pre> # Stack extended DNA and protein back together protein = pdb.atom_slice(pdb.top.select('not chainid 0 1')) dna_traj = dna.get_traj() extended_traj = dna_traj.stack(protein)  view = nv.show_mdtraj(extended_traj) view <pre>NGLWidget()</pre> In\u00a0[4]: Copied! <pre># Save extended traj\nextended_traj.save_pdb('./pdbs/1kx5_extended.pdb')\n</pre> # Save extended traj extended_traj.save_pdb('./pdbs/1kx5_extended.pdb') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/5_extension_tutorial/#extending-dna-structures-and-integration-with-protein-data","title":"Extending DNA Structures and Integration with Protein Data\u00b6","text":"<p>This tutorial demonstrates how to extend DNA sequences from a loaded structure and integrate the extended DNA with protein components. This process is useful for creating complex models for simulations or visualization, aiding in the study of DNA-protein interactions.</p>"},{"location":"notebooks/5_extension_tutorial/#steps-covered","title":"Steps Covered:\u00b6","text":"<ul> <li>Load and visualize the initial PDB structure.</li> <li>Isolate and extend the DNA component.</li> <li>Combine the extended DNA with the protein structure.</li> <li>Save the modified structure for further analysis.</li> </ul>"},{"location":"notebooks/5_extension_tutorial/#loading-and-visualizing-initial-structures","title":"Loading and Visualizing Initial Structures\u00b6","text":"<p>Start by loading a PDB file and visualize it to confirm the structure's integrity.</p>"},{"location":"notebooks/5_extension_tutorial/#extending-the-dna-structure","title":"Extending the DNA Structure\u00b6","text":"<p>Isolate the DNA part, describe its current state, and then extend it at both ends.</p>"},{"location":"notebooks/5_extension_tutorial/#integration-with-protein-structure","title":"Integration with Protein Structure\u00b6","text":"<p>Isolate the protein part of the structure, combine it with the extended DNA, and save the new structure.</p>"},{"location":"notebooks/6_connection_tutorial/","title":"Connecting Two DNA Strands and Integration with Protein Data","text":"In\u00a0[1]: Copied! <pre>import mdtraj as md\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport nglview as nv\nimport mdna\n</pre> import mdtraj as md import numpy as np import matplotlib.pyplot as plt import nglview as nv import mdna <pre></pre> In\u00a0[2]: Copied! <pre># Load the structure\ntraj = md.load('./pdbs/8srp.pdb')\nprotein = traj.atom_slice(traj.top.select('protein'))\nview = nv.show_mdtraj(traj)\n\nview\n</pre> # Load the structure traj = md.load('./pdbs/8srp.pdb') protein = traj.atom_slice(traj.top.select('protein')) view = nv.show_mdtraj(traj)  view <pre>/Users/thor/miniforge3/envs/mdna/lib/python3.12/site-packages/mdtraj/formats/pdb/pdbfile.py:200: UserWarning: Unlikely unit cell vectors detected in PDB file likely resulting from a dummy CRYST1 record. Discarding unit cell vectors.\n  warnings.warn('Unlikely unit cell vectors detected in PDB file likely '\n</pre> <pre>NGLWidget()</pre> In\u00a0[3]: Copied! <pre>DNA_residue_names = ['DG','DC','DT','DA']\nDNA_chainids = []\nfor chain in traj.top.chains:\n    for res in chain._residues:\n         if str(res.name) in DNA_residue_names:\n            DNA_chainids.append(res.chain.index)\nDNA_chainids = np.unique(DNA_chainids)\nDNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)])\n</pre> DNA_residue_names = ['DG','DC','DT','DA'] DNA_chainids = [] for chain in traj.top.chains:     for res in chain._residues:          if str(res.name) in DNA_residue_names:             DNA_chainids.append(res.chain.index) DNA_chainids = np.unique(DNA_chainids) DNA_chainids = np.array([DNA_chainids[i:i + 2] for i in range(0, len(DNA_chainids), 2)]) In\u00a0[4]: Copied! <pre>dna_a = mdna.load(traj=traj, chainids=DNA_chainids[0])\ndna_b = mdna.load(traj=traj, chainids=DNA_chainids[1])\n\n# Get frames to calculate control points\nframes_a = dna_a.get_frames()\nframes_b = dna_b.get_frames()\nstart = np.squeeze(frames_a[-1])[0]\nend = np.squeeze(frames_b[0])[0]\n\n# Calculate incremental positions for smoother curves\nstart_increment = start + np.array([0.5, 0, 3])\nend_increment = end + np.array([-0.5, 0, 3])\ncenter_of_mass = (start + end) / 2\ncenter_of_mass += np.array([0, 0, 1]) * 20\ncontrol_points = np.array([start, start_increment, center_of_mass, end_increment, end])\n\n# Draw initial strands and control points\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\ndna_a.draw(ax=ax, triads=True, color_lead='blue')\ndna_b.draw(ax=ax, triads=True, color_lead='red')\nax.plot(control_points[:,0], control_points[:,1], control_points[:,2], marker='o', color='g', linestyle='-', linewidth=2, markersize=12)\nax.axis('equal')\n</pre> dna_a = mdna.load(traj=traj, chainids=DNA_chainids[0]) dna_b = mdna.load(traj=traj, chainids=DNA_chainids[1])  # Get frames to calculate control points frames_a = dna_a.get_frames() frames_b = dna_b.get_frames() start = np.squeeze(frames_a[-1])[0] end = np.squeeze(frames_b[0])[0]  # Calculate incremental positions for smoother curves start_increment = start + np.array([0.5, 0, 3]) end_increment = end + np.array([-0.5, 0, 3]) center_of_mass = (start + end) / 2 center_of_mass += np.array([0, 0, 1]) * 20 control_points = np.array([start, start_increment, center_of_mass, end_increment, end])  # Draw initial strands and control points fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(111, projection='3d') dna_a.draw(ax=ax, triads=True, color_lead='blue') dna_b.draw(ax=ax, triads=True, color_lead='red') ax.plot(control_points[:,0], control_points[:,1], control_points[:,2], marker='o', color='g', linestyle='-', linewidth=2, markersize=12) ax.axis('equal')  Out[4]: <pre>(-10.94905859894223,\n 44.446358746952484,\n -10.83135897583432,\n 44.564058370060394,\n 5.5965357522169725,\n 47.14309876163801)</pre> <p>Now the control point shave been defined we can make the loop.</p> In\u00a0[5]: Copied! <pre># Connect the strands\ndna_c = mdna.connect(dna_a, dna_b, control_points=control_points)\ndna_c.draw(ax=ax)\n</pre> # Connect the strands dna_c = mdna.connect(dna_a, dna_b, control_points=control_points) dna_c.draw(ax=ax) <pre>Optimal BP: 26, Twist Difference per BP: 0.176 degrees\nOptimal number of base pairs: 26\nRandom sequence: GAGAGTTGTTAGGAGTCAAGGAGCAGATATTTTCCCGCCAAAACCGTTCTTACATCCTCTGTGTCTGACAACTACGAGCATGGTGGGTATCCGGCACCGCGGGGGTGTTGGCTCCCATAGA \n\nMinimize the DNA structure:\nsimple equilibration = False \nequilibrate writhe = False \nexcluded volume radius = 0.0 \ntemperature = 300\nCircular: False\n</pre> In\u00a0[6]: Copied! <pre># Combine DNA and protein trajectories\ndna_traj = dna_c.get_traj()\nconnected_traj = protein.stack(dna_traj)\nview = nv.show_mdtraj(connected_traj)\nview\n</pre> # Combine DNA and protein trajectories dna_traj = dna_c.get_traj() connected_traj = protein.stack(dna_traj) view = nv.show_mdtraj(connected_traj) view   <pre>NGLWidget()</pre> In\u00a0[7]: Copied! <pre># Save the combined structure\nconnected_traj.save('./pdbs/8srp_connected.pdb')\n</pre> # Save the combined structure connected_traj.save('./pdbs/8srp_connected.pdb')"},{"location":"notebooks/6_connection_tutorial/#connecting-two-dna-strands-and-integration-with-protein-data","title":"Connecting Two DNA Strands and Integration with Protein Data\u00b6","text":"<p>This tutorial demonstrates how to identify and connect two separate DNA strands from a loaded structure, and integrate the connected DNA with protein components. This process is essential for creating comprehensive models for visualization and analysis.</p>"},{"location":"notebooks/6_connection_tutorial/#steps-covered","title":"Steps Covered:\u00b6","text":"<ul> <li>Load and identify DNA strands in a structure containing proteins.</li> <li>Calculate and visualize control points for connecting DNA strands.</li> <li>Connect the DNA strands and integrate the result with the protein structure.</li> <li>Visualize and save the new combined structure.</li> </ul>"},{"location":"notebooks/6_connection_tutorial/#loading-the-structure-and-identifying-dna-strands","title":"Loading the Structure and Identifying DNA Strands\u00b6","text":"<p>Load a PDB file containing both DNA and protein components and identify DNA strands based on residue names.</p>"},{"location":"notebooks/6_connection_tutorial/#identifying-dna-chains","title":"Identifying DNA Chains\u00b6","text":"<p>Extract the indices of DNA chains based on common residue names for nucleotides.</p>"},{"location":"notebooks/6_connection_tutorial/#connecting-dna-strands","title":"Connecting DNA Strands\u00b6","text":"<p>Load the DNA strands, calculate control points for connection, and visualize the initial and connected states.</p>"},{"location":"notebooks/6_connection_tutorial/#visualization-and-saving-the-connected-structure","title":"Visualization and Saving the Connected Structure\u00b6","text":"<p>Combine the connected DNA with the protein structure and visualize the complete assembly.</p>"},{"location":"notebooks/7_sequence_library/","title":"The sequence library","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\nimport nglview as nv\n\nimport copy\nimport nglview as nv\nimport random\nfrom Bio.SVDSuperimposer import SVDSuperimposer\n\nimport mdna\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt import nglview as nv  import copy import nglview as nv import random from Bio.SVDSuperimposer import SVDSuperimposer  import mdna <pre></pre> In\u00a0[2]: Copied! <pre># Complemetary base pairs\nbase_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z','CM':'G','AH':'T','GM':'C'}\n        \n# Load reference bases from the atomic data        \nreference_bases = {base: md.load_hdf5(mdna.utils.get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in base_pair_map.keys()}\nbases = list(reference_bases.values())\n\n# Define grid to place the bases\norder = [['A', 'T', 'G', 'C'],\n        ['AH', 'U', 'GM', 'CM'], \n         ['B', 'S', 'P', 'Z'], \n         ['E', 'D','L', 'M']]\n\n\n# Initialize the trajectory with the first base\ntraj = reference_bases[order[0][0]]\n\n# Spacing parameters (in angstroms, adjust as needed)\nhorizontal_spacing = 1.2  # Spacing between bases within a row\nvertical_spacing = 1.5    # Spacing between rows\n\n# Base positions tracking\ny_position = 0  # Start at the top-most row and work downwards\n\nfor row in order:\n    x_position = 0  # Reset x position for each new row\n    for i, base in enumerate(row,1):\n        if i == 0 and row == order[0]:\n            # Already initialized with the first base\n            continue\n        # Move base in x and y direction\n        reference_bases[base].xyz[0] = reference_bases[base].xyz[0] + np.array([-x_position, y_position, 0])\n        # Stack the base to the trajectory\n        traj = traj.stack(reference_bases[base])\n        # Increment x position for the next base in the row\n        x_position += horizontal_spacing\n    # Decrement y position for the next row to position it below the current one\n    y_position -= vertical_spacing\n</pre> # Complemetary base pairs base_pair_map = {'A':'T','T':'A','G':'C','C':'G','U':'A','D':'G','E':'T','L':'M','M':'L','B':'S','S':'B','Z':'P','P':'Z','CM':'G','AH':'T','GM':'C'}          # Load reference bases from the atomic data         reference_bases = {base: md.load_hdf5(mdna.utils.get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in base_pair_map.keys()} bases = list(reference_bases.values())  # Define grid to place the bases order = [['A', 'T', 'G', 'C'],         ['AH', 'U', 'GM', 'CM'],           ['B', 'S', 'P', 'Z'],           ['E', 'D','L', 'M']]   # Initialize the trajectory with the first base traj = reference_bases[order[0][0]]  # Spacing parameters (in angstroms, adjust as needed) horizontal_spacing = 1.2  # Spacing between bases within a row vertical_spacing = 1.5    # Spacing between rows  # Base positions tracking y_position = 0  # Start at the top-most row and work downwards  for row in order:     x_position = 0  # Reset x position for each new row     for i, base in enumerate(row,1):         if i == 0 and row == order[0]:             # Already initialized with the first base             continue         # Move base in x and y direction         reference_bases[base].xyz[0] = reference_bases[base].xyz[0] + np.array([-x_position, y_position, 0])         # Stack the base to the trajectory         traj = traj.stack(reference_bases[base])         # Increment x position for the next base in the row         x_position += horizontal_spacing     # Decrement y position for the next row to position it below the current one     y_position -= vertical_spacing <p>Visualize the bases</p> In\u00a0[3]: Copied! <pre>subtraj = traj.atom_slice(traj.top.select('not element H'))\n# subtraj.save_pdb('all_bases.pdb')\n# subtraj.save_hdf5('all_bases.h5')\nview = nv.show_mdtraj(subtraj)    \nview.clear()\nview.add_representation('licorice', selection='all')\nview\n</pre> subtraj = traj.atom_slice(traj.top.select('not element H')) # subtraj.save_pdb('all_bases.pdb') # subtraj.save_hdf5('all_bases.h5') view = nv.show_mdtraj(subtraj)     view.clear() view.add_representation('licorice', selection='all') view <pre>NGLWidget()</pre> In\u00a0[4]: Copied! <pre>def get_base_vectors(res):\n       \"\"\"Compute base vectors from reference base.\"\"\"\n       ref_base = mdna.ReferenceBase(res)\n       return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n\ndef get_rot_mat_trans(x,y):\n    # load super imposer\n    sup = SVDSuperimposer()\n\n    # Set the coords, y will be rotated and translated on x\n    sup.set(x, y)\n\n    # Do the leastsquared fit\n    sup.run()\n\n    # Get the rms\n    rms = sup.get_rms()\n\n    # Get rotation (right multiplying!) and the translation\n    rot, tran = sup.get_rotran()\n    return rot, tran\n\n# Function to calculate positions from origin and vectors\ndef calculate_positions(triad):\n    \n    origin = triad[0]\n    vectors = triad[1:]\n    # Each row in vectors is added to the origin to get the end position\n    end_positions = origin + vectors\n    # Combine the origin with these end positions\n    positions = np.vstack([origin, end_positions])\n    return positions\n\n\ndef align_to_ref(traj, ref =  np.array([[0,0,0.0],[1,0,0],[0,1,0],[0,0,1]])):\n    vectors = get_base_vectors(traj)\n    positions = calculate_positions(vectors[0])\n    ref_position =  calculate_positions(ref)\n    rot, tran = get_rot_mat_trans(ref_position,positions)\n    new_xyz = np.dot(traj.xyz[0], rot) + tran\n    traj.xyz[0] = new_xyz\n    return traj\n</pre>  def get_base_vectors(res):        \"\"\"Compute base vectors from reference base.\"\"\"        ref_base = mdna.ReferenceBase(res)        return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)  def get_rot_mat_trans(x,y):     # load super imposer     sup = SVDSuperimposer()      # Set the coords, y will be rotated and translated on x     sup.set(x, y)      # Do the leastsquared fit     sup.run()      # Get the rms     rms = sup.get_rms()      # Get rotation (right multiplying!) and the translation     rot, tran = sup.get_rotran()     return rot, tran  # Function to calculate positions from origin and vectors def calculate_positions(triad):          origin = triad[0]     vectors = triad[1:]     # Each row in vectors is added to the origin to get the end position     end_positions = origin + vectors     # Combine the origin with these end positions     positions = np.vstack([origin, end_positions])     return positions   def align_to_ref(traj, ref =  np.array([[0,0,0.0],[1,0,0],[0,1,0],[0,0,1]])):     vectors = get_base_vectors(traj)     positions = calculate_positions(vectors[0])     ref_position =  calculate_positions(ref)     rot, tran = get_rot_mat_trans(ref_position,positions)     new_xyz = np.dot(traj.xyz[0], rot) + tran     traj.xyz[0] = new_xyz     return traj In\u00a0[5]: Copied! <pre># Create a DNA sequence with a methylated base\ndna = mdna.make('GCGCG')\ndna.methylate(CpG=True)\ntraj = dna.get_traj()\n\n# Select the methylated base\nmeth = traj.atom_slice(traj.top.select('resid 1'))\n\n# Align the methylated base to the reference frame\nmeth = align_to_ref(meth)\n\n# Save the methylated base\nmeth.save('./pdbs/BDNA_CM.pdb')\nmeth.save('./pdbs/BDNA_CM.h5')\n\n# Show the methylated base\nview = nv.show_mdtraj(meth)\nview.clear()\nview.add_ball_and_stick()\nview\n</pre>  # Create a DNA sequence with a methylated base dna = mdna.make('GCGCG') dna.methylate(CpG=True) traj = dna.get_traj()  # Select the methylated base meth = traj.atom_slice(traj.top.select('resid 1'))  # Align the methylated base to the reference frame meth = align_to_ref(meth)  # Save the methylated base meth.save('./pdbs/BDNA_CM.pdb') meth.save('./pdbs/BDNA_CM.h5')  # Show the methylated base view = nv.show_mdtraj(meth) view.clear() view.add_ball_and_stick() view <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 5\n\nMethylate all C in CpG context, superseeds methylations list.\nMethtylating: [1, 3]\n</pre> <pre>NGLWidget()</pre> In\u00a0[6]: Copied! <pre>def point_mutation(sequence, position=None, new_nucleotide=None):\n    if position is None:\n        position = random.randint(0, len(sequence) - 1)\n    if new_nucleotide is None:\n        nucleotides = ['A', 'T', 'C', 'G']\n        new_nucleotide = random.choice([n for n in nucleotides if n != sequence[position]])\n    \n    mutated_sequence = list(sequence)\n    mutated_sequence[position] = new_nucleotide\n    return ''.join(mutated_sequence)\n\ndef radiate_system(dna, new_sequence, complementary=True, chainids=[0,1], verbose=False):\n\n    pdb = copy.deepcopy(dna.get_traj())   \n    if verbose:\n        print('--- current stat of the system ---')\n    s = dna.sequence\n    if len(s) != len(new_sequence):\n        raise ValueError('The length of the new sequence does not match the length of the current sequence')\n    if verbose:\n        print(len(s),s)\n        print(''.join(s))\n    mutations = mdna.get_mutations(s,new_sequence)\n    if verbose:\n        print(f'start mutation ---- {mutations} ----')    \n    # dna = pdb.atom_slice(pdb.top.select(f'chainid {chainids[0]} {chainids[1]}'))\n    # if verbose:\n    #     for c in dna.top.chains:\n    #         print(c.index, c._residues)\n\n    dna.mutate(mutations,complementary=complementary)\n    mutant_sequence = dna.sequence\n    if verbose:\n        print(mutant_sequence)\n        print(''.join(mutant_sequence))\n    new_traj = dna.get_traj()\n    if verbose:\n        for c in new_traj.top.chains:\n            print(c.index, c._residues)\n        print('--- end radiation ---')\n    return new_traj\n</pre> def point_mutation(sequence, position=None, new_nucleotide=None):     if position is None:         position = random.randint(0, len(sequence) - 1)     if new_nucleotide is None:         nucleotides = ['A', 'T', 'C', 'G']         new_nucleotide = random.choice([n for n in nucleotides if n != sequence[position]])          mutated_sequence = list(sequence)     mutated_sequence[position] = new_nucleotide     return ''.join(mutated_sequence)  def radiate_system(dna, new_sequence, complementary=True, chainids=[0,1], verbose=False):      pdb = copy.deepcopy(dna.get_traj())        if verbose:         print('--- current stat of the system ---')     s = dna.sequence     if len(s) != len(new_sequence):         raise ValueError('The length of the new sequence does not match the length of the current sequence')     if verbose:         print(len(s),s)         print(''.join(s))     mutations = mdna.get_mutations(s,new_sequence)     if verbose:         print(f'start mutation ---- {mutations} ----')         # dna = pdb.atom_slice(pdb.top.select(f'chainid {chainids[0]} {chainids[1]}'))     # if verbose:     #     for c in dna.top.chains:     #         print(c.index, c._residues)      dna.mutate(mutations,complementary=complementary)     mutant_sequence = dna.sequence     if verbose:         print(mutant_sequence)         print(''.join(mutant_sequence))     new_traj = dna.get_traj()     if verbose:         for c in new_traj.top.chains:             print(c.index, c._residues)         print('--- end radiation ---')     return new_traj In\u00a0[7]: Copied! <pre># Example usage\nsave = False\ndna = mdna.make('GCGCG')\npoint_mutations = np.unique([point_mutation(dna.sequence) for _ in range(100)])\n\nfor i, new_sequence in enumerate(point_mutations):\n    mutant = radiate_system(dna, list(new_sequence))\n    print(new_sequence,f'saved as point_mutant_{i}.pdb')\n    if save:\n        mutant.save(f'./pdbs/point_mutant_{i}.pdb')\n</pre> # Example usage save = False dna = mdna.make('GCGCG') point_mutations = np.unique([point_mutation(dna.sequence) for _ in range(100)])  for i, new_sequence in enumerate(point_mutations):     mutant = radiate_system(dna, list(new_sequence))     print(new_sequence,f'saved as point_mutant_{i}.pdb')     if save:         mutant.save(f'./pdbs/point_mutant_{i}.pdb')  <pre>\nStart rescaling spline based on requested number of base pairs.\n\tThis requires recomputation of the control points to match the desired number of base pairs.\n\tSpline scaled to match the target number of base pairs: 5\n\nhello\nPre-deletion residue atoms : [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N9'), (12, 'C8'), (13, 'N7'), (14, 'C5'), (15, 'C6'), (16, 'O6'), (17, 'N1'), (18, 'C2'), (19, 'N2'), (20, 'N3'), (21, 'C4')]\nPre-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\")]\nPost-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N9'), (12, 'C8'), (13, 'N7'), (14, 'C5'), (15, 'C6'), (16, 'N6'), (17, 'N1'), (18, 'C2'), (19, 'N3'), (20, 'C4')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 11, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 183, 3)\nConcatenated shape: 204\nPre-deletion residue atoms : [(185, 'P'), (186, 'OP1'), (187, 'OP2'), (188, \"O5'\"), (189, \"C5'\"), (190, \"C4'\"), (191, \"O4'\"), (192, \"C3'\"), (193, \"O3'\"), (194, \"C2'\"), (195, \"C1'\"), (196, 'N1'), (197, 'C2'), (198, 'O2'), (199, 'N3'), (200, 'C4'), (201, 'N4'), (202, 'C5'), (203, 'C6')]\nPre-insertion residue atoms: [(185, 'P'), (186, 'OP1'), (187, 'OP2'), (188, \"O5'\"), (189, \"C5'\"), (190, \"C4'\"), (191, \"O4'\"), (192, \"C3'\"), (193, \"O3'\"), (194, \"C2'\"), (195, \"C1'\")]\nPost-insertion residue atoms: [(185, 'P'), (186, 'OP1'), (187, 'OP2'), (188, \"O5'\"), (189, \"C5'\"), (190, \"C4'\"), (191, \"O4'\"), (192, \"C3'\"), (193, \"O3'\"), (194, \"C2'\"), (195, \"C1'\"), (197, 'N1'), (199, 'C2'), (201, 'O2'), (203, 'N3'), (205, 'C4'), (207, 'O4'), (209, 'C5'), (211, 'C7'), (213, 'C6')]\nOriginal trajectory shape: (1, 204, 3)\nxyz1 shape: (1, 196, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 0, 3)\nConcatenated shape: 205\nACGCG saved as point_mutant_0.pdb\nhello\nPre-deletion residue atoms : [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N9'), (12, 'C8'), (13, 'N7'), (14, 'C5'), (15, 'C6'), (16, 'N6'), (17, 'N1'), (18, 'C2'), (19, 'N3'), (20, 'C4')]\nPre-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\")]\nPost-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N1'), (12, 'C2'), (13, 'O2'), (14, 'N3'), (15, 'C4'), (16, 'N4'), (17, 'C5'), (18, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 11, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 184, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(183, 'P'), (184, 'OP1'), (185, 'OP2'), (186, \"O5'\"), (187, \"C5'\"), (188, \"C4'\"), (189, \"O4'\"), (190, \"C3'\"), (191, \"O3'\"), (192, \"C2'\"), (193, \"C1'\"), (194, 'N1'), (195, 'C2'), (196, 'O2'), (197, 'N3'), (198, 'C4'), (199, 'O4'), (200, 'C5'), (201, 'C7'), (202, 'C6')]\nPre-insertion residue atoms: [(183, 'P'), (184, 'OP1'), (185, 'OP2'), (186, \"O5'\"), (187, \"C5'\"), (188, \"C4'\"), (189, \"O4'\"), (190, \"C3'\"), (191, \"O3'\"), (192, \"C2'\"), (193, \"C1'\")]\nPost-insertion residue atoms: [(183, 'P'), (184, 'OP1'), (185, 'OP2'), (186, \"O5'\"), (187, \"C5'\"), (188, \"C4'\"), (189, \"O4'\"), (190, \"C3'\"), (191, \"O3'\"), (192, \"C2'\"), (193, \"C1'\"), (195, 'N9'), (197, 'C8'), (199, 'N7'), (201, 'C5'), (203, 'C6'), (205, 'O6'), (207, 'N1'), (209, 'C2'), (211, 'N2'), (213, 'N3'), (215, 'C4')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 194, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 0, 3)\nConcatenated shape: 205\nCCGCG saved as point_mutant_1.pdb\nhello\nPre-deletion residue atoms : [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N1'), (12, 'C2'), (13, 'O2'), (14, 'N3'), (15, 'C4'), (16, 'N4'), (17, 'C5'), (18, 'C6')]\nPre-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\")]\nPost-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N9'), (12, 'C8'), (13, 'N7'), (14, 'C5'), (15, 'C6'), (16, 'O6'), (17, 'N1'), (18, 'C2'), (19, 'N2'), (20, 'N3'), (21, 'C4')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 11, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 186, 3)\nConcatenated shape: 208\nPre-deletion residue atoms : [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N1'), (34, 'C2'), (35, 'O2'), (36, 'N3'), (37, 'C4'), (38, 'N4'), (39, 'C5'), (40, 'C6')]\nPre-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\")]\nPost-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N9'), (34, 'C8'), (35, 'N7'), (36, 'C5'), (37, 'C6'), (38, 'N6'), (39, 'N1'), (40, 'C2'), (41, 'N3'), (42, 'C4')]\nOriginal trajectory shape: (1, 208, 3)\nxyz1 shape: (1, 33, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 167, 3)\nConcatenated shape: 210\nPre-deletion residue atoms : [(188, 'P'), (189, 'OP1'), (190, 'OP2'), (191, \"O5'\"), (192, \"C5'\"), (193, \"C4'\"), (194, \"O4'\"), (195, \"C3'\"), (196, \"O3'\"), (197, \"C2'\"), (198, \"C1'\"), (199, 'N9'), (200, 'C8'), (201, 'N7'), (202, 'C5'), (203, 'C6'), (204, 'O6'), (205, 'N1'), (206, 'C2'), (207, 'N2'), (208, 'N3'), (209, 'C4')]\nPre-insertion residue atoms: [(188, 'P'), (189, 'OP1'), (190, 'OP2'), (191, \"O5'\"), (192, \"C5'\"), (193, \"C4'\"), (194, \"O4'\"), (195, \"C3'\"), (196, \"O3'\"), (197, \"C2'\"), (198, \"C1'\")]\nPost-insertion residue atoms: [(188, 'P'), (189, 'OP1'), (190, 'OP2'), (191, \"O5'\"), (192, \"C5'\"), (193, \"C4'\"), (194, \"O4'\"), (195, \"C3'\"), (196, \"O3'\"), (197, \"C2'\"), (198, \"C1'\"), (200, 'N1'), (202, 'C2'), (204, 'O2'), (206, 'N3'), (208, 'C4'), (210, 'N4'), (212, 'C5'), (214, 'C6')]\nOriginal trajectory shape: (1, 210, 3)\nxyz1 shape: (1, 199, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 0, 3)\nConcatenated shape: 207\nPre-deletion residue atoms : [(166, 'P'), (167, 'OP1'), (168, 'OP2'), (169, \"O5'\"), (170, \"C5'\"), (171, \"C4'\"), (172, \"O4'\"), (173, \"C3'\"), (174, \"O3'\"), (175, \"C2'\"), (176, \"C1'\"), (177, 'N9'), (178, 'C8'), (179, 'N7'), (180, 'C5'), (181, 'C6'), (182, 'O6'), (183, 'N1'), (184, 'C2'), (185, 'N2'), (186, 'N3'), (187, 'C4')]\nPre-insertion residue atoms: [(166, 'P'), (167, 'OP1'), (168, 'OP2'), (169, \"O5'\"), (170, \"C5'\"), (171, \"C4'\"), (172, \"O4'\"), (173, \"C3'\"), (174, \"O3'\"), (175, \"C2'\"), (176, \"C1'\")]\nPost-insertion residue atoms: [(166, 'P'), (167, 'OP1'), (168, 'OP2'), (169, \"O5'\"), (170, \"C5'\"), (171, \"C4'\"), (172, \"O4'\"), (173, \"C3'\"), (174, \"O3'\"), (175, \"C2'\"), (176, \"C1'\"), (177, 'N1'), (178, 'C2'), (179, 'O2'), (180, 'N3'), (181, 'C4'), (182, 'O4'), (183, 'C5'), (184, 'C7'), (185, 'C6')]\nOriginal trajectory shape: (1, 207, 3)\nxyz1 shape: (1, 177, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 19, 3)\nConcatenated shape: 205\nGAGCG saved as point_mutant_2.pdb\nhello\nPre-deletion residue atoms : [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N9'), (34, 'C8'), (35, 'N7'), (36, 'C5'), (37, 'C6'), (38, 'N6'), (39, 'N1'), (40, 'C2'), (41, 'N3'), (42, 'C4')]\nPre-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\")]\nPost-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N1'), (34, 'C2'), (35, 'O2'), (36, 'N3'), (37, 'C4'), (38, 'N4'), (39, 'C5'), (40, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 33, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 162, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N9'), (53, 'C8'), (54, 'N7'), (55, 'C5'), (56, 'C6'), (57, 'O6'), (58, 'N1'), (59, 'C2'), (60, 'N2'), (61, 'N3'), (62, 'C4')]\nPre-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\")]\nPost-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N9'), (53, 'C8'), (54, 'N7'), (55, 'C5'), (56, 'C6'), (57, 'N6'), (58, 'N1'), (59, 'C2'), (60, 'N3'), (61, 'C4')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 52, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 140, 3)\nConcatenated shape: 202\nPre-deletion residue atoms : [(163, 'P'), (164, 'OP1'), (165, 'OP2'), (166, \"O5'\"), (167, \"C5'\"), (168, \"C4'\"), (169, \"O4'\"), (170, \"C3'\"), (171, \"O3'\"), (172, \"C2'\"), (173, \"C1'\"), (174, 'N1'), (175, 'C2'), (176, 'O2'), (177, 'N3'), (178, 'C4'), (179, 'O4'), (180, 'C5'), (181, 'C7'), (182, 'C6')]\nPre-insertion residue atoms: [(163, 'P'), (164, 'OP1'), (165, 'OP2'), (166, \"O5'\"), (167, \"C5'\"), (168, \"C4'\"), (169, \"O4'\"), (170, \"C3'\"), (171, \"O3'\"), (172, \"C2'\"), (173, \"C1'\")]\nPost-insertion residue atoms: [(163, 'P'), (164, 'OP1'), (165, 'OP2'), (166, \"O5'\"), (167, \"C5'\"), (168, \"C4'\"), (169, \"O4'\"), (170, \"C3'\"), (171, \"O3'\"), (172, \"C2'\"), (173, \"C1'\"), (174, 'N9'), (175, 'C8'), (176, 'N7'), (177, 'C5'), (178, 'C6'), (179, 'O6'), (180, 'N1'), (181, 'C2'), (182, 'N2'), (183, 'N3'), (184, 'C4')]\nOriginal trajectory shape: (1, 202, 3)\nxyz1 shape: (1, 174, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 19, 3)\nConcatenated shape: 204\nPre-deletion residue atoms : [(144, 'P'), (145, 'OP1'), (146, 'OP2'), (147, \"O5'\"), (148, \"C5'\"), (149, \"C4'\"), (150, \"O4'\"), (151, \"C3'\"), (152, \"O3'\"), (153, \"C2'\"), (154, \"C1'\"), (155, 'N1'), (156, 'C2'), (157, 'O2'), (158, 'N3'), (159, 'C4'), (160, 'N4'), (161, 'C5'), (162, 'C6')]\nPre-insertion residue atoms: [(144, 'P'), (145, 'OP1'), (146, 'OP2'), (147, \"O5'\"), (148, \"C5'\"), (149, \"C4'\"), (150, \"O4'\"), (151, \"C3'\"), (152, \"O3'\"), (153, \"C2'\"), (154, \"C1'\")]\nPost-insertion residue atoms: [(144, 'P'), (145, 'OP1'), (146, 'OP2'), (147, \"O5'\"), (148, \"C5'\"), (149, \"C4'\"), (150, \"O4'\"), (151, \"C3'\"), (152, \"O3'\"), (153, \"C2'\"), (154, \"C1'\"), (155, 'N1'), (156, 'C2'), (157, 'O2'), (158, 'N3'), (159, 'C4'), (160, 'O4'), (161, 'C5'), (162, 'C7'), (163, 'C6')]\nOriginal trajectory shape: (1, 204, 3)\nxyz1 shape: (1, 155, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 41, 3)\nConcatenated shape: 205\nGCACG saved as point_mutant_3.pdb\nhello\nPre-deletion residue atoms : [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N9'), (53, 'C8'), (54, 'N7'), (55, 'C5'), (56, 'C6'), (57, 'N6'), (58, 'N1'), (59, 'C2'), (60, 'N3'), (61, 'C4')]\nPre-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\")]\nPost-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N1'), (53, 'C2'), (54, 'O2'), (55, 'N3'), (56, 'C4'), (57, 'N4'), (58, 'C5'), (59, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 52, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 143, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(142, 'P'), (143, 'OP1'), (144, 'OP2'), (145, \"O5'\"), (146, \"C5'\"), (147, \"C4'\"), (148, \"O4'\"), (149, \"C3'\"), (150, \"O3'\"), (151, \"C2'\"), (152, \"C1'\"), (153, 'N1'), (154, 'C2'), (155, 'O2'), (156, 'N3'), (157, 'C4'), (158, 'O4'), (159, 'C5'), (160, 'C7'), (161, 'C6')]\nPre-insertion residue atoms: [(142, 'P'), (143, 'OP1'), (144, 'OP2'), (145, \"O5'\"), (146, \"C5'\"), (147, \"C4'\"), (148, \"O4'\"), (149, \"C3'\"), (150, \"O3'\"), (151, \"C2'\"), (152, \"C1'\")]\nPost-insertion residue atoms: [(142, 'P'), (143, 'OP1'), (144, 'OP2'), (145, \"O5'\"), (146, \"C5'\"), (147, \"C4'\"), (148, \"O4'\"), (149, \"C3'\"), (150, \"O3'\"), (151, \"C2'\"), (152, \"C1'\"), (153, 'N9'), (154, 'C8'), (155, 'N7'), (156, 'C5'), (157, 'C6'), (158, 'O6'), (159, 'N1'), (160, 'C2'), (161, 'N2'), (162, 'N3'), (163, 'C4')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 153, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 41, 3)\nConcatenated shape: 205\nGCCCG saved as point_mutant_4.pdb\nhello\nPre-deletion residue atoms : [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N1'), (53, 'C2'), (54, 'O2'), (55, 'N3'), (56, 'C4'), (57, 'N4'), (58, 'C5'), (59, 'C6')]\nPre-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\")]\nPost-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N9'), (53, 'C8'), (54, 'N7'), (55, 'C5'), (56, 'C6'), (57, 'O6'), (58, 'N1'), (59, 'C2'), (60, 'N2'), (61, 'N3'), (62, 'C4')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 52, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 145, 3)\nConcatenated shape: 208\nPre-deletion residue atoms : [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N1'), (75, 'C2'), (76, 'O2'), (77, 'N3'), (78, 'C4'), (79, 'N4'), (80, 'C5'), (81, 'C6')]\nPre-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\")]\nPost-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N9'), (75, 'C8'), (76, 'N7'), (77, 'C5'), (78, 'C6'), (79, 'N6'), (80, 'N1'), (81, 'C2'), (82, 'N3'), (83, 'C4')]\nOriginal trajectory shape: (1, 208, 3)\nxyz1 shape: (1, 74, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 126, 3)\nConcatenated shape: 210\nPre-deletion residue atoms : [(147, 'P'), (148, 'OP1'), (149, 'OP2'), (150, \"O5'\"), (151, \"C5'\"), (152, \"C4'\"), (153, \"O4'\"), (154, \"C3'\"), (155, \"O3'\"), (156, \"C2'\"), (157, \"C1'\"), (158, 'N9'), (159, 'C8'), (160, 'N7'), (161, 'C5'), (162, 'C6'), (163, 'O6'), (164, 'N1'), (165, 'C2'), (166, 'N2'), (167, 'N3'), (168, 'C4')]\nPre-insertion residue atoms: [(147, 'P'), (148, 'OP1'), (149, 'OP2'), (150, \"O5'\"), (151, \"C5'\"), (152, \"C4'\"), (153, \"O4'\"), (154, \"C3'\"), (155, \"O3'\"), (156, \"C2'\"), (157, \"C1'\")]\nPost-insertion residue atoms: [(147, 'P'), (148, 'OP1'), (149, 'OP2'), (150, \"O5'\"), (151, \"C5'\"), (152, \"C4'\"), (153, \"O4'\"), (154, \"C3'\"), (155, \"O3'\"), (156, \"C2'\"), (157, \"C1'\"), (158, 'N1'), (159, 'C2'), (160, 'O2'), (161, 'N3'), (162, 'C4'), (163, 'N4'), (164, 'C5'), (165, 'C6')]\nOriginal trajectory shape: (1, 210, 3)\nxyz1 shape: (1, 158, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 41, 3)\nConcatenated shape: 207\nPre-deletion residue atoms : [(125, 'P'), (126, 'OP1'), (127, 'OP2'), (128, \"O5'\"), (129, \"C5'\"), (130, \"C4'\"), (131, \"O4'\"), (132, \"C3'\"), (133, \"O3'\"), (134, \"C2'\"), (135, \"C1'\"), (136, 'N9'), (137, 'C8'), (138, 'N7'), (139, 'C5'), (140, 'C6'), (141, 'O6'), (142, 'N1'), (143, 'C2'), (144, 'N2'), (145, 'N3'), (146, 'C4')]\nPre-insertion residue atoms: [(125, 'P'), (126, 'OP1'), (127, 'OP2'), (128, \"O5'\"), (129, \"C5'\"), (130, \"C4'\"), (131, \"O4'\"), (132, \"C3'\"), (133, \"O3'\"), (134, \"C2'\"), (135, \"C1'\")]\nPost-insertion residue atoms: [(125, 'P'), (126, 'OP1'), (127, 'OP2'), (128, \"O5'\"), (129, \"C5'\"), (130, \"C4'\"), (131, \"O4'\"), (132, \"C3'\"), (133, \"O3'\"), (134, \"C2'\"), (135, \"C1'\"), (136, 'N1'), (137, 'C2'), (138, 'O2'), (139, 'N3'), (140, 'C4'), (141, 'O4'), (142, 'C5'), (143, 'C7'), (144, 'C6')]\nOriginal trajectory shape: (1, 207, 3)\nxyz1 shape: (1, 136, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 60, 3)\nConcatenated shape: 205\nGCGAG saved as point_mutant_5.pdb\nhello\nPre-deletion residue atoms : [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N9'), (75, 'C8'), (76, 'N7'), (77, 'C5'), (78, 'C6'), (79, 'N6'), (80, 'N1'), (81, 'C2'), (82, 'N3'), (83, 'C4')]\nPre-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\")]\nPost-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N1'), (75, 'C2'), (76, 'O2'), (77, 'N3'), (78, 'C4'), (79, 'N4'), (80, 'C5'), (81, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 74, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 121, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\"), (93, 'N9'), (94, 'C8'), (95, 'N7'), (96, 'C5'), (97, 'C6'), (98, 'O6'), (99, 'N1'), (100, 'C2'), (101, 'N2'), (102, 'N3'), (103, 'C4')]\nPre-insertion residue atoms: [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\")]\nPost-insertion residue atoms: [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\"), (93, 'N9'), (94, 'C8'), (95, 'N7'), (96, 'C5'), (97, 'C6'), (98, 'N6'), (99, 'N1'), (100, 'C2'), (101, 'N3'), (102, 'C4')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 93, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 99, 3)\nConcatenated shape: 202\nPre-deletion residue atoms : [(122, 'P'), (123, 'OP1'), (124, 'OP2'), (125, \"O5'\"), (126, \"C5'\"), (127, \"C4'\"), (128, \"O4'\"), (129, \"C3'\"), (130, \"O3'\"), (131, \"C2'\"), (132, \"C1'\"), (133, 'N1'), (134, 'C2'), (135, 'O2'), (136, 'N3'), (137, 'C4'), (138, 'O4'), (139, 'C5'), (140, 'C7'), (141, 'C6')]\nPre-insertion residue atoms: [(122, 'P'), (123, 'OP1'), (124, 'OP2'), (125, \"O5'\"), (126, \"C5'\"), (127, \"C4'\"), (128, \"O4'\"), (129, \"C3'\"), (130, \"O3'\"), (131, \"C2'\"), (132, \"C1'\")]\nPost-insertion residue atoms: [(122, 'P'), (123, 'OP1'), (124, 'OP2'), (125, \"O5'\"), (126, \"C5'\"), (127, \"C4'\"), (128, \"O4'\"), (129, \"C3'\"), (130, \"O3'\"), (131, \"C2'\"), (132, \"C1'\"), (133, 'N9'), (134, 'C8'), (135, 'N7'), (136, 'C5'), (137, 'C6'), (138, 'O6'), (139, 'N1'), (140, 'C2'), (141, 'N2'), (142, 'N3'), (143, 'C4')]\nOriginal trajectory shape: (1, 202, 3)\nxyz1 shape: (1, 133, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 60, 3)\nConcatenated shape: 204\nPre-deletion residue atoms : [(103, 'P'), (104, 'OP1'), (105, 'OP2'), (106, \"O5'\"), (107, \"C5'\"), (108, \"C4'\"), (109, \"O4'\"), (110, \"C3'\"), (111, \"O3'\"), (112, \"C2'\"), (113, \"C1'\"), (114, 'N1'), (115, 'C2'), (116, 'O2'), (117, 'N3'), (118, 'C4'), (119, 'N4'), (120, 'C5'), (121, 'C6')]\nPre-insertion residue atoms: [(103, 'P'), (104, 'OP1'), (105, 'OP2'), (106, \"O5'\"), (107, \"C5'\"), (108, \"C4'\"), (109, \"O4'\"), (110, \"C3'\"), (111, \"O3'\"), (112, \"C2'\"), (113, \"C1'\")]\nPost-insertion residue atoms: [(103, 'P'), (104, 'OP1'), (105, 'OP2'), (106, \"O5'\"), (107, \"C5'\"), (108, \"C4'\"), (109, \"O4'\"), (110, \"C3'\"), (111, \"O3'\"), (112, \"C2'\"), (113, \"C1'\"), (114, 'N1'), (115, 'C2'), (116, 'O2'), (117, 'N3'), (118, 'C4'), (119, 'O4'), (120, 'C5'), (121, 'C7'), (122, 'C6')]\nOriginal trajectory shape: (1, 204, 3)\nxyz1 shape: (1, 114, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 82, 3)\nConcatenated shape: 205\nGCGCA saved as point_mutant_6.pdb\nhello\nPre-deletion residue atoms : [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\"), (93, 'N9'), (94, 'C8'), (95, 'N7'), (96, 'C5'), (97, 'C6'), (98, 'N6'), (99, 'N1'), (100, 'C2'), (101, 'N3'), (102, 'C4')]\nPre-insertion residue atoms: [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\")]\nPost-insertion residue atoms: [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\"), (93, 'N1'), (94, 'C2'), (95, 'O2'), (96, 'N3'), (97, 'C4'), (98, 'N4'), (99, 'C5'), (100, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 93, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 102, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(101, 'P'), (102, 'OP1'), (103, 'OP2'), (104, \"O5'\"), (105, \"C5'\"), (106, \"C4'\"), (107, \"O4'\"), (108, \"C3'\"), (109, \"O3'\"), (110, \"C2'\"), (111, \"C1'\"), (112, 'N1'), (113, 'C2'), (114, 'O2'), (115, 'N3'), (116, 'C4'), (117, 'O4'), (118, 'C5'), (119, 'C7'), (120, 'C6')]\nPre-insertion residue atoms: [(101, 'P'), (102, 'OP1'), (103, 'OP2'), (104, \"O5'\"), (105, \"C5'\"), (106, \"C4'\"), (107, \"O4'\"), (108, \"C3'\"), (109, \"O3'\"), (110, \"C2'\"), (111, \"C1'\")]\nPost-insertion residue atoms: [(101, 'P'), (102, 'OP1'), (103, 'OP2'), (104, \"O5'\"), (105, \"C5'\"), (106, \"C4'\"), (107, \"O4'\"), (108, \"C3'\"), (109, \"O3'\"), (110, \"C2'\"), (111, \"C1'\"), (112, 'N9'), (113, 'C8'), (114, 'N7'), (115, 'C5'), (116, 'C6'), (117, 'O6'), (118, 'N1'), (119, 'C2'), (120, 'N2'), (121, 'N3'), (122, 'C4')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 112, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 82, 3)\nConcatenated shape: 205\nGCGCC saved as point_mutant_7.pdb\nhello\nPre-deletion residue atoms : [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\"), (93, 'N1'), (94, 'C2'), (95, 'O2'), (96, 'N3'), (97, 'C4'), (98, 'N4'), (99, 'C5'), (100, 'C6')]\nPre-insertion residue atoms: [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\")]\nPost-insertion residue atoms: [(82, 'P'), (83, 'OP1'), (84, 'OP2'), (85, \"O5'\"), (86, \"C5'\"), (87, \"C4'\"), (88, \"O4'\"), (89, \"C3'\"), (90, \"O3'\"), (91, \"C2'\"), (92, \"C1'\"), (93, 'N1'), (94, 'C2'), (95, 'O2'), (96, 'N3'), (97, 'C4'), (98, 'O4'), (99, 'C5'), (100, 'C7'), (101, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 93, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 104, 3)\nConcatenated shape: 206\nPre-deletion residue atoms : [(102, 'P'), (103, 'OP1'), (104, 'OP2'), (105, \"O5'\"), (106, \"C5'\"), (107, \"C4'\"), (108, \"O4'\"), (109, \"C3'\"), (110, \"O3'\"), (111, \"C2'\"), (112, \"C1'\"), (113, 'N9'), (114, 'C8'), (115, 'N7'), (116, 'C5'), (117, 'C6'), (118, 'O6'), (119, 'N1'), (120, 'C2'), (121, 'N2'), (122, 'N3'), (123, 'C4')]\nPre-insertion residue atoms: [(102, 'P'), (103, 'OP1'), (104, 'OP2'), (105, \"O5'\"), (106, \"C5'\"), (107, \"C4'\"), (108, \"O4'\"), (109, \"C3'\"), (110, \"O3'\"), (111, \"C2'\"), (112, \"C1'\")]\nPost-insertion residue atoms: [(102, 'P'), (103, 'OP1'), (104, 'OP2'), (105, \"O5'\"), (106, \"C5'\"), (107, \"C4'\"), (108, \"O4'\"), (109, \"C3'\"), (110, \"O3'\"), (111, \"C2'\"), (112, \"C1'\"), (113, 'N9'), (114, 'C8'), (115, 'N7'), (116, 'C5'), (117, 'C6'), (118, 'N6'), (119, 'N1'), (120, 'C2'), (121, 'N3'), (122, 'C4')]\nOriginal trajectory shape: (1, 206, 3)\nxyz1 shape: (1, 113, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 82, 3)\nConcatenated shape: 205\nGCGCT saved as point_mutant_8.pdb\nhello\nPre-deletion residue atoms : [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N1'), (75, 'C2'), (76, 'O2'), (77, 'N3'), (78, 'C4'), (79, 'N4'), (80, 'C5'), (81, 'C6')]\nPre-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\")]\nPost-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N9'), (75, 'C8'), (76, 'N7'), (77, 'C5'), (78, 'C6'), (79, 'O6'), (80, 'N1'), (81, 'C2'), (82, 'N2'), (83, 'N3'), (84, 'C4')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 74, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 123, 3)\nConcatenated shape: 208\nPre-deletion residue atoms : [(85, 'P'), (86, 'OP1'), (87, 'OP2'), (88, \"O5'\"), (89, \"C5'\"), (90, \"C4'\"), (91, \"O4'\"), (92, \"C3'\"), (93, \"O3'\"), (94, \"C2'\"), (95, \"C1'\"), (96, 'N1'), (97, 'C2'), (98, 'O2'), (99, 'N3'), (100, 'C4'), (101, 'O4'), (102, 'C5'), (103, 'C7'), (104, 'C6')]\nPre-insertion residue atoms: [(85, 'P'), (86, 'OP1'), (87, 'OP2'), (88, \"O5'\"), (89, \"C5'\"), (90, \"C4'\"), (91, \"O4'\"), (92, \"C3'\"), (93, \"O3'\"), (94, \"C2'\"), (95, \"C1'\")]\nPost-insertion residue atoms: [(85, 'P'), (86, 'OP1'), (87, 'OP2'), (88, \"O5'\"), (89, \"C5'\"), (90, \"C4'\"), (91, \"O4'\"), (92, \"C3'\"), (93, \"O3'\"), (94, \"C2'\"), (95, \"C1'\"), (96, 'N9'), (97, 'C8'), (98, 'N7'), (99, 'C5'), (100, 'C6'), (101, 'O6'), (102, 'N1'), (103, 'C2'), (104, 'N2'), (105, 'N3'), (106, 'C4')]\nOriginal trajectory shape: (1, 208, 3)\nxyz1 shape: (1, 96, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 103, 3)\nConcatenated shape: 210\nPre-deletion residue atoms : [(128, 'P'), (129, 'OP1'), (130, 'OP2'), (131, \"O5'\"), (132, \"C5'\"), (133, \"C4'\"), (134, \"O4'\"), (135, \"C3'\"), (136, \"O3'\"), (137, \"C2'\"), (138, \"C1'\"), (139, 'N9'), (140, 'C8'), (141, 'N7'), (142, 'C5'), (143, 'C6'), (144, 'O6'), (145, 'N1'), (146, 'C2'), (147, 'N2'), (148, 'N3'), (149, 'C4')]\nPre-insertion residue atoms: [(128, 'P'), (129, 'OP1'), (130, 'OP2'), (131, \"O5'\"), (132, \"C5'\"), (133, \"C4'\"), (134, \"O4'\"), (135, \"C3'\"), (136, \"O3'\"), (137, \"C2'\"), (138, \"C1'\")]\nPost-insertion residue atoms: [(128, 'P'), (129, 'OP1'), (130, 'OP2'), (131, \"O5'\"), (132, \"C5'\"), (133, \"C4'\"), (134, \"O4'\"), (135, \"C3'\"), (136, \"O3'\"), (137, \"C2'\"), (138, \"C1'\"), (139, 'N1'), (140, 'C2'), (141, 'O2'), (142, 'N3'), (143, 'C4'), (144, 'N4'), (145, 'C5'), (146, 'C6')]\nOriginal trajectory shape: (1, 210, 3)\nxyz1 shape: (1, 139, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 60, 3)\nConcatenated shape: 207\nPre-deletion residue atoms : [(107, 'P'), (108, 'OP1'), (109, 'OP2'), (110, \"O5'\"), (111, \"C5'\"), (112, \"C4'\"), (113, \"O4'\"), (114, \"C3'\"), (115, \"O3'\"), (116, \"C2'\"), (117, \"C1'\"), (118, 'N9'), (119, 'C8'), (120, 'N7'), (121, 'C5'), (122, 'C6'), (123, 'N6'), (124, 'N1'), (125, 'C2'), (126, 'N3'), (127, 'C4')]\nPre-insertion residue atoms: [(107, 'P'), (108, 'OP1'), (109, 'OP2'), (110, \"O5'\"), (111, \"C5'\"), (112, \"C4'\"), (113, \"O4'\"), (114, \"C3'\"), (115, \"O3'\"), (116, \"C2'\"), (117, \"C1'\")]\nPost-insertion residue atoms: [(107, 'P'), (108, 'OP1'), (109, 'OP2'), (110, \"O5'\"), (111, \"C5'\"), (112, \"C4'\"), (113, \"O4'\"), (114, \"C3'\"), (115, \"O3'\"), (116, \"C2'\"), (117, \"C1'\"), (118, 'N1'), (119, 'C2'), (120, 'O2'), (121, 'N3'), (122, 'C4'), (123, 'N4'), (124, 'C5'), (125, 'C6')]\nOriginal trajectory shape: (1, 207, 3)\nxyz1 shape: (1, 118, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 79, 3)\nConcatenated shape: 205\nGCGGG saved as point_mutant_9.pdb\nhello\nPre-deletion residue atoms : [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N9'), (75, 'C8'), (76, 'N7'), (77, 'C5'), (78, 'C6'), (79, 'O6'), (80, 'N1'), (81, 'C2'), (82, 'N2'), (83, 'N3'), (84, 'C4')]\nPre-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\")]\nPost-insertion residue atoms: [(63, 'P'), (64, 'OP1'), (65, 'OP2'), (66, \"O5'\"), (67, \"C5'\"), (68, \"C4'\"), (69, \"O4'\"), (70, \"C3'\"), (71, \"O3'\"), (72, \"C2'\"), (73, \"C1'\"), (74, 'N1'), (75, 'C2'), (76, 'O2'), (77, 'N3'), (78, 'C4'), (79, 'O4'), (80, 'C5'), (81, 'C7'), (82, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 74, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 120, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(124, 'P'), (125, 'OP1'), (126, 'OP2'), (127, \"O5'\"), (128, \"C5'\"), (129, \"C4'\"), (130, \"O4'\"), (131, \"C3'\"), (132, \"O3'\"), (133, \"C2'\"), (134, \"C1'\"), (135, 'N1'), (136, 'C2'), (137, 'O2'), (138, 'N3'), (139, 'C4'), (140, 'N4'), (141, 'C5'), (142, 'C6')]\nPre-insertion residue atoms: [(124, 'P'), (125, 'OP1'), (126, 'OP2'), (127, \"O5'\"), (128, \"C5'\"), (129, \"C4'\"), (130, \"O4'\"), (131, \"C3'\"), (132, \"O3'\"), (133, \"C2'\"), (134, \"C1'\")]\nPost-insertion residue atoms: [(124, 'P'), (125, 'OP1'), (126, 'OP2'), (127, \"O5'\"), (128, \"C5'\"), (129, \"C4'\"), (130, \"O4'\"), (131, \"C3'\"), (132, \"O3'\"), (133, \"C2'\"), (134, \"C1'\"), (135, 'N9'), (136, 'C8'), (137, 'N7'), (138, 'C5'), (139, 'C6'), (140, 'N6'), (141, 'N1'), (142, 'C2'), (143, 'N3'), (144, 'C4')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 135, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 60, 3)\nConcatenated shape: 205\nGCGTG saved as point_mutant_10.pdb\nhello\nPre-deletion residue atoms : [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N9'), (53, 'C8'), (54, 'N7'), (55, 'C5'), (56, 'C6'), (57, 'O6'), (58, 'N1'), (59, 'C2'), (60, 'N2'), (61, 'N3'), (62, 'C4')]\nPre-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\")]\nPost-insertion residue atoms: [(41, 'P'), (42, 'OP1'), (43, 'OP2'), (44, \"O5'\"), (45, \"C5'\"), (46, \"C4'\"), (47, \"O4'\"), (48, \"C3'\"), (49, \"O3'\"), (50, \"C2'\"), (51, \"C1'\"), (52, 'N1'), (53, 'C2'), (54, 'O2'), (55, 'N3'), (56, 'C4'), (57, 'O4'), (58, 'C5'), (59, 'C7'), (60, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 52, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 142, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(61, 'P'), (62, 'OP1'), (63, 'OP2'), (64, \"O5'\"), (65, \"C5'\"), (66, \"C4'\"), (67, \"O4'\"), (68, \"C3'\"), (69, \"O3'\"), (70, \"C2'\"), (71, \"C1'\"), (72, 'N1'), (73, 'C2'), (74, 'O2'), (75, 'N3'), (76, 'C4'), (77, 'O4'), (78, 'C5'), (79, 'C7'), (80, 'C6')]\nPre-insertion residue atoms: [(61, 'P'), (62, 'OP1'), (63, 'OP2'), (64, \"O5'\"), (65, \"C5'\"), (66, \"C4'\"), (67, \"O4'\"), (68, \"C3'\"), (69, \"O3'\"), (70, \"C2'\"), (71, \"C1'\")]\nPost-insertion residue atoms: [(61, 'P'), (62, 'OP1'), (63, 'OP2'), (64, \"O5'\"), (65, \"C5'\"), (66, \"C4'\"), (67, \"O4'\"), (68, \"C3'\"), (69, \"O3'\"), (70, \"C2'\"), (71, \"C1'\"), (72, 'N1'), (73, 'C2'), (74, 'O2'), (75, 'N3'), (76, 'C4'), (77, 'N4'), (78, 'C5'), (79, 'C6')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 72, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 122, 3)\nConcatenated shape: 202\nPre-deletion residue atoms : [(142, 'P'), (143, 'OP1'), (144, 'OP2'), (145, \"O5'\"), (146, \"C5'\"), (147, \"C4'\"), (148, \"O4'\"), (149, \"C3'\"), (150, \"O3'\"), (151, \"C2'\"), (152, \"C1'\"), (153, 'N1'), (154, 'C2'), (155, 'O2'), (156, 'N3'), (157, 'C4'), (158, 'N4'), (159, 'C5'), (160, 'C6')]\nPre-insertion residue atoms: [(142, 'P'), (143, 'OP1'), (144, 'OP2'), (145, \"O5'\"), (146, \"C5'\"), (147, \"C4'\"), (148, \"O4'\"), (149, \"C3'\"), (150, \"O3'\"), (151, \"C2'\"), (152, \"C1'\")]\nPost-insertion residue atoms: [(142, 'P'), (143, 'OP1'), (144, 'OP2'), (145, \"O5'\"), (146, \"C5'\"), (147, \"C4'\"), (148, \"O4'\"), (149, \"C3'\"), (150, \"O3'\"), (151, \"C2'\"), (152, \"C1'\"), (153, 'N9'), (154, 'C8'), (155, 'N7'), (156, 'C5'), (157, 'C6'), (158, 'N6'), (159, 'N1'), (160, 'C2'), (161, 'N3'), (162, 'C4')]\nOriginal trajectory shape: (1, 202, 3)\nxyz1 shape: (1, 153, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 41, 3)\nConcatenated shape: 204\nPre-deletion residue atoms : [(121, 'P'), (122, 'OP1'), (123, 'OP2'), (124, \"O5'\"), (125, \"C5'\"), (126, \"C4'\"), (127, \"O4'\"), (128, \"C3'\"), (129, \"O3'\"), (130, \"C2'\"), (131, \"C1'\"), (132, 'N9'), (133, 'C8'), (134, 'N7'), (135, 'C5'), (136, 'C6'), (137, 'N6'), (138, 'N1'), (139, 'C2'), (140, 'N3'), (141, 'C4')]\nPre-insertion residue atoms: [(121, 'P'), (122, 'OP1'), (123, 'OP2'), (124, \"O5'\"), (125, \"C5'\"), (126, \"C4'\"), (127, \"O4'\"), (128, \"C3'\"), (129, \"O3'\"), (130, \"C2'\"), (131, \"C1'\")]\nPost-insertion residue atoms: [(121, 'P'), (122, 'OP1'), (123, 'OP2'), (124, \"O5'\"), (125, \"C5'\"), (126, \"C4'\"), (127, \"O4'\"), (128, \"C3'\"), (129, \"O3'\"), (130, \"C2'\"), (131, \"C1'\"), (132, 'N9'), (133, 'C8'), (134, 'N7'), (135, 'C5'), (136, 'C6'), (137, 'O6'), (138, 'N1'), (139, 'C2'), (140, 'N2'), (141, 'N3'), (142, 'C4')]\nOriginal trajectory shape: (1, 204, 3)\nxyz1 shape: (1, 132, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 62, 3)\nConcatenated shape: 205\nGCTCG saved as point_mutant_11.pdb\nhello\nPre-deletion residue atoms : [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N1'), (34, 'C2'), (35, 'O2'), (36, 'N3'), (37, 'C4'), (38, 'N4'), (39, 'C5'), (40, 'C6')]\nPre-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\")]\nPost-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N9'), (34, 'C8'), (35, 'N7'), (36, 'C5'), (37, 'C6'), (38, 'O6'), (39, 'N1'), (40, 'C2'), (41, 'N2'), (42, 'N3'), (43, 'C4')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 33, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 164, 3)\nConcatenated shape: 208\nPre-deletion residue atoms : [(44, 'P'), (45, 'OP1'), (46, 'OP2'), (47, \"O5'\"), (48, \"C5'\"), (49, \"C4'\"), (50, \"O4'\"), (51, \"C3'\"), (52, \"O3'\"), (53, \"C2'\"), (54, \"C1'\"), (55, 'N1'), (56, 'C2'), (57, 'O2'), (58, 'N3'), (59, 'C4'), (60, 'O4'), (61, 'C5'), (62, 'C7'), (63, 'C6')]\nPre-insertion residue atoms: [(44, 'P'), (45, 'OP1'), (46, 'OP2'), (47, \"O5'\"), (48, \"C5'\"), (49, \"C4'\"), (50, \"O4'\"), (51, \"C3'\"), (52, \"O3'\"), (53, \"C2'\"), (54, \"C1'\")]\nPost-insertion residue atoms: [(44, 'P'), (45, 'OP1'), (46, 'OP2'), (47, \"O5'\"), (48, \"C5'\"), (49, \"C4'\"), (50, \"O4'\"), (51, \"C3'\"), (52, \"O3'\"), (53, \"C2'\"), (54, \"C1'\"), (55, 'N9'), (56, 'C8'), (57, 'N7'), (58, 'C5'), (59, 'C6'), (60, 'O6'), (61, 'N1'), (62, 'C2'), (63, 'N2'), (64, 'N3'), (65, 'C4')]\nOriginal trajectory shape: (1, 208, 3)\nxyz1 shape: (1, 55, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 144, 3)\nConcatenated shape: 210\nPre-deletion residue atoms : [(169, 'P'), (170, 'OP1'), (171, 'OP2'), (172, \"O5'\"), (173, \"C5'\"), (174, \"C4'\"), (175, \"O4'\"), (176, \"C3'\"), (177, \"O3'\"), (178, \"C2'\"), (179, \"C1'\"), (180, 'N9'), (181, 'C8'), (182, 'N7'), (183, 'C5'), (184, 'C6'), (185, 'O6'), (186, 'N1'), (187, 'C2'), (188, 'N2'), (189, 'N3'), (190, 'C4')]\nPre-insertion residue atoms: [(169, 'P'), (170, 'OP1'), (171, 'OP2'), (172, \"O5'\"), (173, \"C5'\"), (174, \"C4'\"), (175, \"O4'\"), (176, \"C3'\"), (177, \"O3'\"), (178, \"C2'\"), (179, \"C1'\")]\nPost-insertion residue atoms: [(169, 'P'), (170, 'OP1'), (171, 'OP2'), (172, \"O5'\"), (173, \"C5'\"), (174, \"C4'\"), (175, \"O4'\"), (176, \"C3'\"), (177, \"O3'\"), (178, \"C2'\"), (179, \"C1'\"), (180, 'N1'), (181, 'C2'), (182, 'O2'), (183, 'N3'), (184, 'C4'), (185, 'N4'), (186, 'C5'), (187, 'C6')]\nOriginal trajectory shape: (1, 210, 3)\nxyz1 shape: (1, 180, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 19, 3)\nConcatenated shape: 207\nPre-deletion residue atoms : [(148, 'P'), (149, 'OP1'), (150, 'OP2'), (151, \"O5'\"), (152, \"C5'\"), (153, \"C4'\"), (154, \"O4'\"), (155, \"C3'\"), (156, \"O3'\"), (157, \"C2'\"), (158, \"C1'\"), (159, 'N9'), (160, 'C8'), (161, 'N7'), (162, 'C5'), (163, 'C6'), (164, 'N6'), (165, 'N1'), (166, 'C2'), (167, 'N3'), (168, 'C4')]\nPre-insertion residue atoms: [(148, 'P'), (149, 'OP1'), (150, 'OP2'), (151, \"O5'\"), (152, \"C5'\"), (153, \"C4'\"), (154, \"O4'\"), (155, \"C3'\"), (156, \"O3'\"), (157, \"C2'\"), (158, \"C1'\")]\nPost-insertion residue atoms: [(148, 'P'), (149, 'OP1'), (150, 'OP2'), (151, \"O5'\"), (152, \"C5'\"), (153, \"C4'\"), (154, \"O4'\"), (155, \"C3'\"), (156, \"O3'\"), (157, \"C2'\"), (158, \"C1'\"), (159, 'N1'), (160, 'C2'), (161, 'O2'), (162, 'N3'), (163, 'C4'), (164, 'N4'), (165, 'C5'), (166, 'C6')]\nOriginal trajectory shape: (1, 207, 3)\nxyz1 shape: (1, 159, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 38, 3)\nConcatenated shape: 205\nGGGCG saved as point_mutant_12.pdb\nhello\nPre-deletion residue atoms : [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N9'), (34, 'C8'), (35, 'N7'), (36, 'C5'), (37, 'C6'), (38, 'O6'), (39, 'N1'), (40, 'C2'), (41, 'N2'), (42, 'N3'), (43, 'C4')]\nPre-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\")]\nPost-insertion residue atoms: [(22, 'P'), (23, 'OP1'), (24, 'OP2'), (25, \"O5'\"), (26, \"C5'\"), (27, \"C4'\"), (28, \"O4'\"), (29, \"C3'\"), (30, \"O3'\"), (31, \"C2'\"), (32, \"C1'\"), (33, 'N1'), (34, 'C2'), (35, 'O2'), (36, 'N3'), (37, 'C4'), (38, 'O4'), (39, 'C5'), (40, 'C7'), (41, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 33, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 161, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(165, 'P'), (166, 'OP1'), (167, 'OP2'), (168, \"O5'\"), (169, \"C5'\"), (170, \"C4'\"), (171, \"O4'\"), (172, \"C3'\"), (173, \"O3'\"), (174, \"C2'\"), (175, \"C1'\"), (176, 'N1'), (177, 'C2'), (178, 'O2'), (179, 'N3'), (180, 'C4'), (181, 'N4'), (182, 'C5'), (183, 'C6')]\nPre-insertion residue atoms: [(165, 'P'), (166, 'OP1'), (167, 'OP2'), (168, \"O5'\"), (169, \"C5'\"), (170, \"C4'\"), (171, \"O4'\"), (172, \"C3'\"), (173, \"O3'\"), (174, \"C2'\"), (175, \"C1'\")]\nPost-insertion residue atoms: [(165, 'P'), (166, 'OP1'), (167, 'OP2'), (168, \"O5'\"), (169, \"C5'\"), (170, \"C4'\"), (171, \"O4'\"), (172, \"C3'\"), (173, \"O3'\"), (174, \"C2'\"), (175, \"C1'\"), (176, 'N9'), (177, 'C8'), (178, 'N7'), (179, 'C5'), (180, 'C6'), (181, 'N6'), (182, 'N1'), (183, 'C2'), (184, 'N3'), (185, 'C4')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 176, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 19, 3)\nConcatenated shape: 205\nGTGCG saved as point_mutant_13.pdb\nhello\nPre-deletion residue atoms : [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N9'), (12, 'C8'), (13, 'N7'), (14, 'C5'), (15, 'C6'), (16, 'O6'), (17, 'N1'), (18, 'C2'), (19, 'N2'), (20, 'N3'), (21, 'C4')]\nPre-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\")]\nPost-insertion residue atoms: [(0, 'P'), (1, 'OP1'), (2, 'OP2'), (3, \"O5'\"), (4, \"C5'\"), (5, \"C4'\"), (6, \"O4'\"), (7, \"C3'\"), (8, \"O3'\"), (9, \"C2'\"), (10, \"C1'\"), (11, 'N1'), (12, 'C2'), (13, 'O2'), (14, 'N3'), (15, 'C4'), (16, 'O4'), (17, 'C5'), (18, 'C7'), (19, 'C6')]\nOriginal trajectory shape: (1, 205, 3)\nxyz1 shape: (1, 11, 3)\nnew_xyz shape: (1, 9, 3)\nxyz2 shape: (1, 183, 3)\nConcatenated shape: 203\nPre-deletion residue atoms : [(20, 'P'), (21, 'OP1'), (22, 'OP2'), (23, \"O5'\"), (24, \"C5'\"), (25, \"C4'\"), (26, \"O4'\"), (27, \"C3'\"), (28, \"O3'\"), (29, \"C2'\"), (30, \"C1'\"), (31, 'N1'), (32, 'C2'), (33, 'O2'), (34, 'N3'), (35, 'C4'), (36, 'O4'), (37, 'C5'), (38, 'C7'), (39, 'C6')]\nPre-insertion residue atoms: [(20, 'P'), (21, 'OP1'), (22, 'OP2'), (23, \"O5'\"), (24, \"C5'\"), (25, \"C4'\"), (26, \"O4'\"), (27, \"C3'\"), (28, \"O3'\"), (29, \"C2'\"), (30, \"C1'\")]\nPost-insertion residue atoms: [(20, 'P'), (21, 'OP1'), (22, 'OP2'), (23, \"O5'\"), (24, \"C5'\"), (25, \"C4'\"), (26, \"O4'\"), (27, \"C3'\"), (28, \"O3'\"), (29, \"C2'\"), (30, \"C1'\"), (31, 'N1'), (32, 'C2'), (33, 'O2'), (34, 'N3'), (35, 'C4'), (36, 'N4'), (37, 'C5'), (38, 'C6')]\nOriginal trajectory shape: (1, 203, 3)\nxyz1 shape: (1, 31, 3)\nnew_xyz shape: (1, 8, 3)\nxyz2 shape: (1, 163, 3)\nConcatenated shape: 202\nPre-deletion residue atoms : [(183, 'P'), (184, 'OP1'), (185, 'OP2'), (186, \"O5'\"), (187, \"C5'\"), (188, \"C4'\"), (189, \"O4'\"), (190, \"C3'\"), (191, \"O3'\"), (192, \"C2'\"), (193, \"C1'\"), (194, 'N1'), (195, 'C2'), (196, 'O2'), (197, 'N3'), (198, 'C4'), (199, 'N4'), (200, 'C5'), (201, 'C6')]\nPre-insertion residue atoms: [(183, 'P'), (184, 'OP1'), (185, 'OP2'), (186, \"O5'\"), (187, \"C5'\"), (188, \"C4'\"), (189, \"O4'\"), (190, \"C3'\"), (191, \"O3'\"), (192, \"C2'\"), (193, \"C1'\")]\nPost-insertion residue atoms: [(183, 'P'), (184, 'OP1'), (185, 'OP2'), (186, \"O5'\"), (187, \"C5'\"), (188, \"C4'\"), (189, \"O4'\"), (190, \"C3'\"), (191, \"O3'\"), (192, \"C2'\"), (193, \"C1'\"), (195, 'N9'), (197, 'C8'), (199, 'N7'), (201, 'C5'), (203, 'C6'), (205, 'N6'), (207, 'N1'), (209, 'C2'), (211, 'N3'), (213, 'C4')]\nOriginal trajectory shape: (1, 202, 3)\nxyz1 shape: (1, 194, 3)\nnew_xyz shape: (1, 10, 3)\nxyz2 shape: (1, 0, 3)\nConcatenated shape: 204\nPre-deletion residue atoms : [(162, 'P'), (163, 'OP1'), (164, 'OP2'), (165, \"O5'\"), (166, \"C5'\"), (167, \"C4'\"), (168, \"O4'\"), (169, \"C3'\"), (170, \"O3'\"), (171, \"C2'\"), (172, \"C1'\"), (173, 'N9'), (174, 'C8'), (175, 'N7'), (176, 'C5'), (177, 'C6'), (178, 'N6'), (179, 'N1'), (180, 'C2'), (181, 'N3'), (182, 'C4')]\nPre-insertion residue atoms: [(162, 'P'), (163, 'OP1'), (164, 'OP2'), (165, \"O5'\"), (166, \"C5'\"), (167, \"C4'\"), (168, \"O4'\"), (169, \"C3'\"), (170, \"O3'\"), (171, \"C2'\"), (172, \"C1'\")]\nPost-insertion residue atoms: [(162, 'P'), (163, 'OP1'), (164, 'OP2'), (165, \"O5'\"), (166, \"C5'\"), (167, \"C4'\"), (168, \"O4'\"), (169, \"C3'\"), (170, \"O3'\"), (171, \"C2'\"), (172, \"C1'\"), (173, 'N9'), (174, 'C8'), (175, 'N7'), (176, 'C5'), (177, 'C6'), (178, 'O6'), (179, 'N1'), (180, 'C2'), (181, 'N2'), (182, 'N3'), (183, 'C4')]\nOriginal trajectory shape: (1, 204, 3)\nxyz1 shape: (1, 173, 3)\nnew_xyz shape: (1, 11, 3)\nxyz2 shape: (1, 21, 3)\nConcatenated shape: 205\nTCGCG saved as point_mutant_14.pdb\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/7_sequence_library/#the-sequence-library","title":"The sequence library\u00b6","text":"<p>In addition to the ...</p>"},{"location":"notebooks/7_sequence_library/#how-to-add-a-base-to-the-sequence-library","title":"How to add a base to the sequence library\u00b6","text":"<p>Here we show how to align a DNA nucleobase to a specific reference frame. We chose the default reference frame at the origin with the base vectors [1,0,0], [0,1,0], [0,0,1]. This can be useful if you want to add a custom nucleobase to the sequence libary. For this we need to isolate the base and add it to the sequence library (./atomic/) and add the pdb/h5 to the reference list in geometry.py <code>NUCLEOBASE_DICT</code> which contains all the atoms that belong to the nucleobas part as well as in the modify. Mutate.mutate <code>base_pair_map</code> which defines the complementary base partner. Here we show an example using a methylated base, but you can use any sequence you want. Just select the residue that you want to isolate.</p>"},{"location":"notebooks/7_sequence_library/#point-mutations","title":"Point mutations\u00b6","text":""},{"location":"notebooks/data/filament_minimal/","title":"H-NS Filament Minimal Dataset","text":"<p>This folder contains a compact, package-friendly subset of the full filament MD dataset.</p>"},{"location":"notebooks/data/filament_minimal/#purpose","title":"Purpose","text":"<p>The goal is to avoid shipping the full ~1.7 GB trajectory bundle while preserving deterministic filament construction behavior for the tutorial's non-random assembly path.</p> <p>This minimal dataset is designed for:</p> <ul> <li><code>Assembler.load_minimal_site_map(...)</code></li> <li><code>assembler.add_dimer(segment='minimal')</code></li> </ul>"},{"location":"notebooks/data/filament_minimal/#contents","title":"Contents","text":"<ul> <li><code>s1s1_start.pdb</code></li> <li><code>s2s2_start.pdb</code></li> <li><code>s1s1_extend.pdb</code></li> <li><code>s2s2_extend.pdb</code></li> <li><code>complex_frame_1.pdb</code></li> <li><code>manifest.json</code></li> </ul>"},{"location":"notebooks/data/filament_minimal/#size","title":"Size","text":"<ul> <li>Total: ~<code>1.5M</code></li> </ul>"},{"location":"notebooks/data/filament_minimal/#how-it-works","title":"How it works","text":"<p>Unlike the full dataset (many <code>.xtc</code> trajectories), this folder stores only a few selected source-state PDB frames:</p> <ul> <li>start-state source frames for <code>s1s1</code> and <code>s2s2</code></li> <li>extend-state source frames for <code>s1s1</code> and <code>s2s2</code></li> <li>one DBD-DNA complex frame</li> </ul> <p>At runtime, <code>Assembler.load_minimal_site_map(...)</code>:</p> <ol> <li>Loads these source PDBs</li> <li>Rebuilds segment/site maps using <code>SiteMapper</code></li> <li>Selects the required site structures for start/extend assembly</li> <li>Uses <code>complex_frame_1.pdb</code> for <code>add_dna(...)</code></li> </ol> <p>So the segmentation logic is still performed in code (like full mode), but from minimal source inputs.</p>"},{"location":"notebooks/data/filament_minimal/#generation","title":"Generation","text":"<p>This dataset is generated from <code>examples/data/filament_dataset</code> with:</p> <p><code>python examples/scripts/extract_minimal_filament_dataset.py --output-dir examples/data/filament_minimal</code></p> <p>The selection metadata (trajectory ids, stride, source mapping) is stored in <code>manifest.json</code>.</p>"},{"location":"notebooks/data/filament_minimal/#notes","title":"Notes","text":"<ul> <li><code>segment='minimal'</code> is intended for reproducible compact usage.</li> <li><code>segment='fixed'</code> and <code>segment='random'</code> remain tied to full trajectory-style site maps.</li> <li>If you regenerate with a different <code>--dna-frame-idx</code>, the output complex file name and manifest should stay consistent for your workflow.</li> </ul>"},{"location":"notebooks/modules/filament/","title":"Filament","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport mdtraj as md\nimport matplotlib.pyplot as plt\ntry:\n    import nglview as nv\nexcept ImportError:\n    nv = None\ntry:\n    import networkx as nx\nexcept ImportError:\n    nx = None\nfrom pathlib import Path\n</pre> import numpy as np import mdtraj as md import matplotlib.pyplot as plt try:     import nglview as nv except ImportError:     nv = None try:     import networkx as nx except ImportError:     nx = None from pathlib import Path In\u00a0[\u00a0]: Copied! <pre># https://biopython.org/docs/1.74/api/Bio.SVDSuperimposer.html\n# conda install conda-forge::biopython\nfrom Bio.SVDSuperimposer import SVDSuperimposer\n</pre> # https://biopython.org/docs/1.74/api/Bio.SVDSuperimposer.html # conda install conda-forge::biopython from Bio.SVDSuperimposer import SVDSuperimposer <p>from numpy import dot</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class SiteMapper:\n\n    def __init__(self, s1s1, s2s2, segments=dict, k=100):\n        \n        self.segments = segments\n        self.s1s1 = s1s1[::k]\n        self.s2s2 = s2s2[::k]\n        #self.get_site_map()\n        \n    def get_site_map(self):\n        \n        # get structures of the different sites\n        s1 = self.get_site_structures(self.s1s1,site='s1')\n        s2_from_s1 = self.get_site_structures(self.s1s1, site='s2')\n        s2 = self.get_site_structures(self.s2s2,site='s2')\n\n        h3_s1s1 = self.get_segment_structures(self.s1s1,site='h3')\n        h3_s2s2 = self.get_segment_structures(self.s2s2,site='h3')\n        h3 = md.join([h3_s1s1,h3_s2s2])\n\n        l2_s1s1 = self.get_segment_structures(self.s1s1,site='l2')\n        l2_s2s2 = self.get_segment_structures(self.s2s2,site='l2')\n        l2 = md.join([l2_s1s1,l2_s2s2])\n\n        dbd_s1s1 = self.get_segment_structures(self.s1s1,site='dbd')\n        dbd_s2s2 = self.get_segment_structures(self.s2s2,site='dbd')\n        dbd = md.join([dbd_s1s1,dbd_s2s2])\n\n        # map of the different sites\n        site_map = {'s1':s1,\n                'h3':h3,\n                's2':s2,\n                's2_end' : s2_from_s1,\n                'l2':l2,\n                'dbd':dbd}\n        \n        # fix resSeq numbering for second chain of s1 and s2\n        for c in site_map['s1'].top.chains:\n            if c.index == 1:\n                for res in c.residues:\n                    res.resSeq = res.resSeq - 137\n\n        for c in site_map['s2'].top.chains:\n            if c.index == 1:\n                for res in c.residues:\n                    res.resSeq = res.resSeq - 137\n                \n        return site_map\n\n    def check_selection(self,top,selection):\n        if selection == 'CA':\n            indices = top.select('name CA')\n        elif selection == 'backbone':\n            indices = top.select('backbone')\n        elif selection == 'sidechain':\n            indices = top.select('sidechain')\n        else:\n            indices = top.select('all')   \n        return indices \n    \n    def get_monomer_domain_indices(self,top,domain,chain=0,selection=None):\n        residues = np.array(top._chains[chain]._residues)\n        indices = self.check_selection(top,selection)\n        return [at.index for res in residues[domain] for at in res.atoms if at.index in indices]\n\n    def get_segment_structures(self,traj,site='dbd'):\n        chain_a = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=0, selection=None)\n        chain_b = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=1, selection=None)\n        A = traj.atom_slice(chain_a)\n        B = traj.atom_slice(chain_b)\n        return md.join([A,B])\n\n    def get_site_structures(self, traj,site='s1'):\n        chain_a = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=0, selection=None)\n        chain_b = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=1, selection=None)\n        return traj.atom_slice(np.sort(chain_a+chain_b))\n\n    def show_domain(self, system, domains, domain):\n        \"\"\"\"Not working yet, need to fix the selection of the atoms in the domain.\"\"\"\n        if nv is None:\n            raise ImportError('nglview is required for show_domain but is not installed.')\n        # shows first frame\n        top = system.top\n        view = nv.show_mdtraj(system[0])\n        view.clear()\n        indices = self.get_monomer_domain_indices(top, domains[domain], chain=0)\n        view.add_representation('cartoon',selection=[i for i in  top.select('all') if i not in indices],color='cornflowerblue')\n        top = system.topology\n        chain_id = 0\n        indices = self.get_monomer_domain_indices(top, domains[domain], chain=chain_id)\n        view.add_representation('cartoon',selection=indices,color='gold')\n        top = system.topology\n        chain_id = 1\n        indices = self.get_monomer_domain_indices(top, domains[domain], chain=chain_id)\n        view.add_representation('cartoon',selection=indices,color='red')\n        return view\n</pre> class SiteMapper:      def __init__(self, s1s1, s2s2, segments=dict, k=100):                  self.segments = segments         self.s1s1 = s1s1[::k]         self.s2s2 = s2s2[::k]         #self.get_site_map()              def get_site_map(self):                  # get structures of the different sites         s1 = self.get_site_structures(self.s1s1,site='s1')         s2_from_s1 = self.get_site_structures(self.s1s1, site='s2')         s2 = self.get_site_structures(self.s2s2,site='s2')          h3_s1s1 = self.get_segment_structures(self.s1s1,site='h3')         h3_s2s2 = self.get_segment_structures(self.s2s2,site='h3')         h3 = md.join([h3_s1s1,h3_s2s2])          l2_s1s1 = self.get_segment_structures(self.s1s1,site='l2')         l2_s2s2 = self.get_segment_structures(self.s2s2,site='l2')         l2 = md.join([l2_s1s1,l2_s2s2])          dbd_s1s1 = self.get_segment_structures(self.s1s1,site='dbd')         dbd_s2s2 = self.get_segment_structures(self.s2s2,site='dbd')         dbd = md.join([dbd_s1s1,dbd_s2s2])          # map of the different sites         site_map = {'s1':s1,                 'h3':h3,                 's2':s2,                 's2_end' : s2_from_s1,                 'l2':l2,                 'dbd':dbd}                  # fix resSeq numbering for second chain of s1 and s2         for c in site_map['s1'].top.chains:             if c.index == 1:                 for res in c.residues:                     res.resSeq = res.resSeq - 137          for c in site_map['s2'].top.chains:             if c.index == 1:                 for res in c.residues:                     res.resSeq = res.resSeq - 137                          return site_map      def check_selection(self,top,selection):         if selection == 'CA':             indices = top.select('name CA')         elif selection == 'backbone':             indices = top.select('backbone')         elif selection == 'sidechain':             indices = top.select('sidechain')         else:             indices = top.select('all')            return indices           def get_monomer_domain_indices(self,top,domain,chain=0,selection=None):         residues = np.array(top._chains[chain]._residues)         indices = self.check_selection(top,selection)         return [at.index for res in residues[domain] for at in res.atoms if at.index in indices]      def get_segment_structures(self,traj,site='dbd'):         chain_a = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=0, selection=None)         chain_b = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=1, selection=None)         A = traj.atom_slice(chain_a)         B = traj.atom_slice(chain_b)         return md.join([A,B])      def get_site_structures(self, traj,site='s1'):         chain_a = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=0, selection=None)         chain_b = self.get_monomer_domain_indices(top=traj.top, domain=self.segments[site], chain=1, selection=None)         return traj.atom_slice(np.sort(chain_a+chain_b))      def show_domain(self, system, domains, domain):         \"\"\"\"Not working yet, need to fix the selection of the atoms in the domain.\"\"\"         if nv is None:             raise ImportError('nglview is required for show_domain but is not installed.')         # shows first frame         top = system.top         view = nv.show_mdtraj(system[0])         view.clear()         indices = self.get_monomer_domain_indices(top, domains[domain], chain=0)         view.add_representation('cartoon',selection=[i for i in  top.select('all') if i not in indices],color='cornflowerblue')         top = system.topology         chain_id = 0         indices = self.get_monomer_domain_indices(top, domains[domain], chain=chain_id)         view.add_representation('cartoon',selection=indices,color='gold')         top = system.topology         chain_id = 1         indices = self.get_monomer_domain_indices(top, domains[domain], chain=chain_id)         view.add_representation('cartoon',selection=indices,color='red')         return view In\u00a0[\u00a0]: Copied! <pre>class Superimposer:\n\n    def __init__(self, A, B, overlap_A, overlap_B):\n        self.A = A\n        self.B = B\n        self.overlap_A = overlap_A\n        self.overlap_B = overlap_B\n\n    def get_rot_and_trans(self, subtraj_A,subtraj_B):\n        \n        \"\"\" fit only works now on a single frame (mdtraj returns xyz with shape (n_frames, atoms, xyz) \n            even for single frame trajs so hence the xyz[0]\"\"\"\n        \n        # load super imposer\n        sup = SVDSuperimposer()\n\n        # Set the coords, y will be rotated and translated on x\n        x = subtraj_A.xyz[0]\n        y = subtraj_B.xyz[0]\n        sup.set(x, y)\n\n        # Do the leastsquared fit\n        sup.run()\n\n        # Get the rms\n        rms = sup.get_rms()\n\n        # Get rotation (right multiplying!) and the translation\n        rot, tran = sup.get_rotran()\n        \n        # now we have the instructions to rotate B on A\n        return rot,tran,rms\n\n    def apply_superimposition(self, traj, rot, tran):\n        \n        # get xyz coordinates\n        xyz = traj.xyz[0]\n        \n        # rotate subject on target\n        new_xyz = np.dot(xyz, rot) + tran\n\n        # replace coordinates of traj\n        traj.xyz = new_xyz\n        return traj\n\n    def fit_B_on_A(self):\n        # create trajs containing only the selections\n        subtraj_A = self.A.atom_slice(self.overlap_A)\n        subtraj_B = self.B.atom_slice(self.overlap_B)\n\n        # obtain instructions to rotate and translate B on A based on substraj structures\n        rot, tran, _ = self.get_rot_and_trans(subtraj_A,subtraj_B)\n\n        # do the superimposition of B on A and subsitute old with new xyz of B\n        return self.apply_superimposition(self.B, rot, tran)\n</pre> class Superimposer:      def __init__(self, A, B, overlap_A, overlap_B):         self.A = A         self.B = B         self.overlap_A = overlap_A         self.overlap_B = overlap_B      def get_rot_and_trans(self, subtraj_A,subtraj_B):                  \"\"\" fit only works now on a single frame (mdtraj returns xyz with shape (n_frames, atoms, xyz)              even for single frame trajs so hence the xyz[0]\"\"\"                  # load super imposer         sup = SVDSuperimposer()          # Set the coords, y will be rotated and translated on x         x = subtraj_A.xyz[0]         y = subtraj_B.xyz[0]         sup.set(x, y)          # Do the leastsquared fit         sup.run()          # Get the rms         rms = sup.get_rms()          # Get rotation (right multiplying!) and the translation         rot, tran = sup.get_rotran()                  # now we have the instructions to rotate B on A         return rot,tran,rms      def apply_superimposition(self, traj, rot, tran):                  # get xyz coordinates         xyz = traj.xyz[0]                  # rotate subject on target         new_xyz = np.dot(xyz, rot) + tran          # replace coordinates of traj         traj.xyz = new_xyz         return traj      def fit_B_on_A(self):         # create trajs containing only the selections         subtraj_A = self.A.atom_slice(self.overlap_A)         subtraj_B = self.B.atom_slice(self.overlap_B)          # obtain instructions to rotate and translate B on A based on substraj structures         rot, tran, _ = self.get_rot_and_trans(subtraj_A,subtraj_B)          # do the superimposition of B on A and subsitute old with new xyz of B         return self.apply_superimposition(self.B, rot, tran) In\u00a0[\u00a0]: Copied! <pre>class Helper:\n    \n    @staticmethod\n    def check_if_dimerization(site):\n        if 's' in site:\n            return True\n        else:\n            return False\n        \n    @staticmethod\n    def get_termini(site_x,site_y):\n        chain_order = np.array(['s1','h3','s2','l2','dbd'])\n        x = np.argwhere(chain_order==site_x)\n        y = np.argwhere(chain_order==site_y)\n        if x &lt; y:\n            return ['N_terminus','C_terminus']\n        elif x &gt; y:\n            return ['C_terminus','N_terminus']\n\n    @staticmethod\n    def get_overlap_indices(top,n,chain=0,terminus=None):\n        residues = np.array(top._chains[chain]._residues)\n        if terminus == 'N_terminus': # get residues at end of chain\n            s = residues[len(residues)-n*2:len(residues)]\n            return [at.index for res in s for at in res.atoms]\n        elif terminus == 'C_terminus': # get residues at beginning of chain\n            s = residues[:n*2]\n            return [at.index for res in s for at in res.atoms]\n        else:\n            print('No terminus')\n\n    @staticmethod\n    def check_overlaps(overlap_A,overlap_B):\n\n        if len(overlap_A) != len(overlap_B):\n            print(len(overlap_A),len(overlap_B))\n            print('Something went wrong with finding the overlaps') \n        else:\n            False\n\n    @staticmethod\n    def remove_overlap_old(traj, overlap):\n        \"\"\"Works fine but is slow for large number of atoms... because top and traj get reinitialized\"\"\"\n        return traj.atom_slice([at.index for at in traj.top.atoms if at.index not in overlap])\n    \n    @staticmethod\n    def remove_overlap(traj, overlap):\n        indices_to_keep = [at.index for at in traj.top.atoms if at.index not in overlap]\n        xyz = np.array(traj.xyz[:, indices_to_keep], order='C')\n        for _,index in enumerate(overlap):\n            traj.top.delete_atom_by_index(index-_)\n        traj.xyz = xyz\n        return traj\n\n    @staticmethod    \n    def split_chain_topology(traj, leading_chain):\n        # split part of A in chain that is being extended and that is not\n        traj_active = traj.atom_slice(traj.top.select(f'chainid {leading_chain}'))\n        traj_passive = traj.atom_slice(traj.top.select(f'not chainid {leading_chain}'))\n        return traj_active, traj_passive\n\n    @staticmethod\n    def merge_chain_topology(A, B, keep_resSeq=True):\n        C = A.stack(B,keep_resSeq=keep_resSeq)\n        top = C.top\n        # Merge two tops (with two chains or more) to a top of one chain \n        out = md.Topology()\n        c = out.add_chain()\n        for chain in top.chains:\n            for residue in chain.residues:\n                r = out.add_residue(residue.name, c, residue.resSeq, residue.segment_id)\n                for atom in residue.atoms:\n                    out.add_atom(atom.name, atom.element, r, serial=atom.serial)\n        #     for bond in top.bonds:\n        #         a1, a2 = bond\n        #         out.add_bond(a1, a2, type=bond.type, order=bond.order)\n        out.create_standard_bonds() #rare manier om bonds te maken, maar werkt\n        C.top = out \n        return C\n</pre> class Helper:          @staticmethod     def check_if_dimerization(site):         if 's' in site:             return True         else:             return False              @staticmethod     def get_termini(site_x,site_y):         chain_order = np.array(['s1','h3','s2','l2','dbd'])         x = np.argwhere(chain_order==site_x)         y = np.argwhere(chain_order==site_y)         if x &lt; y:             return ['N_terminus','C_terminus']         elif x &gt; y:             return ['C_terminus','N_terminus']      @staticmethod     def get_overlap_indices(top,n,chain=0,terminus=None):         residues = np.array(top._chains[chain]._residues)         if terminus == 'N_terminus': # get residues at end of chain             s = residues[len(residues)-n*2:len(residues)]             return [at.index for res in s for at in res.atoms]         elif terminus == 'C_terminus': # get residues at beginning of chain             s = residues[:n*2]             return [at.index for res in s for at in res.atoms]         else:             print('No terminus')      @staticmethod     def check_overlaps(overlap_A,overlap_B):          if len(overlap_A) != len(overlap_B):             print(len(overlap_A),len(overlap_B))             print('Something went wrong with finding the overlaps')          else:             False      @staticmethod     def remove_overlap_old(traj, overlap):         \"\"\"Works fine but is slow for large number of atoms... because top and traj get reinitialized\"\"\"         return traj.atom_slice([at.index for at in traj.top.atoms if at.index not in overlap])          @staticmethod     def remove_overlap(traj, overlap):         indices_to_keep = [at.index for at in traj.top.atoms if at.index not in overlap]         xyz = np.array(traj.xyz[:, indices_to_keep], order='C')         for _,index in enumerate(overlap):             traj.top.delete_atom_by_index(index-_)         traj.xyz = xyz         return traj      @staticmethod         def split_chain_topology(traj, leading_chain):         # split part of A in chain that is being extended and that is not         traj_active = traj.atom_slice(traj.top.select(f'chainid {leading_chain}'))         traj_passive = traj.atom_slice(traj.top.select(f'not chainid {leading_chain}'))         return traj_active, traj_passive      @staticmethod     def merge_chain_topology(A, B, keep_resSeq=True):         C = A.stack(B,keep_resSeq=keep_resSeq)         top = C.top         # Merge two tops (with two chains or more) to a top of one chain          out = md.Topology()         c = out.add_chain()         for chain in top.chains:             for residue in chain.residues:                 r = out.add_residue(residue.name, c, residue.resSeq, residue.segment_id)                 for atom in residue.atoms:                     out.add_atom(atom.name, atom.element, r, serial=atom.serial)         #     for bond in top.bonds:         #         a1, a2 = bond         #         out.add_bond(a1, a2, type=bond.type, order=bond.order)         out.create_standard_bonds() #rare manier om bonds te maken, maar werkt         C.top = out          return C In\u00a0[\u00a0]: Copied! <pre>class Fixer:\n\n    def __init__(self, traj):\n        if nx is None:\n            raise ImportError('networkx is required for Fixer but is not installed.')\n\n        segments = {'s1':np.arange(0,41),\n                     's2':np.arange(53,82)}\n        \n        # Figure out which chains are connected \n        G = self.compute_interaction_graph(traj, segments)\n            \n        # Traverse over graph for new chain assignements\n        chain_mapping = self.traverse_from_endpoint(G)\n\n        # Update chain order in topology\n        new_topology, atom_mapping  = self.update_chain_topology(traj, chain_mapping)\n\n        # Update xyz coordinates\n        new_xyz =  traj.xyz[:,atom_mapping]\n\n        # Create new trajectory with corrected order and adjust xyz as well\n        new_traj = md.Trajectory(new_xyz,new_topology)\n        self.new_traj = new_traj\n\n    def get_updated_traj(self):\n        return self.new_traj\n\n    def traverse_from_endpoint(self, G):\n\n        # Find all nodes with degree 1 (endpoints)\n        endpoints = [node for node, degree in G.degree() if degree == 1]\n\n        # Choose the first endpoint as the start node\n        start_node = endpoints[0] if endpoints else None\n        # Initialize a dictionary to store the number of steps to each node\n        # chain_mapping = {node: float('inf') for node in G.nodes()}\n        D = []\n        for node in G.nodes:\n            d = nx.shortest_path_length(G, source=start_node, target=node)\n            D.append(d)\n        chain_mapping = {i:j for i,j in zip(G.nodes, np.argsort(D))}\n        return chain_mapping\n\n    def compute_chain_centers(self, traj, domain):\n        top = traj.top\n        coms = []\n        lens = []\n        ids =   []\n        for c in top.chains:\n            try:\n                selection = top.select(f'chainid {c.index} and resSeq {domain[0]} to {domain[-1]}')\n                com = md.compute_center_of_mass(traj.atom_slice(selection))\n                coms.append(com)\n                lens.append(len(selection))\n                ids.append(c.index)\n            except:\n                pass\n        coms = np.squeeze(np.array(coms))\n        lens = np.array(lens)\n        ids = np.array(ids)\n        return coms, lens, ids\n\n    def compute_interaction_graph(self, traj, segments):\n\n        # Compute COMS of each chain domain and get chain labels\n        s1_centers = self.compute_chain_centers(traj, segments['s1'])\n        s2_centers = self.compute_chain_centers(traj, segments['s2'])\n\n\n        # Initialize graph\n        G = nx.Graph()\n        labels = {}\n        for c in traj.top.chains:\n            G.add_node(c.index,label=c.index)\n            labels[c.index] = c.index\n\n        # Loop over centers\n        for idx,center in enumerate([s1_centers, s2_centers]):\n            coms = center[0]\n            ids = center[2]\n\n            # Computer distance between coms\n            D = np.zeros((len(coms),len(coms)))\n            for i,ci in enumerate(coms):\n                for j,cj in enumerate(coms):\n                    d = np.linalg.norm(ci-cj)\n                    D[i,j] = d\n\n            # Use closest pairs to collect edges\n            edges = []\n            for _,d in enumerate(D):\n                pair = np.sort([ids[_],ids[np.argsort(d)[1]]])\n                edges.append(pair)\n            \n            # Filter pairs for redudancy\n            edges = np.unique(edges,axis=0)\n            for pair in edges:\n                G.add_edge(pair[0],pair[1])\n        return G\n\n    def update_chain_topology(self, traj, chain_mapping):\n\n        # Initialize empty top\n        new_top = md.Topology()\n\n        # Collect current chains\n        chains = list(traj.top.chains)\n        atom_mapping = []\n\n        # Loop over chain mapping \n        for new, current in chain_mapping.items():\n            new_chain = new_top.add_chain() # add empty chain\n            chain = chains[current]\n            for res in chain.residues: # fill chain with resdues\n                new_res = new_top.add_residue(res.name, new_chain, res.resSeq,res.segment_id)\n                for atom in res.atoms: # fill residue with atoms\n                    new_top.add_atom(atom.name, atom.element, new_res, serial=atom.serial)\n                    atom_mapping.append(atom.index) # keep track of new index order \n                    \n        # Return mapping and top\n        return new_top, atom_mapping\n</pre> class Fixer:      def __init__(self, traj):         if nx is None:             raise ImportError('networkx is required for Fixer but is not installed.')          segments = {'s1':np.arange(0,41),                      's2':np.arange(53,82)}                  # Figure out which chains are connected          G = self.compute_interaction_graph(traj, segments)                      # Traverse over graph for new chain assignements         chain_mapping = self.traverse_from_endpoint(G)          # Update chain order in topology         new_topology, atom_mapping  = self.update_chain_topology(traj, chain_mapping)          # Update xyz coordinates         new_xyz =  traj.xyz[:,atom_mapping]          # Create new trajectory with corrected order and adjust xyz as well         new_traj = md.Trajectory(new_xyz,new_topology)         self.new_traj = new_traj      def get_updated_traj(self):         return self.new_traj      def traverse_from_endpoint(self, G):          # Find all nodes with degree 1 (endpoints)         endpoints = [node for node, degree in G.degree() if degree == 1]          # Choose the first endpoint as the start node         start_node = endpoints[0] if endpoints else None         # Initialize a dictionary to store the number of steps to each node         # chain_mapping = {node: float('inf') for node in G.nodes()}         D = []         for node in G.nodes:             d = nx.shortest_path_length(G, source=start_node, target=node)             D.append(d)         chain_mapping = {i:j for i,j in zip(G.nodes, np.argsort(D))}         return chain_mapping      def compute_chain_centers(self, traj, domain):         top = traj.top         coms = []         lens = []         ids =   []         for c in top.chains:             try:                 selection = top.select(f'chainid {c.index} and resSeq {domain[0]} to {domain[-1]}')                 com = md.compute_center_of_mass(traj.atom_slice(selection))                 coms.append(com)                 lens.append(len(selection))                 ids.append(c.index)             except:                 pass         coms = np.squeeze(np.array(coms))         lens = np.array(lens)         ids = np.array(ids)         return coms, lens, ids      def compute_interaction_graph(self, traj, segments):          # Compute COMS of each chain domain and get chain labels         s1_centers = self.compute_chain_centers(traj, segments['s1'])         s2_centers = self.compute_chain_centers(traj, segments['s2'])           # Initialize graph         G = nx.Graph()         labels = {}         for c in traj.top.chains:             G.add_node(c.index,label=c.index)             labels[c.index] = c.index          # Loop over centers         for idx,center in enumerate([s1_centers, s2_centers]):             coms = center[0]             ids = center[2]              # Computer distance between coms             D = np.zeros((len(coms),len(coms)))             for i,ci in enumerate(coms):                 for j,cj in enumerate(coms):                     d = np.linalg.norm(ci-cj)                     D[i,j] = d              # Use closest pairs to collect edges             edges = []             for _,d in enumerate(D):                 pair = np.sort([ids[_],ids[np.argsort(d)[1]]])                 edges.append(pair)                          # Filter pairs for redudancy             edges = np.unique(edges,axis=0)             for pair in edges:                 G.add_edge(pair[0],pair[1])         return G      def update_chain_topology(self, traj, chain_mapping):          # Initialize empty top         new_top = md.Topology()          # Collect current chains         chains = list(traj.top.chains)         atom_mapping = []          # Loop over chain mapping          for new, current in chain_mapping.items():             new_chain = new_top.add_chain() # add empty chain             chain = chains[current]             for res in chain.residues: # fill chain with resdues                 new_res = new_top.add_residue(res.name, new_chain, res.resSeq,res.segment_id)                 for atom in res.atoms: # fill residue with atoms                     new_top.add_atom(atom.name, atom.element, new_res, serial=atom.serial)                     atom_mapping.append(atom.index) # keep track of new index order                               # Return mapping and top         return new_top, atom_mapping In\u00a0[\u00a0]: Copied! <pre>class Assembler:\n\n    def __init__(self, site_map, n_overlap : int = 2):\n        \n        self.traj = None\n        self.chain_id = 0\n        self.site_map = site_map\n        self.n = n_overlap\n        self.n_dimers = 0\n        self.n_dna = 0\n        self.first = True\n        self.s1_pairs = [['s1','h3'],['h3','s2'],['s2','l2'],['l2','dbd']]\n        self.s2_pairs = [['s2','h3'],['h3','s1'],['s2','l2'],['l2','dbd']]\n        self.traj_history = []\n        self.cleaned = False\n\n    @staticmethod\n    def default_segments(n_overlap=2):\n        return {\n            's1': np.arange(0, 41 + n_overlap),\n            'h3': np.arange(41 - n_overlap, 53 + n_overlap),\n            's2': np.arange(53 - n_overlap, 82 + n_overlap),\n            'l2': np.arange(82 - n_overlap, 95 + n_overlap),\n            'dbd': np.arange(95 - n_overlap, 137),\n        }\n\n    @staticmethod\n    def _pick_site_frame(site_traj, site_name, source_name):\n        if site_name in {'s1', 's2', 's2_end'}:\n            return site_traj[0]\n        if source_name == 's1s1':\n            return site_traj[0]\n        if source_name == 's2s2':\n            return site_traj[-1]\n        raise ValueError(f'Unknown source name {source_name} for site {site_name}.')\n\n    @staticmethod\n    def load_minimal_site_map(minimal_dir, segments=None, n_overlap=2):\n        \"\"\"\n        Load minimal source PDBs and build start/extend segment maps on demand.\n\n        Expected files in ``minimal_dir``:\n        - ``s1s1_start.pdb``\n        - ``s2s2_start.pdb``\n        - ``s1s1_extend.pdb``\n        - ``s2s2_extend.pdb``\n        - ``complex_frame_&lt;idx&gt;.pdb``\n        \"\"\"\n        base = Path(minimal_dir)\n        if segments is None:\n            segments = Assembler.default_segments(n_overlap=n_overlap)\n\n        required_files = [\n            's1s1_start.pdb',\n            's2s2_start.pdb',\n            's1s1_extend.pdb',\n            's2s2_extend.pdb',\n        ]\n        missing = [filename for filename in required_files if not (base / filename).exists()]\n        if missing:\n            raise FileNotFoundError(f'Missing required minimal source files: {missing}')\n\n        manifest = {}\n        manifest_path = base / 'manifest.json'\n        if manifest_path.exists():\n            import json\n\n            with open(manifest_path, 'r', encoding='utf-8') as handle:\n                manifest = json.load(handle)\n\n        start_site_sources = manifest.get('start_site_sources', {'s2': 's2s2', 'h3': 's1s1'})\n        extend_site_sources = manifest.get(\n            'extend_site_sources',\n            {'s1': 's1s1', 'h3': 's1s1', 's2': 's2s2', 'l2': 's1s1', 'dbd': 's1s1'},\n        )\n\n        s1s1_start = md.load(str(base / 's1s1_start.pdb'))\n        s2s2_start = md.load(str(base / 's2s2_start.pdb'))\n        s1s1_extend = md.load(str(base / 's1s1_extend.pdb'))\n        s2s2_extend = md.load(str(base / 's2s2_extend.pdb'))\n\n        start_mapper = SiteMapper(s1s1_start, s2s2_start, segments=segments, k=1)\n        extend_mapper = SiteMapper(s1s1_extend, s2s2_extend, segments=segments, k=1)\n        start_site_map = start_mapper.get_site_map()\n        extend_site_map = extend_mapper.get_site_map()\n\n        minimal_start = {}\n        for site_name, source_name in start_site_sources.items():\n            if site_name not in start_site_map:\n                raise KeyError(f'Start site {site_name} missing from generated site map.')\n            minimal_start[site_name] = Assembler._pick_site_frame(start_site_map[site_name], site_name, source_name)\n\n        minimal_extend = {}\n        for site_name, source_name in extend_site_sources.items():\n            if site_name not in extend_site_map:\n                raise KeyError(f'Extend site {site_name} missing from generated site map.')\n            minimal_extend[site_name] = Assembler._pick_site_frame(extend_site_map[site_name], site_name, source_name)\n\n        site_map = {'minimal_start': minimal_start, 'minimal_extend': minimal_extend}\n\n        dna_frame_idx = manifest.get('dna_frame_index', 1)\n        dna_candidate = base / f'complex_frame_{dna_frame_idx}.pdb'\n        if not dna_candidate.exists():\n            candidates = sorted(base.glob('complex_frame_*.pdb'))\n            if candidates:\n                dna_candidate = candidates[0]\n\n        if dna_candidate.exists():\n            site_map['complex'] = md.load(str(dna_candidate))\n\n        return site_map\n\n    @staticmethod\n    def load_fixed_minimal_site_map(minimal_dir):\n        return Assembler.load_minimal_site_map(minimal_dir=minimal_dir)\n\n    def get_traj(self):\n        if self.cleaned:\n            return self.traj\n        else:\n            self.clean_traj()\n            return self.traj\n        # if self.n_dna != 0:\n        #     subtraj_dna = self.traj.atom_slice(self.traj.top.select('resname DG DC DA DT'))\n        #     subtraj_protein  = self.traj.atom_slice(self.traj.top.select('protein'))\n        #     traj = subtraj_protein.atom_slice(subtraj_protein.top.select(f'chainid 0 to {(self.n_dimers*2)-1}'))\n        #     return traj.stack(subtraj_dna)\n        # else:\n        #     return self.traj.atom_slice(self.traj.top.select(f'chainid 0 to {(self.n_dimers*2)-1}'))\n\n    def add_dimer(self, verbose: bool = False, segment: str = 'random'):\n        \"\"\"\n        Adds a dimer to the trajectory by iterating over s2_pairs first and then s1_pairs, with specific increments to chain_id.\n        \"\"\"\n        self.n_dimers += 1\n        # print('Start processing s2 pairs')\n        # print(self.s2_pairs)\n        self.traj = self.process_pairs(self.s2_pairs, self.chain_id, verbose, segment)\n        # print('Start processing s1 pairs')\n        # print(self.s1_pairs)\n        self.traj = self.process_pairs(self.s1_pairs, self.chain_id + 2,verbose, segment)\n        self.chain_id += 2\n        return self.traj\n\n    def process_pairs(self, pairs, chain_id, verbose, segment):\n        \"\"\"\n        Processes a sequence of pairs, adding each to the trajectory.\n        \"\"\"        \n        for idx, pair in enumerate(pairs):\n            leading_chain = chain_id if idx == 0 else 0\n            self.traj = self.add_pair(pair, leading_chain=leading_chain, verbose=verbose, segment=segment)\n            \n        return self.traj\n\n    # Get segments based on 'fixed' or 'random' segment criteria\n    def get_segments(self, site_a, site_b, segment):\n        if segment == 'minimal' and 'minimal_start' in self.site_map and 'minimal_extend' in self.site_map:\n            if not self.traj:\n                start_map = self.site_map['minimal_start']\n                fallback_map = self.site_map['minimal_extend']\n                A = start_map.get(site_a, fallback_map.get(site_a))\n                B = start_map.get(site_b, fallback_map.get(site_b))\n                if A is None or B is None:\n                    raise KeyError(f'Missing minimal-start entries for {site_a} and/or {site_b}.')\n            else:\n                extension_map = self.site_map['minimal_extend']\n                if site_b not in extension_map:\n                    raise KeyError(f'Missing minimal-extension entry for site {site_b}.')\n                A = self.traj\n                B = extension_map[site_b]\n            return A, B\n\n        if not self.traj:\n            if segment == 'fixed':\n                x, y = 40, 90\n            elif segment == 'random':\n                k = len(self.site_map[site_a])\n                l = len(self.site_map[site_b])\n                x, y = np.random.randint(0, k), np.random.randint(0, l)\n            A = self.site_map[site_a][x]\n            B = self.site_map[site_b][y]\n        else:\n            if segment == 'fixed':\n                z = 20\n            elif segment == 'random':\n                k = len(self.site_map[site_b])\n                z = np.random.randint(0, k)\n            A = self.traj\n            B = self.site_map[site_b][z]\n        return A, B\n\n    # Check for dimerization and print if verbose\n    def check_dimerization(self, site_a, site_b):\n        dimer_a = Helper.check_if_dimerization(site_a)\n        dimer_b = Helper.check_if_dimerization(site_b)\n        return dimer_a, dimer_b\n\n    # Determine growth direction based on terminus\n    def determine_terminus_direction(self, site_a, site_b):\n        terminus_a, terminus_b = Helper.get_termini(site_a, site_b)\n        reverse = terminus_a == 'C_terminus'\n        return reverse, terminus_a, terminus_b\n\n    # Manage overlaps and perform superimposition\n    def manage_overlaps(self, A, B, leading_chain, adding_chain, terminus_a, terminus_b):\n       \n        overlap_A = Helper.get_overlap_indices(A.top, self.n, chain=leading_chain, terminus=terminus_a)\n        overlap_B = Helper.get_overlap_indices(B.top, self.n, chain=adding_chain, terminus=terminus_b)\n        check = Helper.check_overlaps(overlap_A, overlap_B)\n\n        if check:\n            return check\n        \n        superimposer = Superimposer(A, B, overlap_A, overlap_B)\n        new_B = superimposer.fit_B_on_A()\n\n        # Instead of atom slice I should use pop/delete to remove the atoms?\n        new_A = Helper.remove_overlap(A, overlap_A)\n        return new_A, new_B\n\n    # Manipulate topologies: split, merge, and stack components\n    def manipulate_topology(self, A, B, leading_chain, adding_chain, reverse, keep_resSeq, dimer_b):\n        A_active, A_passive = Helper.split_chain_topology(A, leading_chain)\n        if dimer_b:\n            B_active, B_passive = Helper.split_chain_topology(B, adding_chain)\n            temp = Helper.merge_chain_topology(B_active if reverse else A_active, A_active if reverse else B_active, keep_resSeq)\n            C_temp = temp.stack(A_passive, keep_resSeq)\n            C = C_temp.stack(B_passive, keep_resSeq)\n        else:\n            temp = Helper.merge_chain_topology(B if reverse else A_active, A_active if reverse else B, keep_resSeq)\n            C = temp.stack(A_passive, keep_resSeq)\n        return C\n\n    # Refactored method to add a pair of sites\n    def add_pair(self, pair, leading_chain=0, adding_chain=0, verbose=False, reverse=False, segment='fixed'):\n        if verbose:\n            #print(f'Adding pair: {pair} of dimer {self.n_dimers}')\n            pass\n        site_a, site_b = pair\n\n        # Get segments based on 'fixed' or 'random' segment criteria\n        A, B = self.get_segments(site_a, site_b, segment)\n\n        # Check for dimerization (aka if site is s1 or s2)\n        dimer_a, dimer_b = self.check_dimerization(site_a, site_b)\n\n        # Determine growth direction based on terminus\n        reverse, terminus_a, terminus_b = self.determine_terminus_direction(site_a, site_b)\n\n        # Manage overlaps and perform superimposition\n        new_A, new_B = self.manage_overlaps(A, B, leading_chain, adding_chain, terminus_a, terminus_b)\n\n        # Manipulate topologies: split, merge, and stack components, and return new trajectory\n        C = self.manipulate_topology(A=new_A, B=new_B, leading_chain=leading_chain, adding_chain=adding_chain, reverse=reverse, keep_resSeq=True, dimer_b=dimer_b)\n        self.traj_history.append(C)\n        return C\n\n    def clean_traj(self):\n        self.raw_traj = self.traj\n        fixer = Fixer(self.traj)\n        self.traj = fixer.get_updated_traj()\n        # Remove leftover s2 segment domains at the ends of the filament\n        self.traj = self.traj.atom_slice(self.traj.top.select(f'chainid 1 to {(self.n_dimers*2)}'))\n        self.cleaned = True\n\n    def add_dna(self, chainid=0, frame_idx=1):\n        \n        if not self.cleaned:\n            self.clean_traj()\n        \n        # Select frame of DNA - DBD complex\n        if 'complex' not in self.site_map:\n            raise KeyError('No DNA complex found in site_map. Provide site_map[\"complex\"] before calling add_dna.')\n        complex_traj = self.site_map['complex']\n        dna_complex = complex_traj[0] if len(complex_traj) == 1 else complex_traj[frame_idx]\n\n        # Get selection of dbd residues for fit of only backbone\n        indices_dbd_complex = dna_complex.top.select(f'resSeq 95 to 137 and backbone') # SALMONELA\n        indices_dbd_traj = self.traj.top.select(f'(chainid {chainid} and resSeq 95 to 137) and backbone') # Ecoli\n\n        # Fit the dbd with DNA to the loction of the dbd in the filament at chainid\n        imposer = Superimposer(self.traj,dna_complex,indices_dbd_traj,indices_dbd_complex)\n        new_dbd_complex =  imposer.fit_B_on_A()\n\n        # Remove indices of DBD from complex\n        dna = new_dbd_complex.atom_slice(new_dbd_complex.top.select('not protein'))\n        # Add DNA to the filament traj\n        self.traj = self.traj.stack(dna)\n        self.n_dna += 1\n</pre> class Assembler:      def __init__(self, site_map, n_overlap : int = 2):                  self.traj = None         self.chain_id = 0         self.site_map = site_map         self.n = n_overlap         self.n_dimers = 0         self.n_dna = 0         self.first = True         self.s1_pairs = [['s1','h3'],['h3','s2'],['s2','l2'],['l2','dbd']]         self.s2_pairs = [['s2','h3'],['h3','s1'],['s2','l2'],['l2','dbd']]         self.traj_history = []         self.cleaned = False      @staticmethod     def default_segments(n_overlap=2):         return {             's1': np.arange(0, 41 + n_overlap),             'h3': np.arange(41 - n_overlap, 53 + n_overlap),             's2': np.arange(53 - n_overlap, 82 + n_overlap),             'l2': np.arange(82 - n_overlap, 95 + n_overlap),             'dbd': np.arange(95 - n_overlap, 137),         }      @staticmethod     def _pick_site_frame(site_traj, site_name, source_name):         if site_name in {'s1', 's2', 's2_end'}:             return site_traj[0]         if source_name == 's1s1':             return site_traj[0]         if source_name == 's2s2':             return site_traj[-1]         raise ValueError(f'Unknown source name {source_name} for site {site_name}.')      @staticmethod     def load_minimal_site_map(minimal_dir, segments=None, n_overlap=2):         \"\"\"         Load minimal source PDBs and build start/extend segment maps on demand.          Expected files in ``minimal_dir``:         - ``s1s1_start.pdb``         - ``s2s2_start.pdb``         - ``s1s1_extend.pdb``         - ``s2s2_extend.pdb``         - ``complex_frame_.pdb``         \"\"\"         base = Path(minimal_dir)         if segments is None:             segments = Assembler.default_segments(n_overlap=n_overlap)          required_files = [             's1s1_start.pdb',             's2s2_start.pdb',             's1s1_extend.pdb',             's2s2_extend.pdb',         ]         missing = [filename for filename in required_files if not (base / filename).exists()]         if missing:             raise FileNotFoundError(f'Missing required minimal source files: {missing}')          manifest = {}         manifest_path = base / 'manifest.json'         if manifest_path.exists():             import json              with open(manifest_path, 'r', encoding='utf-8') as handle:                 manifest = json.load(handle)          start_site_sources = manifest.get('start_site_sources', {'s2': 's2s2', 'h3': 's1s1'})         extend_site_sources = manifest.get(             'extend_site_sources',             {'s1': 's1s1', 'h3': 's1s1', 's2': 's2s2', 'l2': 's1s1', 'dbd': 's1s1'},         )          s1s1_start = md.load(str(base / 's1s1_start.pdb'))         s2s2_start = md.load(str(base / 's2s2_start.pdb'))         s1s1_extend = md.load(str(base / 's1s1_extend.pdb'))         s2s2_extend = md.load(str(base / 's2s2_extend.pdb'))          start_mapper = SiteMapper(s1s1_start, s2s2_start, segments=segments, k=1)         extend_mapper = SiteMapper(s1s1_extend, s2s2_extend, segments=segments, k=1)         start_site_map = start_mapper.get_site_map()         extend_site_map = extend_mapper.get_site_map()          minimal_start = {}         for site_name, source_name in start_site_sources.items():             if site_name not in start_site_map:                 raise KeyError(f'Start site {site_name} missing from generated site map.')             minimal_start[site_name] = Assembler._pick_site_frame(start_site_map[site_name], site_name, source_name)          minimal_extend = {}         for site_name, source_name in extend_site_sources.items():             if site_name not in extend_site_map:                 raise KeyError(f'Extend site {site_name} missing from generated site map.')             minimal_extend[site_name] = Assembler._pick_site_frame(extend_site_map[site_name], site_name, source_name)          site_map = {'minimal_start': minimal_start, 'minimal_extend': minimal_extend}          dna_frame_idx = manifest.get('dna_frame_index', 1)         dna_candidate = base / f'complex_frame_{dna_frame_idx}.pdb'         if not dna_candidate.exists():             candidates = sorted(base.glob('complex_frame_*.pdb'))             if candidates:                 dna_candidate = candidates[0]          if dna_candidate.exists():             site_map['complex'] = md.load(str(dna_candidate))          return site_map      @staticmethod     def load_fixed_minimal_site_map(minimal_dir):         return Assembler.load_minimal_site_map(minimal_dir=minimal_dir)      def get_traj(self):         if self.cleaned:             return self.traj         else:             self.clean_traj()             return self.traj         # if self.n_dna != 0:         #     subtraj_dna = self.traj.atom_slice(self.traj.top.select('resname DG DC DA DT'))         #     subtraj_protein  = self.traj.atom_slice(self.traj.top.select('protein'))         #     traj = subtraj_protein.atom_slice(subtraj_protein.top.select(f'chainid 0 to {(self.n_dimers*2)-1}'))         #     return traj.stack(subtraj_dna)         # else:         #     return self.traj.atom_slice(self.traj.top.select(f'chainid 0 to {(self.n_dimers*2)-1}'))      def add_dimer(self, verbose: bool = False, segment: str = 'random'):         \"\"\"         Adds a dimer to the trajectory by iterating over s2_pairs first and then s1_pairs, with specific increments to chain_id.         \"\"\"         self.n_dimers += 1         # print('Start processing s2 pairs')         # print(self.s2_pairs)         self.traj = self.process_pairs(self.s2_pairs, self.chain_id, verbose, segment)         # print('Start processing s1 pairs')         # print(self.s1_pairs)         self.traj = self.process_pairs(self.s1_pairs, self.chain_id + 2,verbose, segment)         self.chain_id += 2         return self.traj      def process_pairs(self, pairs, chain_id, verbose, segment):         \"\"\"         Processes a sequence of pairs, adding each to the trajectory.         \"\"\"                 for idx, pair in enumerate(pairs):             leading_chain = chain_id if idx == 0 else 0             self.traj = self.add_pair(pair, leading_chain=leading_chain, verbose=verbose, segment=segment)                      return self.traj      # Get segments based on 'fixed' or 'random' segment criteria     def get_segments(self, site_a, site_b, segment):         if segment == 'minimal' and 'minimal_start' in self.site_map and 'minimal_extend' in self.site_map:             if not self.traj:                 start_map = self.site_map['minimal_start']                 fallback_map = self.site_map['minimal_extend']                 A = start_map.get(site_a, fallback_map.get(site_a))                 B = start_map.get(site_b, fallback_map.get(site_b))                 if A is None or B is None:                     raise KeyError(f'Missing minimal-start entries for {site_a} and/or {site_b}.')             else:                 extension_map = self.site_map['minimal_extend']                 if site_b not in extension_map:                     raise KeyError(f'Missing minimal-extension entry for site {site_b}.')                 A = self.traj                 B = extension_map[site_b]             return A, B          if not self.traj:             if segment == 'fixed':                 x, y = 40, 90             elif segment == 'random':                 k = len(self.site_map[site_a])                 l = len(self.site_map[site_b])                 x, y = np.random.randint(0, k), np.random.randint(0, l)             A = self.site_map[site_a][x]             B = self.site_map[site_b][y]         else:             if segment == 'fixed':                 z = 20             elif segment == 'random':                 k = len(self.site_map[site_b])                 z = np.random.randint(0, k)             A = self.traj             B = self.site_map[site_b][z]         return A, B      # Check for dimerization and print if verbose     def check_dimerization(self, site_a, site_b):         dimer_a = Helper.check_if_dimerization(site_a)         dimer_b = Helper.check_if_dimerization(site_b)         return dimer_a, dimer_b      # Determine growth direction based on terminus     def determine_terminus_direction(self, site_a, site_b):         terminus_a, terminus_b = Helper.get_termini(site_a, site_b)         reverse = terminus_a == 'C_terminus'         return reverse, terminus_a, terminus_b      # Manage overlaps and perform superimposition     def manage_overlaps(self, A, B, leading_chain, adding_chain, terminus_a, terminus_b):                 overlap_A = Helper.get_overlap_indices(A.top, self.n, chain=leading_chain, terminus=terminus_a)         overlap_B = Helper.get_overlap_indices(B.top, self.n, chain=adding_chain, terminus=terminus_b)         check = Helper.check_overlaps(overlap_A, overlap_B)          if check:             return check                  superimposer = Superimposer(A, B, overlap_A, overlap_B)         new_B = superimposer.fit_B_on_A()          # Instead of atom slice I should use pop/delete to remove the atoms?         new_A = Helper.remove_overlap(A, overlap_A)         return new_A, new_B      # Manipulate topologies: split, merge, and stack components     def manipulate_topology(self, A, B, leading_chain, adding_chain, reverse, keep_resSeq, dimer_b):         A_active, A_passive = Helper.split_chain_topology(A, leading_chain)         if dimer_b:             B_active, B_passive = Helper.split_chain_topology(B, adding_chain)             temp = Helper.merge_chain_topology(B_active if reverse else A_active, A_active if reverse else B_active, keep_resSeq)             C_temp = temp.stack(A_passive, keep_resSeq)             C = C_temp.stack(B_passive, keep_resSeq)         else:             temp = Helper.merge_chain_topology(B if reverse else A_active, A_active if reverse else B, keep_resSeq)             C = temp.stack(A_passive, keep_resSeq)         return C      # Refactored method to add a pair of sites     def add_pair(self, pair, leading_chain=0, adding_chain=0, verbose=False, reverse=False, segment='fixed'):         if verbose:             #print(f'Adding pair: {pair} of dimer {self.n_dimers}')             pass         site_a, site_b = pair          # Get segments based on 'fixed' or 'random' segment criteria         A, B = self.get_segments(site_a, site_b, segment)          # Check for dimerization (aka if site is s1 or s2)         dimer_a, dimer_b = self.check_dimerization(site_a, site_b)          # Determine growth direction based on terminus         reverse, terminus_a, terminus_b = self.determine_terminus_direction(site_a, site_b)          # Manage overlaps and perform superimposition         new_A, new_B = self.manage_overlaps(A, B, leading_chain, adding_chain, terminus_a, terminus_b)          # Manipulate topologies: split, merge, and stack components, and return new trajectory         C = self.manipulate_topology(A=new_A, B=new_B, leading_chain=leading_chain, adding_chain=adding_chain, reverse=reverse, keep_resSeq=True, dimer_b=dimer_b)         self.traj_history.append(C)         return C      def clean_traj(self):         self.raw_traj = self.traj         fixer = Fixer(self.traj)         self.traj = fixer.get_updated_traj()         # Remove leftover s2 segment domains at the ends of the filament         self.traj = self.traj.atom_slice(self.traj.top.select(f'chainid 1 to {(self.n_dimers*2)}'))         self.cleaned = True      def add_dna(self, chainid=0, frame_idx=1):                  if not self.cleaned:             self.clean_traj()                  # Select frame of DNA - DBD complex         if 'complex' not in self.site_map:             raise KeyError('No DNA complex found in site_map. Provide site_map[\"complex\"] before calling add_dna.')         complex_traj = self.site_map['complex']         dna_complex = complex_traj[0] if len(complex_traj) == 1 else complex_traj[frame_idx]          # Get selection of dbd residues for fit of only backbone         indices_dbd_complex = dna_complex.top.select(f'resSeq 95 to 137 and backbone') # SALMONELA         indices_dbd_traj = self.traj.top.select(f'(chainid {chainid} and resSeq 95 to 137) and backbone') # Ecoli          # Fit the dbd with DNA to the loction of the dbd in the filament at chainid         imposer = Superimposer(self.traj,dna_complex,indices_dbd_traj,indices_dbd_complex)         new_dbd_complex =  imposer.fit_B_on_A()          # Remove indices of DBD from complex         dna = new_dbd_complex.atom_slice(new_dbd_complex.top.select('not protein'))         # Add DNA to the filament traj         self.traj = self.traj.stack(dna)         self.n_dna += 1"},{"location":"notebooks/scripts/extract_minimal_filament_dataset/","title":"Extract minimal filament dataset","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>import argparse\nimport json\nfrom pathlib import Path\n</pre> import argparse import json from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mdtraj as md\nimport numpy as np\n</pre> import mdtraj as md import numpy as np In\u00a0[\u00a0]: Copied! <pre>def _list_numeric_dry_ids(folder: Path):\n    ids = []\n    for xtc_path in folder.glob('dry_*.xtc'):\n        suffix = xtc_path.stem.replace('dry_', '')\n        if suffix.isdigit() and (folder / f'dry_{suffix}.pdb').exists():\n            ids.append(int(suffix))\n    return sorted(ids)\n</pre> def _list_numeric_dry_ids(folder: Path):     ids = []     for xtc_path in folder.glob('dry_*.xtc'):         suffix = xtc_path.stem.replace('dry_', '')         if suffix.isdigit() and (folder / f'dry_{suffix}.pdb').exists():             ids.append(int(suffix))     return sorted(ids) In\u00a0[\u00a0]: Copied! <pre>def _load_joined_traj(folder: Path, ids):\n    trajectories = []\n    for idx in ids:\n        xtc = folder / f'dry_{idx}.xtc'\n        pdb = folder / f'dry_{idx}.pdb'\n        trajectories.append(md.load(str(xtc), top=str(pdb)).remove_solvent())\n    return md.join(trajectories)\n</pre> def _load_joined_traj(folder: Path, ids):     trajectories = []     for idx in ids:         xtc = folder / f'dry_{idx}.xtc'         pdb = folder / f'dry_{idx}.pdb'         trajectories.append(md.load(str(xtc), top=str(pdb)).remove_solvent())     return md.join(trajectories) In\u00a0[\u00a0]: Copied! <pre>def _save_single_pdb(traj, file_path: Path):\n    frame = traj[0] if len(traj) &gt; 1 else traj\n    frame.save_pdb(str(file_path))\n</pre> def _save_single_pdb(traj, file_path: Path):     frame = traj[0] if len(traj) &gt; 1 else traj     frame.save_pdb(str(file_path)) In\u00a0[\u00a0]: Copied! <pre>def _resolve_source_for_site(site_name, frame_idx, n_s1):\n    if site_name == 's1':\n        return 's1s1', frame_idx\n    if site_name in {'s2', 's2_end'}:\n        return 's2s2', frame_idx\n    if frame_idx &lt; n_s1:\n        return 's1s1', frame_idx\n    return 's2s2', frame_idx - n_s1\n</pre> def _resolve_source_for_site(site_name, frame_idx, n_s1):     if site_name == 's1':         return 's1s1', frame_idx     if site_name in {'s2', 's2_end'}:         return 's2s2', frame_idx     if frame_idx &lt; n_s1:         return 's1s1', frame_idx     return 's2s2', frame_idx - n_s1 In\u00a0[\u00a0]: Copied! <pre>def _accumulate_source_frames(requirements, n_s1):\n    site_sources = {}\n    source_frames = {}\n    for site_name, frame_idx in requirements.items():\n        source_name, source_frame = _resolve_source_for_site(site_name, frame_idx, n_s1)\n        site_sources[site_name] = source_name\n        if source_name in source_frames and source_frames[source_name] != source_frame:\n            raise ValueError(\n                f'Conflicting source frame requirements for {source_name}: '\n                f'{source_frames[source_name]} vs {source_frame}.'\n            )\n        source_frames[source_name] = source_frame\n    return site_sources, source_frames\n</pre> def _accumulate_source_frames(requirements, n_s1):     site_sources = {}     source_frames = {}     for site_name, frame_idx in requirements.items():         source_name, source_frame = _resolve_source_for_site(site_name, frame_idx, n_s1)         site_sources[site_name] = source_name         if source_name in source_frames and source_frames[source_name] != source_frame:             raise ValueError(                 f'Conflicting source frame requirements for {source_name}: '                 f'{source_frames[source_name]} vs {source_frame}.'             )         source_frames[source_name] = source_frame     return site_sources, source_frames In\u00a0[\u00a0]: Copied! <pre>def main():\n    parser = argparse.ArgumentParser(\n        description='Extract minimal fixed-mode filament dataset as single-frame PDB files.'\n    )\n    parser.add_argument('--data-root', type=Path, default=Path('examples/data'))\n    parser.add_argument('--output-dir', type=Path, default=Path('examples/data/filament_minimal'))\n    parser.add_argument('--stride', type=int, default=100, help='Downsampling stride used by SiteMapper.')\n    parser.add_argument(\n        '--trajectory-ids',\n        type=int,\n        nargs='*',\n        default=None,\n        help='Optional numeric dry_* trajectory IDs to include (default: all numeric dry_*.xtc with matching pdb).',\n    )\n    parser.add_argument('--dna-frame-idx', type=int, default=1, help='Frame index used by Assembler.add_dna default.')\n    args = parser.parse_args()\n\n    data_root = args.data_root\n    s1s1_dir = data_root / '0_s1s1'\n    s2s2_dir = data_root / '1_s2s2'\n    fi_dir = data_root / 'FI'\n    out_dir = args.output_dir\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    if args.trajectory_ids is None or len(args.trajectory_ids) == 0:\n        ids_s1 = _list_numeric_dry_ids(s1s1_dir)\n        ids_s2 = _list_numeric_dry_ids(s2s2_dir)\n        ids_fi = _list_numeric_dry_ids(fi_dir)\n        common_ids = sorted(set(ids_s1).intersection(ids_s2).intersection(ids_fi))\n        if not common_ids:\n            raise ValueError('No common numeric dry_* trajectories found across 0_s1s1, 1_s2s2, and FI.')\n        ids = common_ids\n    else:\n        ids = sorted(set(args.trajectory_ids))\n\n    print(f'Using trajectory IDs: {ids}')\n    print('Loading source trajectories...')\n    s1s1 = _load_joined_traj(s1s1_dir, ids)\n    s2s2 = _load_joined_traj(s2s2_dir, ids)\n    dna_complex = _load_joined_traj(fi_dir, ids)\n\n    segments_overlap = 2\n    segments = {\n        's1': np.arange(0, 41 + segments_overlap),\n        'h3': np.arange(41 - segments_overlap, 53 + segments_overlap),\n        's2': np.arange(53 - segments_overlap, 82 + segments_overlap),\n        'l2': np.arange(82 - segments_overlap, 95 + segments_overlap),\n        'dbd': np.arange(95 - segments_overlap, 137),\n    }\n\n    from sys import path as sys_path\n\n    sys_path.append(str(Path(__file__).resolve().parents[1] / 'modules'))\n    from filament import SiteMapper\n\n    mapper = SiteMapper(s1s1, s2s2, segments=segments, k=args.stride)\n    site_map = mapper.get_site_map()\n\n    fixed_start_requirements = {'s2': 40, 'h3': 90}\n    fixed_extend_requirements = {'s1': 20, 'h3': 20, 's2': 20, 'l2': 20, 'dbd': 20}\n\n    n_s1 = len(site_map['s1'])\n    start_site_sources, start_source_frames = _accumulate_source_frames(fixed_start_requirements, n_s1=n_s1)\n    extend_site_sources, extend_source_frames = _accumulate_source_frames(fixed_extend_requirements, n_s1=n_s1)\n\n    if 's1s1' not in start_source_frames:\n        start_source_frames['s1s1'] = extend_source_frames.get('s1s1', 0)\n    if 's2s2' not in start_source_frames:\n        start_source_frames['s2s2'] = extend_source_frames.get('s2s2', 0)\n    if 's1s1' not in extend_source_frames:\n        extend_source_frames['s1s1'] = start_source_frames.get('s1s1', 0)\n    if 's2s2' not in extend_source_frames:\n        extend_source_frames['s2s2'] = start_source_frames.get('s2s2', 0)\n\n    print('Extracting minimal source frames (s1s1/s2s2/dna_complex)...')\n    _save_single_pdb(mapper.s1s1[start_source_frames['s1s1']], out_dir / 's1s1_start.pdb')\n    _save_single_pdb(mapper.s2s2[start_source_frames['s2s2']], out_dir / 's2s2_start.pdb')\n    _save_single_pdb(mapper.s1s1[extend_source_frames['s1s1']], out_dir / 's1s1_extend.pdb')\n    _save_single_pdb(mapper.s2s2[extend_source_frames['s2s2']], out_dir / 's2s2_extend.pdb')\n\n    if args.dna_frame_idx &gt;= len(dna_complex):\n        raise IndexError(\n            f'Requested DNA frame {args.dna_frame_idx}, but only {len(dna_complex)} frames available in joined FI data.'\n        )\n    _save_single_pdb(dna_complex[args.dna_frame_idx], out_dir / f'complex_frame_{args.dna_frame_idx}.pdb')\n\n    manifest = {\n        'data_root': str(data_root),\n        'trajectory_ids': ids,\n        'stride': args.stride,\n        'segments_overlap': segments_overlap,\n        'fixed_start_requirements': fixed_start_requirements,\n        'fixed_extend_requirements': fixed_extend_requirements,\n        'start_site_sources': start_site_sources,\n        'extend_site_sources': extend_site_sources,\n        'start_source_frames': start_source_frames,\n        'extend_source_frames': extend_source_frames,\n        'dna_frame_index': args.dna_frame_idx,\n    }\n\n    with open(out_dir / 'manifest.json', 'w', encoding='utf-8') as handle:\n        json.dump(manifest, handle, indent=2)\n\n    print(f'Minimal dataset written to: {out_dir}')\n    print('Use Assembler.load_minimal_site_map(...) and segment=\"minimal\" to use this dataset.')\n</pre> def main():     parser = argparse.ArgumentParser(         description='Extract minimal fixed-mode filament dataset as single-frame PDB files.'     )     parser.add_argument('--data-root', type=Path, default=Path('examples/data'))     parser.add_argument('--output-dir', type=Path, default=Path('examples/data/filament_minimal'))     parser.add_argument('--stride', type=int, default=100, help='Downsampling stride used by SiteMapper.')     parser.add_argument(         '--trajectory-ids',         type=int,         nargs='*',         default=None,         help='Optional numeric dry_* trajectory IDs to include (default: all numeric dry_*.xtc with matching pdb).',     )     parser.add_argument('--dna-frame-idx', type=int, default=1, help='Frame index used by Assembler.add_dna default.')     args = parser.parse_args()      data_root = args.data_root     s1s1_dir = data_root / '0_s1s1'     s2s2_dir = data_root / '1_s2s2'     fi_dir = data_root / 'FI'     out_dir = args.output_dir     out_dir.mkdir(parents=True, exist_ok=True)      if args.trajectory_ids is None or len(args.trajectory_ids) == 0:         ids_s1 = _list_numeric_dry_ids(s1s1_dir)         ids_s2 = _list_numeric_dry_ids(s2s2_dir)         ids_fi = _list_numeric_dry_ids(fi_dir)         common_ids = sorted(set(ids_s1).intersection(ids_s2).intersection(ids_fi))         if not common_ids:             raise ValueError('No common numeric dry_* trajectories found across 0_s1s1, 1_s2s2, and FI.')         ids = common_ids     else:         ids = sorted(set(args.trajectory_ids))      print(f'Using trajectory IDs: {ids}')     print('Loading source trajectories...')     s1s1 = _load_joined_traj(s1s1_dir, ids)     s2s2 = _load_joined_traj(s2s2_dir, ids)     dna_complex = _load_joined_traj(fi_dir, ids)      segments_overlap = 2     segments = {         's1': np.arange(0, 41 + segments_overlap),         'h3': np.arange(41 - segments_overlap, 53 + segments_overlap),         's2': np.arange(53 - segments_overlap, 82 + segments_overlap),         'l2': np.arange(82 - segments_overlap, 95 + segments_overlap),         'dbd': np.arange(95 - segments_overlap, 137),     }      from sys import path as sys_path      sys_path.append(str(Path(__file__).resolve().parents[1] / 'modules'))     from filament import SiteMapper      mapper = SiteMapper(s1s1, s2s2, segments=segments, k=args.stride)     site_map = mapper.get_site_map()      fixed_start_requirements = {'s2': 40, 'h3': 90}     fixed_extend_requirements = {'s1': 20, 'h3': 20, 's2': 20, 'l2': 20, 'dbd': 20}      n_s1 = len(site_map['s1'])     start_site_sources, start_source_frames = _accumulate_source_frames(fixed_start_requirements, n_s1=n_s1)     extend_site_sources, extend_source_frames = _accumulate_source_frames(fixed_extend_requirements, n_s1=n_s1)      if 's1s1' not in start_source_frames:         start_source_frames['s1s1'] = extend_source_frames.get('s1s1', 0)     if 's2s2' not in start_source_frames:         start_source_frames['s2s2'] = extend_source_frames.get('s2s2', 0)     if 's1s1' not in extend_source_frames:         extend_source_frames['s1s1'] = start_source_frames.get('s1s1', 0)     if 's2s2' not in extend_source_frames:         extend_source_frames['s2s2'] = start_source_frames.get('s2s2', 0)      print('Extracting minimal source frames (s1s1/s2s2/dna_complex)...')     _save_single_pdb(mapper.s1s1[start_source_frames['s1s1']], out_dir / 's1s1_start.pdb')     _save_single_pdb(mapper.s2s2[start_source_frames['s2s2']], out_dir / 's2s2_start.pdb')     _save_single_pdb(mapper.s1s1[extend_source_frames['s1s1']], out_dir / 's1s1_extend.pdb')     _save_single_pdb(mapper.s2s2[extend_source_frames['s2s2']], out_dir / 's2s2_extend.pdb')      if args.dna_frame_idx &gt;= len(dna_complex):         raise IndexError(             f'Requested DNA frame {args.dna_frame_idx}, but only {len(dna_complex)} frames available in joined FI data.'         )     _save_single_pdb(dna_complex[args.dna_frame_idx], out_dir / f'complex_frame_{args.dna_frame_idx}.pdb')      manifest = {         'data_root': str(data_root),         'trajectory_ids': ids,         'stride': args.stride,         'segments_overlap': segments_overlap,         'fixed_start_requirements': fixed_start_requirements,         'fixed_extend_requirements': fixed_extend_requirements,         'start_site_sources': start_site_sources,         'extend_site_sources': extend_site_sources,         'start_source_frames': start_source_frames,         'extend_source_frames': extend_source_frames,         'dna_frame_index': args.dna_frame_idx,     }      with open(out_dir / 'manifest.json', 'w', encoding='utf-8') as handle:         json.dump(manifest, handle, indent=2)      print(f'Minimal dataset written to: {out_dir}')     print('Use Assembler.load_minimal_site_map(...) and segment=\"minimal\" to use this dataset.') In\u00a0[\u00a0]: Copied! <pre>if __name__ == '__main__':\n    main()\n</pre> if __name__ == '__main__':     main()"},{"location":"notebooks/scripts/fetch_filament_dataset/","title":"Fetch filament dataset","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>import argparse\nimport hashlib\nimport os\nimport re\nimport shutil\nimport tarfile\nimport tempfile\nimport zipfile\nfrom pathlib import Path\nfrom urllib.parse import urlparse\nfrom urllib.request import urlopen, urlretrieve\n</pre> import argparse import hashlib import os import re import shutil import tarfile import tempfile import zipfile from pathlib import Path from urllib.parse import urlparse from urllib.request import urlopen, urlretrieve In\u00a0[\u00a0]: Copied! <pre>EXPECTED_SUBDIRS = {\"0_s1s1\", \"1_s2s2\", \"FI\"}\nSHA256_PLACEHOLDERS = {\"&lt;SHA256&gt;\", \"SHA256\", \"YOUR_SHA256\", \"OPTIONAL_SHA256\"}\nFIGSHARE_DIRECT_URL_PATTERN = re.compile(r\"https://figshare\\.com/ndownloader/files/\\d+\")\n</pre> EXPECTED_SUBDIRS = {\"0_s1s1\", \"1_s2s2\", \"FI\"} SHA256_PLACEHOLDERS = {\"\", \"SHA256\", \"YOUR_SHA256\", \"OPTIONAL_SHA256\"} FIGSHARE_DIRECT_URL_PATTERN = re.compile(r\"https://figshare\\.com/ndownloader/files/\\d+\") In\u00a0[\u00a0]: Copied! <pre>def _compute_sha256(file_path: Path) -&gt; str:\n    digest = hashlib.sha256()\n    with open(file_path, \"rb\") as handle:\n        for chunk in iter(lambda: handle.read(1024 * 1024), b\"\"):\n            digest.update(chunk)\n    return digest.hexdigest()\n</pre> def _compute_sha256(file_path: Path) -&gt; str:     digest = hashlib.sha256()     with open(file_path, \"rb\") as handle:         for chunk in iter(lambda: handle.read(1024 * 1024), b\"\"):             digest.update(chunk)     return digest.hexdigest() In\u00a0[\u00a0]: Copied! <pre>def _resolve_archive_name(url: str) -&gt; str:\n    parsed = urlparse(url)\n    candidate = Path(parsed.path).name\n    if candidate:\n        return candidate\n    return \"filament_dataset_archive.zip\"\n</pre> def _resolve_archive_name(url: str) -&gt; str:     parsed = urlparse(url)     candidate = Path(parsed.path).name     if candidate:         return candidate     return \"filament_dataset_archive.zip\" In\u00a0[\u00a0]: Copied! <pre>def _resolve_download_url(url: str) -&gt; str:\n    if FIGSHARE_DIRECT_URL_PATTERN.search(url):\n        return url\n\n    try:\n        with urlopen(url) as response:\n            content_type = response.headers.get(\"Content-Type\", \"\")\n            final_url = response.geturl()\n            if \"text/html\" not in content_type.lower():\n                return final_url\n            html = response.read().decode(\"utf-8\", errors=\"ignore\")\n    except Exception:\n        return url\n\n    match = FIGSHARE_DIRECT_URL_PATTERN.search(html)\n    if match:\n        resolved = match.group(0)\n        print(f\"Resolved Figshare file download URL: {resolved}\")\n        return resolved\n\n    return url\n</pre> def _resolve_download_url(url: str) -&gt; str:     if FIGSHARE_DIRECT_URL_PATTERN.search(url):         return url      try:         with urlopen(url) as response:             content_type = response.headers.get(\"Content-Type\", \"\")             final_url = response.geturl()             if \"text/html\" not in content_type.lower():                 return final_url             html = response.read().decode(\"utf-8\", errors=\"ignore\")     except Exception:         return url      match = FIGSHARE_DIRECT_URL_PATTERN.search(html)     if match:         resolved = match.group(0)         print(f\"Resolved Figshare file download URL: {resolved}\")         return resolved      return url In\u00a0[\u00a0]: Copied! <pre>def _looks_like_dataset_dir(path: Path) -&gt; bool:\n    if not path.is_dir():\n        return False\n    present = {child.name for child in path.iterdir() if child.is_dir()}\n    return EXPECTED_SUBDIRS.issubset(present)\n</pre> def _looks_like_dataset_dir(path: Path) -&gt; bool:     if not path.is_dir():         return False     present = {child.name for child in path.iterdir() if child.is_dir()}     return EXPECTED_SUBDIRS.issubset(present) In\u00a0[\u00a0]: Copied! <pre>def _find_dataset_dir(root: Path) -&gt; Path | None:\n    if _looks_like_dataset_dir(root):\n        return root\n    for child in root.iterdir():\n        if _looks_like_dataset_dir(child):\n            return child\n    return None\n</pre> def _find_dataset_dir(root: Path) -&gt; Path | None:     if _looks_like_dataset_dir(root):         return root     for child in root.iterdir():         if _looks_like_dataset_dir(child):             return child     return None In\u00a0[\u00a0]: Copied! <pre>def _normalize_expected_sha256(expected_sha256: str | None) -&gt; str | None:\n    if not expected_sha256:\n        return None\n    normalized = expected_sha256.strip()\n    normalized_upper = normalized.upper()\n    if normalized in SHA256_PLACEHOLDERS or (normalized.startswith(\"&lt;\") and normalized.endswith(\"&gt;\")):\n        print(\n            \"Ignoring placeholder checksum value. \"\n            \"Set MDNA_FILAMENT_DATASET_SHA256 to a real hash to enable integrity verification.\"\n        )\n        return None\n    return normalized\n</pre> def _normalize_expected_sha256(expected_sha256: str | None) -&gt; str | None:     if not expected_sha256:         return None     normalized = expected_sha256.strip()     normalized_upper = normalized.upper()     if normalized in SHA256_PLACEHOLDERS or (normalized.startswith(\"&lt;\") and normalized.endswith(\"&gt;\")):         print(             \"Ignoring placeholder checksum value. \"             \"Set MDNA_FILAMENT_DATASET_SHA256 to a real hash to enable integrity verification.\"         )         return None     return normalized In\u00a0[\u00a0]: Copied! <pre>def _unpack_archive_robust(archive_path: Path, extract_dir: Path) -&gt; None:\n    try:\n        shutil.unpack_archive(str(archive_path), str(extract_dir))\n        return\n    except shutil.ReadError:\n        pass\n\n    if zipfile.is_zipfile(archive_path):\n        with zipfile.ZipFile(archive_path) as zip_handle:\n            zip_handle.extractall(extract_dir)\n        return\n\n    if tarfile.is_tarfile(archive_path):\n        with tarfile.open(archive_path) as tar_handle:\n            tar_handle.extractall(extract_dir)\n        return\n\n    raise shutil.ReadError(f\"Unknown archive format '{archive_path}'\")\n</pre> def _unpack_archive_robust(archive_path: Path, extract_dir: Path) -&gt; None:     try:         shutil.unpack_archive(str(archive_path), str(extract_dir))         return     except shutil.ReadError:         pass      if zipfile.is_zipfile(archive_path):         with zipfile.ZipFile(archive_path) as zip_handle:             zip_handle.extractall(extract_dir)         return      if tarfile.is_tarfile(archive_path):         with tarfile.open(archive_path) as tar_handle:             tar_handle.extractall(extract_dir)         return      raise shutil.ReadError(f\"Unknown archive format '{archive_path}'\") In\u00a0[\u00a0]: Copied! <pre>def fetch_dataset(\n    url: str,\n    output_root: Path,\n    dataset_dir_name: str,\n    expected_sha256: str | None,\n    force: bool,\n) -&gt; Path:\n    expected_sha256 = _normalize_expected_sha256(expected_sha256)\n    url = _resolve_download_url(url)\n\n    destination = output_root / dataset_dir_name\n    if destination.exists():\n        if not force:\n            print(f\"Dataset already exists at {destination}. Use --force to re-download.\")\n            return destination\n        shutil.rmtree(destination)\n\n    output_root.mkdir(parents=True, exist_ok=True)\n\n    with tempfile.TemporaryDirectory() as tmpdir:\n        tmp_path = Path(tmpdir)\n        archive_name = _resolve_archive_name(url)\n        archive_path = tmp_path / archive_name\n\n        print(f\"Downloading from: {url}\")\n        urlretrieve(url, archive_path)\n\n        if expected_sha256:\n            checksum = _compute_sha256(archive_path)\n            if checksum.lower() != expected_sha256.lower():\n                raise ValueError(\n                    \"Checksum mismatch for downloaded archive. \"\n                    f\"Expected {expected_sha256}, got {checksum}.\"\n                )\n            print(\"Checksum verified.\")\n\n        extracted_root = tmp_path / \"extracted\"\n        extracted_root.mkdir(parents=True, exist_ok=True)\n        _unpack_archive_robust(archive_path, extracted_root)\n\n        dataset_source = _find_dataset_dir(extracted_root)\n        if dataset_source is None:\n            raise RuntimeError(\n                \"Could not locate extracted filament dataset folder. \"\n                \"Expected subdirectories: 0_s1s1, 1_s2s2, FI.\"\n            )\n\n        shutil.move(str(dataset_source), str(destination))\n\n    print(f\"Dataset ready at: {destination}\")\n    return destination\n</pre> def fetch_dataset(     url: str,     output_root: Path,     dataset_dir_name: str,     expected_sha256: str | None,     force: bool, ) -&gt; Path:     expected_sha256 = _normalize_expected_sha256(expected_sha256)     url = _resolve_download_url(url)      destination = output_root / dataset_dir_name     if destination.exists():         if not force:             print(f\"Dataset already exists at {destination}. Use --force to re-download.\")             return destination         shutil.rmtree(destination)      output_root.mkdir(parents=True, exist_ok=True)      with tempfile.TemporaryDirectory() as tmpdir:         tmp_path = Path(tmpdir)         archive_name = _resolve_archive_name(url)         archive_path = tmp_path / archive_name          print(f\"Downloading from: {url}\")         urlretrieve(url, archive_path)          if expected_sha256:             checksum = _compute_sha256(archive_path)             if checksum.lower() != expected_sha256.lower():                 raise ValueError(                     \"Checksum mismatch for downloaded archive. \"                     f\"Expected {expected_sha256}, got {checksum}.\"                 )             print(\"Checksum verified.\")          extracted_root = tmp_path / \"extracted\"         extracted_root.mkdir(parents=True, exist_ok=True)         _unpack_archive_robust(archive_path, extracted_root)          dataset_source = _find_dataset_dir(extracted_root)         if dataset_source is None:             raise RuntimeError(                 \"Could not locate extracted filament dataset folder. \"                 \"Expected subdirectories: 0_s1s1, 1_s2s2, FI.\"             )          shutil.move(str(dataset_source), str(destination))      print(f\"Dataset ready at: {destination}\")     return destination In\u00a0[\u00a0]: Copied! <pre>def main() -&gt; None:\n    parser = argparse.ArgumentParser(\n        description=\"Download and install optional filament_dataset from Figshare (or any archive URL).\"\n    )\n    parser.add_argument(\n        \"--url\",\n        type=str,\n        default=os.environ.get(\"MDNA_FILAMENT_DATASET_URL\"),\n        help=(\n            \"Dataset URL. Can be a direct archive URL, a Figshare item URL, or a DOI URL. \"\n            \"Figshare page/DOI URLs are resolved to a direct file download automatically. \"\n            \"Can also be set via MDNA_FILAMENT_DATASET_URL.\"\n        ),\n    )\n    parser.add_argument(\n        \"--output-root\",\n        type=Path,\n        default=Path(\"examples/data\"),\n        help=\"Root folder where filament_dataset will be placed.\",\n    )\n    parser.add_argument(\n        \"--dataset-dir\",\n        type=str,\n        default=\"filament_dataset\",\n        help=\"Name of destination dataset folder.\",\n    )\n    parser.add_argument(\n        \"--sha256\",\n        type=str,\n        default=os.environ.get(\"MDNA_FILAMENT_DATASET_SHA256\"),\n        help=\"Optional archive SHA256 checksum. Can also be set via MDNA_FILAMENT_DATASET_SHA256.\",\n    )\n    parser.add_argument(\n        \"--force\",\n        action=\"store_true\",\n        help=\"Re-download even if destination dataset folder already exists.\",\n    )\n\n    args = parser.parse_args()\n\n    if not args.url:\n        raise SystemExit(\n            \"No dataset URL provided. Use --url &lt;FIGSHARE_ARCHIVE_URL&gt; or set MDNA_FILAMENT_DATASET_URL.\"\n        )\n\n    fetch_dataset(\n        url=args.url,\n        output_root=args.output_root,\n        dataset_dir_name=args.dataset_dir,\n        expected_sha256=args.sha256,\n        force=args.force,\n    )\n</pre> def main() -&gt; None:     parser = argparse.ArgumentParser(         description=\"Download and install optional filament_dataset from Figshare (or any archive URL).\"     )     parser.add_argument(         \"--url\",         type=str,         default=os.environ.get(\"MDNA_FILAMENT_DATASET_URL\"),         help=(             \"Dataset URL. Can be a direct archive URL, a Figshare item URL, or a DOI URL. \"             \"Figshare page/DOI URLs are resolved to a direct file download automatically. \"             \"Can also be set via MDNA_FILAMENT_DATASET_URL.\"         ),     )     parser.add_argument(         \"--output-root\",         type=Path,         default=Path(\"examples/data\"),         help=\"Root folder where filament_dataset will be placed.\",     )     parser.add_argument(         \"--dataset-dir\",         type=str,         default=\"filament_dataset\",         help=\"Name of destination dataset folder.\",     )     parser.add_argument(         \"--sha256\",         type=str,         default=os.environ.get(\"MDNA_FILAMENT_DATASET_SHA256\"),         help=\"Optional archive SHA256 checksum. Can also be set via MDNA_FILAMENT_DATASET_SHA256.\",     )     parser.add_argument(         \"--force\",         action=\"store_true\",         help=\"Re-download even if destination dataset folder already exists.\",     )      args = parser.parse_args()      if not args.url:         raise SystemExit(             \"No dataset URL provided. Use --url  or set MDNA_FILAMENT_DATASET_URL.\"         )      fetch_dataset(         url=args.url,         output_root=args.output_root,         dataset_dir_name=args.dataset_dir,         expected_sha256=args.sha256,         force=args.force,     ) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    main()\n</pre> if __name__ == \"__main__\":     main()"}]}