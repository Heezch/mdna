{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MDNA Docs","text":""},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>This site contains the project documentation for the <code>calculator</code> project that is a toy module used in the Real Python tutorial Build Your Python Project Documentation With MkDocs. Its aim is to give you a framework to build your project documentation using Python, MkDocs, mkdocstrings, and the Material for MkDocs theme.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#project-overview","title":"Project Overview","text":""},{"location":"#pymdna.compute_curvature","title":"<code>compute_curvature(traj, chainids=[0, 1])</code>","text":"<p>Compute the curvature of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_curvature(traj, chainids=[0,1]):\n    \"\"\"Compute the curvature of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"#pymdna.compute_groove_width","title":"<code>compute_groove_width(traj, chainids=[0, 1])</code>","text":"<p>Compute the groove width of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_groove_width(traj, chainids=[0,1]):\n    \"\"\"Compute the groove width of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"#pymdna.compute_linking_number","title":"<code>compute_linking_number(traj, chainids=[0, 1])</code>","text":"<p>Compute the linking number of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_linking_number(traj, chainids=[0,1]):\n    \"\"\"Compute the linking number of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"#pymdna.compute_rigid_parameters","title":"<code>compute_rigid_parameters(traj, chainids=[0, 1])</code>","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The traj argument must be provided.</li> <li>The chainids argument is optional and defaults to [0, 1].</li> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1]):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The traj argument must be provided.\n        - The chainids argument is optional and defaults to [0, 1].\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        # Compute the rigid base parameters of a DNA structure\n        traj = md.load('dna.pdb')\n        rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])\"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids)\n</code></pre>"},{"location":"#pymdna.compute_rigid_parameters--compute-the-rigid-base-parameters-of-a-dna-structure","title":"Compute the rigid base parameters of a DNA structure","text":"<p>traj = md.load('dna.pdb') rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])</p>"},{"location":"#pymdna.connect","title":"<code>connect(Nucleic0, Nucleic1, sequence=None, n_bp=None, leader=0, frame=-1, margin=1, minimize=True, exvol_rad=0.0, temperature=300)</code>","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Note: The minimization does not use excluded volume interactions by default. This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def connect(Nucleic0, Nucleic1, sequence: str = None, n_bp: int = None, leader: int = 0, frame: int = -1, margin: int = 1, minimize: bool = True, exvol_rad: float = 0.0, temperature: int = 300):\n    \"\"\"Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.\n\n    The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure.\n    To connect the two strands, a straight line is interpolated between the two ends,\n    and the optimal number of base pairs is distributed to achieve a neutral twist.\n\n    Note:\n    The minimization does not use excluded volume interactions by default.\n    This is because the excluded volume interactions require the EV beads to have no overlap.\n    However, in the initial configuration, the EV beads are likely to have overlap.\n    If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.\n\n    Args:\n        Nucleic0 (Nucleic): First DNA structure to connect.\n        Nucleic1 (Nucleic): Second DNA structure to connect.\n        sequence (str, optional): DNA sequence of the connecting DNA strand. Default is None.\n        n_bp (int, optional): Number of base pairs of the connecting DNA strand. Default is None.\n        leader (int, optional): The leader of the DNA structure to connect. Default is 0.\n        frame (int, optional): The time frame to connect. Default is -1.\n        margin (int, optional): Number of base pairs to fix at the end. Default is 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure. Default is True.\n        exvol_rad (float, optional): Radius for excluded volume interactions during minimization. Default is 0.0.\n        temperature (int, optional): Temperature for minimization. Default is 300.\n\n    Returns:\n        Nucleic (object): DNA structure with the two DNA structures connected.\n\n    Raises:\n        ValueError: If either of the DNA structures is circular.\n\n    Example:\n        # Connect two DNA structures\n        connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)\n    \"\"\"\n    if Nucleic0.circular or Nucleic1.circular:\n        raise ValueError('Cannot connect circular DNA structures')\n\n    if sequence is not None and n_bp is None:\n        n_bp = len(sequence)\n\n    # Connect the two DNA structures\n    connector = Connector(Nucleic0, Nucleic1, sequence=sequence, n_bp=n_bp, leader=leader, frame=frame, margin=margin)\n    if minimize:\n        connector.connected_nuc.minimize(exvol_rad=exvol_rad, temperature=temperature, fixed=connector.fixed)\n    return connector.connected_nuc\n</code></pre>"},{"location":"#pymdna.connect--connect-two-dna-structures","title":"Connect two DNA structures","text":"<p>connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)</p>"},{"location":"#pymdna.load","title":"<code>load(traj=None, frames=None, sequence=None, chainids=[0, 1], circular=None)</code>","text":"<p>Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>frames</code> <code>array</code> <p>Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>sequence</code> <code>str</code> <p>DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>chainids</code> <code>list</code> <p>Chain IDs of the DNA structure. (default: [0,1])</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>If traj is provided, the frames and sequence arguments are ignored.</li> <li>If frames is provided, the traj and sequence arguments are ignored.</li> <li>If sequence is provided, the traj and frames arguments are ignored.</li> <li>If circular is not provided, it will be determined based on the input data.</li> </ul> Source code in <code>pymdna/nucleic.py</code> <pre><code>def load(traj=None, frames=None, sequence=None, chainids=[0,1], circular=None):\n    \"\"\"Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.\n\n    Args:\n        traj (object, optional): MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)\n        frames (np.array, optional): Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)\n        sequence (str, optional): DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)\n        chainids (list, optional): Chain IDs of the DNA structure. (default: [0,1])\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - If traj is provided, the frames and sequence arguments are ignored.\n        - If frames is provided, the traj and sequence arguments are ignored.\n        - If sequence is provided, the traj and frames arguments are ignored.\n        - If circular is not provided, it will be determined based on the input data.\n    \"\"\"\n    return Nucleic(sequence=sequence, n_bp=None, traj=traj, frames=frames, chainids=chainids, circular=None)\n</code></pre>"},{"location":"#pymdna.make","title":"<code>make(sequence=None, control_points=None, circular=False, closed=False, n_bp=None, dLk=None)</code>","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>If control_points are provided, the sequence argument is ignored.</li> <li>If sequence is provided, the control_points argument is ignored.</li> <li>If circular is True, the DNA structure will be closed.</li> <li>If circular is False, the DNA structure will be open.</li> <li>The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.</li> </ul> Source code in <code>pymdna/nucleic.py</code> <pre><code>def make(sequence: str = None, control_points: np.ndarray = None, circular : bool = False, closed: bool = False, n_bp : int = None, dLk : int = None):\n    \"\"\"Generate a DNA structure from a given DNA sequence and control points.\n\n    Args:\n        sequence (str, optional): DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)\n        control_points (ndarray, optional): Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)\n        closed (bool, optional): Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)\n        n_bp (int, optional): Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)\n        dLk (int, optional): Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - If control_points are provided, the sequence argument is ignored.\n        - If sequence is provided, the control_points argument is ignored.\n        - If circular is True, the DNA structure will be closed.\n        - If circular is False, the DNA structure will be open.\n        - The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.\n    \"\"\"\n\n    # Check if control points are provided, otherwise generate a straight line\n    if control_points is not None:\n        if len(control_points) &lt; 4:\n            raise ValueError('Control points should contain at least 4 points [x, y, z]')\n        elif len(control_points) &gt; 4 and n_bp is None:\n            n_bp = len(control_points)  # Number of base pairs\n    elif control_points is None and circular:\n        control_points = Shapes.circle(radius=1)\n        closed = True\n    else:\n        # Linear strand of control points\n        control_points = Shapes.line(length=1)\n\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n    spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    return Nucleic(sequence=sequence, n_bp=n_bp, frames=spline.frames, chainids=[0, 1], circular=circular)\n</code></pre>"},{"location":"#pymdna.sequence_to_md","title":"<code>sequence_to_md(sequence=None, time=10, time_unit='picoseconds', temperature=310, solvated=False, filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)</code>","text":"<p>Simulate DNA sequence using OpenMM.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code.</p> <code>None</code> <code>time</code> <code>int</code> <p>Simulation time.</p> <code>10</code> <code>time_unit</code> <code>str</code> <p>Time unit (picoseconds or nanoseconds).</p> <code>'picoseconds'</code> <code>temperature</code> <code>int</code> <p>Temperature in Kelvin.</p> <code>310</code> <code>solvated</code> <code>bool</code> <p>Solvate DNA with water and ions.</p> <code>False</code> <code>filename</code> <code>str</code> <p>Filename for pdb output.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Save the trajectory.</p> <code>True</code> <code>output</code> <code>str</code> <p>Output format for the trajectory (GROMACS or HDF5).</p> <code>'GROMACS'</code> <code>shape</code> <code>str</code> <p>Shape of the DNA structure (linear or circular).</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs in the DNA structure.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in linking number of the DNA structure.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MDTraj</code> <code>object</code> <p>MDtraj trajectory object of DNA structure.</p> Notes <ul> <li>This function uses the OpenMM library to simulate the behavior of a DNA sequence.</li> <li>The simulation can be performed for a specified time period at a given temperature.</li> <li>The DNA structure can be solvated with water and ions.</li> <li>The trajectory of the simulation can be saved in either GROMACS or HDF5 format.</li> <li>The shape of the DNA structure can be specified as linear or circular.</li> <li>The number of base pairs in the DNA structure can be provided.</li> <li>The change in linking number of the DNA structure can be specified.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def sequence_to_md(sequence=None, time=10, time_unit='picoseconds',temperature=310, solvated=False,  filename='my_dna', save=True, output='GROMACS',shape=None,n_bp=None,circular=False,dLk=None):\n    \"\"\"Simulate DNA sequence using OpenMM.\n\n        Args:\n            sequence (str): DNA sequence code.\n            time (int): Simulation time.\n            time_unit (str): Time unit (picoseconds or nanoseconds).\n            temperature (int): Temperature in Kelvin.\n            solvated (bool): Solvate DNA with water and ions.\n            filename (str): Filename for pdb output.\n            save (bool): Save the trajectory.\n            output (str): Output format for the trajectory (GROMACS or HDF5).\n            shape (str): Shape of the DNA structure (linear or circular).\n            n_bp (int): Number of base pairs in the DNA structure.\n            circular (bool): Flag indicating if the DNA structure is circular.\n            dLk (int): Change in linking number of the DNA structure.\n\n        Returns:\n            MDTraj (object): MDtraj trajectory object of DNA structure.\n\n        Notes:\n            - This function uses the OpenMM library to simulate the behavior of a DNA sequence.\n            - The simulation can be performed for a specified time period at a given temperature.\n            - The DNA structure can be solvated with water and ions.\n            - The trajectory of the simulation can be saved in either GROMACS or HDF5 format.\n            - The shape of the DNA structure can be specified as linear or circular.\n            - The number of base pairs in the DNA structure can be provided.\n            - The change in linking number of the DNA structure can be specified.\n\n        Example:\n            # Simulate a linear DNA structure for 100 picoseconds at 300 K\n            trajectory = sequence_to_md(sequence='ATCG', time=100, time_unit='picoseconds', temperature=300, shape='linear')\n        \"\"\"\n\n    # TODO update with make function\n    try:\n        import openmm as mm\n        import openmm.app as app\n        import openmm.unit as unit\n        from mdtraj.reporters import HDF5Reporter\n        import mdtraj as md\n        openmm_available = True\n    except ImportError:\n        openmm_available = False\n        print(\"Openmm is not installed. You shall not pass.\")\n\n    pdb = sequence_to_pdb(sequence=sequence, filename='my_dna', save=True, output='GROMACS',shape=None,n_bp=None,circular=False,dLk=None)\n\n    if not openmm_available:\n        print('But here is your DNA structure')\n        return pdb\n    else:\n        if time_unit == 'picoseconds':\n            time_unit = time * unit.picoseconds\n        elif time_unit == 'nanoseconds':\n            time_unit = time * unit.nanoseconds\n\n        time = time * time_unit\n        time_step = 2 * unit.femtoseconds\n        temperature = 310 *unit.kelvin\n        steps = int(time/time_step)\n\n        print(f'Initialize DNA openMM simulation at {temperature._value} K for', time, 'time units')\n        topology = pdb.topology.to_openmm()\n        modeller = app.Modeller(topology, pdb.xyz[0])\n\n        forcefield = app.ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')\n        modeller.addHydrogens(forcefield)\n        if solvated:\n            print('Solvate DNA with padding of 1.0 nm and 0.1 M KCl')\n            modeller.addSolvent(forcefield, padding=1.0*unit.nanometers, ionicStrength=0.1*unit.molar, positiveIon='K+')\n\n        system = forcefield.createSystem(modeller.topology, nonbondedMethod=app.CutoffNonPeriodic)\n        integrator = mm.LangevinIntegrator(temperature, 1.0/unit.picoseconds, time_step)\n\n        simulation = app.Simulation(modeller.topology, system, integrator)\n        simulation.context.setPositions(modeller.positions)\n        simulation.reporters.append(HDF5Reporter(f'./{sequence}'+'.h5', 100))\n        simulation.reporters.append(app.StateDataReporter(f'./output_{sequence}.csv', 100, step=True, potentialEnergy=True, temperature=True,speed=True))\n\n        print('Minimize energy')\n        simulation.minimizeEnergy()\n\n        print('Run simulation for', steps, 'steps')\n        simulation.step(steps)\n        simulation.reporters[0].close()\n        print('Simulation completed')\n        print('Saved trajectory as:', f'./{sequence}'+'.h5')\n        traj = md.load_hdf5(f'./{sequence}'+'.h5')\n        return traj\n</code></pre>"},{"location":"#pymdna.sequence_to_md--simulate-a-linear-dna-structure-for-100-picoseconds-at-300-k","title":"Simulate a linear DNA structure for 100 picoseconds at 300 K","text":"<p>trajectory = sequence_to_md(sequence='ATCG', time=100, time_unit='picoseconds', temperature=300, shape='linear')</p>"},{"location":"#pymdna.sequence_to_pdb","title":"<code>sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)</code>","text":"<p>Generate a DNA structure from a DNA sequence code.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence code. Default is 'CGCGAATTCGCG'.</p> <code>'CGCGAATTCGCG'</code> <code>filename</code> <code>str</code> <p>The filename for the pdb output. Default is 'my_dna'.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Whether to save the pdb file. Default is True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The type of pdb DNA format. Default is 'GROMACS'.</p> <code>'GROMACS'</code> <code>shape</code> <code>ndarray</code> <p>Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Indicates if the structure is circular/closed. Default is False.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.</p> <code>None</code> <p>Returns:</p> Type Description <code>Trajectory</code> <p>md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence is not provided.</p> Notes <ul> <li>The sequence argument must be provided.</li> <li>The returned MDtraj object contains the DNA structure generated from the sequence and control points.</li> <li>If the output is set to 'GROMACS', the DNA structure is edited to make it compatible with the AMBER force field.</li> <li>The pdb file is saved in the current directory with the specified filename.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def sequence_to_pdb(sequence: str = 'CGCGAATTCGCG', filename: str = 'my_dna', save: bool = True, output: str = 'GROMACS', shape: np.ndarray = None, n_bp: int = None, circular: bool = False, dLk: int = None) -&gt; md.Trajectory:\n    \"\"\"Generate a DNA structure from a DNA sequence code.\n\n    Args:\n        sequence (str, optional): The DNA sequence code. Default is 'CGCGAATTCGCG'.\n        filename (str, optional): The filename for the pdb output. Default is 'my_dna'.\n        save (bool, optional): Whether to save the pdb file. Default is True.\n        output (str, optional): The type of pdb DNA format. Default is 'GROMACS'.\n        shape (np.ndarray, optional): Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.\n        n_bp (int, optional): Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.\n        circular (bool, optional): Indicates if the structure is circular/closed. Default is False.\n        dLk (int, optional): Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.\n\n    Returns:\n        md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).\n\n    Raises:\n        ValueError: If the sequence is not provided.\n\n    Notes:\n        - The sequence argument must be provided.\n        - The returned MDtraj object contains the DNA structure generated from the sequence and control points.\n        - If the output is set to 'GROMACS', the DNA structure is edited to make it compatible with the AMBER force field.\n        - The pdb file is saved in the current directory with the specified filename.\n\n    Example:\n        # Generate a DNA structure from a sequence\n        traj = sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)\n    \"\"\"\n\n    # Check if the sequence is provided\n    if sequence is None:\n        raise ValueError(\"The sequence argument must be provided.\")\n\n    # TODO: Update with make function\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    # Linear strand of control points\n    if shape is None:\n        shape = Shapes.line(length=1)\n\n    # Convert the control points to a spline\n    spline = SplineFrames(control_points=shape, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    # Generate the DNA structure\n    generator = StructureGenerator(sequence=sequence, spline=spline, circular=circular)\n\n    # Edit the DNA structure to make it compatible with the AMBER force field\n    traj = generator.traj\n    if output == 'GROMACS':\n        phosphor_termini = traj.top.select(f'name P OP1 OP2 and resid 0 {traj.top.chain(0).n_residues}')\n        all_atoms = traj.top.select('all')\n        traj = traj.atom_slice([at for at in all_atoms if at not in phosphor_termini])\n\n    # Save the DNA structure as a pdb file\n    if save:\n        traj.save(f'./{filename}.pdb')\n\n    return traj\n</code></pre>"},{"location":"#pymdna.sequence_to_pdb--generate-a-dna-structure-from-a-sequence","title":"Generate a DNA structure from a sequence","text":"<p>traj = sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I want to thank my house plants for providing me with a negligible amount of oxygen each day. Also, I want to thank the sun for providing more than half of their nourishment free of charge.</p>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions     here</li> </ul>"},{"location":"geometry-reference/","title":"Geometry classes","text":""},{"location":"geometry-reference/#rigid-nucleobase-class","title":"Rigid Nucleobase class","text":"<p>summary</p> Source code in <code>pymdna/geometry.py</code> <pre><code>class ReferenceBase:\n    \"\"\"_summary_\n    \"\"\"\n    def __init__(self, traj):\n        \"\"\"_summary_\n\n        Args:\n            traj (_type_): _description_\n        \"\"\"\n        self.traj = traj\n        # Determine base type (purine/pyrimidine/other)\n        self.base_type = self.get_base_type()\n        # Define the Tsukuba convention parameters\n        self.tau_1, self.tau_2, self.d = np.radians(141.478), -np.radians(54.418), 0.4702     \n        # Get coordinates of key atoms based on base type\n        self.C1_coords, self.N_coords, self.C_coords = self.get_coordinates()\n        # Calculate base reference point and base vectors\n        self.b_R, self.b_L, self.b_D, self.b_N = self.calculate_base_frame()\n        # self.basis = np.array([self.b_D.T, self.b_L.T, self.b_N])\n\n    def _select_atom_by_name(self, name):\n        \"\"\"_summary_\n\n        Args:\n            name (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # Select an atom by name returns shape (n_frames, 1, [x,y,z])\n        return np.squeeze(self.traj.xyz[:,[self.traj.topology.select(f'name {name}')[0]],:],axis=1)\n\n    def get_base_type(self):\n        \"\"\"_summary_\n\n        Raises:\n            ValueError: _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # Extracts all non-hydrogen atoms from the trajectory topology\n        atoms = {atom.name for atom in self.traj.topology.atoms if atom.element.symbol != 'H'}\n\n        # Check each base in the dictionary to see if all its atoms are present in the extracted atoms set\n        for base, base_atoms in NUCLEOBASE_DICT.items():\n            if all(atom in atoms for atom in base_atoms):\n                return base\n        # If no base matches, raise an error\n        raise ValueError(\"Cannot determine the base type from the PDB file.\")\n\n    def get_coordinates(self):\n        \"\"\"_summary_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # Get the coordinates of key atoms based on the base type\n        C1_coords = self._select_atom_by_name('\"C1\\'\"')\n        if self.base_type in ['C','T','U','D']:# \"pyrimidine\"\n            N_coords = self._select_atom_by_name(\"N1\")\n            C_coords = self._select_atom_by_name(\"C2\")\n        elif self.base_type in ['A','G','E','B','P']:# \"purine\":\n            N_coords = self._select_atom_by_name(\"N9\")\n            C_coords = self._select_atom_by_name(\"C4\") \n        elif self.base_type in ['S','Z']: # Hachi pyrimidine analogues\n            N_coords = self._select_atom_by_name(\"C1\")\n            C_coords = self._select_atom_by_name(\"C2\")\n        elif self.base_type in ['L']: # UBPs hydrophobic\n            N_coords = self._select_atom_by_name(\"N1\")\n            C_coords = self._select_atom_by_name(\"C5\")\n        elif self.base_type in ['M']: # UBPs hydrophilic\n            N_coords = self._select_atom_by_name(\"C1\")\n            C_coords = self._select_atom_by_name(\"C6\")\n        return C1_coords, N_coords, C_coords\n\n\n    def calculate_base_frame(self):\n        \"\"\"_summary_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n\n        # Calculate normal vector using cross product of vectors formed by key atoms\n        #  The coords have the shape (n,1,3)\n        b_N = np.cross((self.N_coords - self.C1_coords), (self.N_coords-self.C_coords), axis=1)\n        b_N /= np.linalg.norm(b_N, axis=1, keepdims=True)  # Normalize b_N to have unit length\n\n        # Compute displacement vector N-C1' \n        N_C1_vector = self.C1_coords - self.N_coords  # Pointing from N to C1'\n        N_C1_vector /= np.linalg.norm(N_C1_vector, axis=1, keepdims=True)\n\n        # Rotate N-C1' vector by angle tau_1 around b_N to get the direction for displacement\n        R_b_R = RigidBody.get_rotation_matrix(self.tau_1 * b_N)\n\n        # Displace N along this direction by a distance d to get b_R\n        b_R = self.N_coords + np.einsum('ijk,ik-&gt;ij', R_b_R, N_C1_vector * self.d)\n\n        # Take a unit vector in the N-C1' direction, rotate it around b_N by angle tau_2 to get b_L\n        R_b_L = RigidBody.get_rotation_matrix(self.tau_2 * b_N)\n        b_L = np.einsum('ijk,ik-&gt;ij', R_b_L, N_C1_vector) \n\n        # Calculate b_D using cross product of b_L and b_N\n        b_D = np.cross(b_L, b_N, axis=1)\n\n        return np.array([b_R, b_D, b_L, b_N])\n        #return np.array([b_R, -b_D, -b_L, -b_N])\n\n    def plot_baseframe(self,atoms=True, frame=True, ax=None,length=1):\n        \"\"\"_summary_\n\n        Args:\n            atoms (bool, optional): _description_. Defaults to True.\n            frame (bool, optional): _description_. Defaults to True.\n            ax (_type_, optional): _description_. Defaults to None.\n            length (int, optional): _description_. Defaults to 1.\n        \"\"\"\n        if ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n        else:\n            fig = False\n\n        # Plot the DNA atoms\n        if atoms:\n            atoms_coords = self.traj.xyz[0]\n            ax.scatter(atoms_coords[:,0], atoms_coords[:,1], atoms_coords[:,2], alpha=0.6)\n\n        # Plot the reference frame vectors\n        if frame:\n            origin = self.b_R[0]\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_L[0][0], self.b_L[0][1], self.b_L[0][2], \n                    color='r', length=length, normalize=True)\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_D[0][0], self.b_D[0][1], self.b_D[0][2], \n                    color='g', length=length, normalize=True)\n            ax.quiver(origin[0], origin[1], origin[2], \n                    self.b_N[0][0], self.b_N[0][1], self.b_N[0][2], \n                    color='b', length=length, normalize=True)\n\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n\n        if fig: \n            # Make axes of equal length\n            max_range = np.array([\n                atoms_coords[:,0].max()-atoms_coords[:,0].min(), \n                atoms_coords[:,1].max()-atoms_coords[:,1].min(), \n                atoms_coords[:,2].max()-atoms_coords[:,2].min()\n            ]).max() / 2.0\n\n            mid_x = (atoms_coords[:,0].max()+atoms_coords[:,0].min()) * 0.5\n            mid_y = (atoms_coords[:,1].max()+atoms_coords[:,1].min()) * 0.5\n            mid_z = (atoms_coords[:,2].max()+atoms_coords[:,2].min()) * 0.5\n            ax.set_xlim(mid_x - max_range, mid_x + max_range)\n            ax.set_ylim(mid_y - max_range, mid_y + max_range)\n            ax.set_zlim(mid_z - max_range, mid_z + max_range)\n\n        ax.axis('equal')\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.ReferenceBase.__init__","title":"<code>__init__(traj)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>_type_</code> <p>description</p> required Source code in <code>pymdna/geometry.py</code> <pre><code>def __init__(self, traj):\n    \"\"\"_summary_\n\n    Args:\n        traj (_type_): _description_\n    \"\"\"\n    self.traj = traj\n    # Determine base type (purine/pyrimidine/other)\n    self.base_type = self.get_base_type()\n    # Define the Tsukuba convention parameters\n    self.tau_1, self.tau_2, self.d = np.radians(141.478), -np.radians(54.418), 0.4702     \n    # Get coordinates of key atoms based on base type\n    self.C1_coords, self.N_coords, self.C_coords = self.get_coordinates()\n    # Calculate base reference point and base vectors\n    self.b_R, self.b_L, self.b_D, self.b_N = self.calculate_base_frame()\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.ReferenceBase.calculate_base_frame","title":"<code>calculate_base_frame()</code>","text":"<p>summary</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def calculate_base_frame(self):\n    \"\"\"_summary_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n\n    # Calculate normal vector using cross product of vectors formed by key atoms\n    #  The coords have the shape (n,1,3)\n    b_N = np.cross((self.N_coords - self.C1_coords), (self.N_coords-self.C_coords), axis=1)\n    b_N /= np.linalg.norm(b_N, axis=1, keepdims=True)  # Normalize b_N to have unit length\n\n    # Compute displacement vector N-C1' \n    N_C1_vector = self.C1_coords - self.N_coords  # Pointing from N to C1'\n    N_C1_vector /= np.linalg.norm(N_C1_vector, axis=1, keepdims=True)\n\n    # Rotate N-C1' vector by angle tau_1 around b_N to get the direction for displacement\n    R_b_R = RigidBody.get_rotation_matrix(self.tau_1 * b_N)\n\n    # Displace N along this direction by a distance d to get b_R\n    b_R = self.N_coords + np.einsum('ijk,ik-&gt;ij', R_b_R, N_C1_vector * self.d)\n\n    # Take a unit vector in the N-C1' direction, rotate it around b_N by angle tau_2 to get b_L\n    R_b_L = RigidBody.get_rotation_matrix(self.tau_2 * b_N)\n    b_L = np.einsum('ijk,ik-&gt;ij', R_b_L, N_C1_vector) \n\n    # Calculate b_D using cross product of b_L and b_N\n    b_D = np.cross(b_L, b_N, axis=1)\n\n    return np.array([b_R, b_D, b_L, b_N])\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.ReferenceBase.get_base_type","title":"<code>get_base_type()</code>","text":"<p>summary</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def get_base_type(self):\n    \"\"\"_summary_\n\n    Raises:\n        ValueError: _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Extracts all non-hydrogen atoms from the trajectory topology\n    atoms = {atom.name for atom in self.traj.topology.atoms if atom.element.symbol != 'H'}\n\n    # Check each base in the dictionary to see if all its atoms are present in the extracted atoms set\n    for base, base_atoms in NUCLEOBASE_DICT.items():\n        if all(atom in atoms for atom in base_atoms):\n            return base\n    # If no base matches, raise an error\n    raise ValueError(\"Cannot determine the base type from the PDB file.\")\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.ReferenceBase.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>summary</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"_summary_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Get the coordinates of key atoms based on the base type\n    C1_coords = self._select_atom_by_name('\"C1\\'\"')\n    if self.base_type in ['C','T','U','D']:# \"pyrimidine\"\n        N_coords = self._select_atom_by_name(\"N1\")\n        C_coords = self._select_atom_by_name(\"C2\")\n    elif self.base_type in ['A','G','E','B','P']:# \"purine\":\n        N_coords = self._select_atom_by_name(\"N9\")\n        C_coords = self._select_atom_by_name(\"C4\") \n    elif self.base_type in ['S','Z']: # Hachi pyrimidine analogues\n        N_coords = self._select_atom_by_name(\"C1\")\n        C_coords = self._select_atom_by_name(\"C2\")\n    elif self.base_type in ['L']: # UBPs hydrophobic\n        N_coords = self._select_atom_by_name(\"N1\")\n        C_coords = self._select_atom_by_name(\"C5\")\n    elif self.base_type in ['M']: # UBPs hydrophilic\n        N_coords = self._select_atom_by_name(\"C1\")\n        C_coords = self._select_atom_by_name(\"C6\")\n    return C1_coords, N_coords, C_coords\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.ReferenceBase.plot_baseframe","title":"<code>plot_baseframe(atoms=True, frame=True, ax=None, length=1)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>frame</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>ax</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>length</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> Source code in <code>pymdna/geometry.py</code> <pre><code>def plot_baseframe(self,atoms=True, frame=True, ax=None,length=1):\n    \"\"\"_summary_\n\n    Args:\n        atoms (bool, optional): _description_. Defaults to True.\n        frame (bool, optional): _description_. Defaults to True.\n        ax (_type_, optional): _description_. Defaults to None.\n        length (int, optional): _description_. Defaults to 1.\n    \"\"\"\n    if ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n    else:\n        fig = False\n\n    # Plot the DNA atoms\n    if atoms:\n        atoms_coords = self.traj.xyz[0]\n        ax.scatter(atoms_coords[:,0], atoms_coords[:,1], atoms_coords[:,2], alpha=0.6)\n\n    # Plot the reference frame vectors\n    if frame:\n        origin = self.b_R[0]\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_L[0][0], self.b_L[0][1], self.b_L[0][2], \n                color='r', length=length, normalize=True)\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_D[0][0], self.b_D[0][1], self.b_D[0][2], \n                color='g', length=length, normalize=True)\n        ax.quiver(origin[0], origin[1], origin[2], \n                self.b_N[0][0], self.b_N[0][1], self.b_N[0][2], \n                color='b', length=length, normalize=True)\n\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n\n    if fig: \n        # Make axes of equal length\n        max_range = np.array([\n            atoms_coords[:,0].max()-atoms_coords[:,0].min(), \n            atoms_coords[:,1].max()-atoms_coords[:,1].min(), \n            atoms_coords[:,2].max()-atoms_coords[:,2].min()\n        ]).max() / 2.0\n\n        mid_x = (atoms_coords[:,0].max()+atoms_coords[:,0].min()) * 0.5\n        mid_y = (atoms_coords[:,1].max()+atoms_coords[:,1].min()) * 0.5\n        mid_z = (atoms_coords[:,2].max()+atoms_coords[:,2].min()) * 0.5\n        ax.set_xlim(mid_x - max_range, mid_x + max_range)\n        ax.set_ylim(mid_y - max_range, mid_y + max_range)\n        ax.set_zlim(mid_z - max_range, mid_z + max_range)\n\n    ax.axis('equal')\n</code></pre>"},{"location":"geometry-reference/#rigid-base-parameter-class","title":"Rigid Base Parameter class","text":"<p>Class to compute the rigid base parameters of a DNA structure.</p> <p>loc = '/Users/thor/surfdrive/Scripts/notebooks/HNS-sequence/WorkingDir/nolinker/data/md/0_highaff/FI/drytrajs/' traj = md.load(loc+'dry_10.xtc',top=loc+'dry_10.pdb')</p> <p>dna = NucleicFrames(traj) params, names = dna.get_paramters() params.shape, names</p>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames--confidence-intervals","title":"Confidence intervals","text":"<p>from scipy.stats import t</p> <p>fig, ax = plt.subplots(2,6,figsize=(12,4)) fig.tight_layout() ax = ax.flatten() M = np.mean(params, axis=0) S = np.std(params, axis=0) n = params.shape[0] ci = t.ppf(0.975, df=n-1) * S / np.sqrt(n) x = np.arange(0, params.shape[1]) for , i in enumerate(M.T):     if _ &gt;= 6:         c1, c2 = 'red','coral'     else:         c1, c2 = 'blue','cornflowerblue'     ax[].plot(i[::-1], '-o',color=c1)     ax[].fill_between(x, (i-ci[])[::-1], (i+ci[])[::-1], color=c2, alpha=0.2)     ax[].set_title(names[_])</p> Source code in <code>pymdna/geometry.py</code> <pre><code>class NucleicFrames:\n    \"\"\"Class to compute the rigid base parameters of a DNA structure.\n\n    loc = '/Users/thor/surfdrive/Scripts/notebooks/HNS-sequence/WorkingDir/nolinker/data/md/0_highaff/FI/drytrajs/'\n    traj = md.load(loc+'dry_10.xtc',top=loc+'dry_10.pdb')\n\n    dna = NucleicFrames(traj)\n    params, names = dna.get_paramters()\n    params.shape, names\n\n    # Confidence intervals \n    from scipy.stats import t\n\n    fig, ax = plt.subplots(2,6,figsize=(12,4))\n    fig.tight_layout()\n    ax = ax.flatten()\n    M = np.mean(params, axis=0)\n    S = np.std(params, axis=0)\n    n = params.shape[0]\n    ci = t.ppf(0.975, df=n-1) * S / np.sqrt(n)\n    x = np.arange(0, params.shape[1])\n    for _, i in enumerate(M.T):\n        if _ &gt;= 6:\n            c1, c2 = 'red','coral'\n        else:\n            c1, c2 = 'blue','cornflowerblue'\n        ax[_].plot(i[::-1], '-o',color=c1)\n        ax[_].fill_between(x, (i-ci[_])[::-1], (i+ci[_])[::-1], color=c2, alpha=0.2)\n        ax[_].set_title(names[_])\n    \"\"\"\n\n    def __init__(self, traj, chainids=[0,1],frames_only=False):\n        \"\"\"_summary_\n\n        Args:\n            traj (_type_): _description_\n            chainids (list, optional): _description_. Defaults to [0,1].\n            frames_only (bool, optional): _description_. Defaults to False.\n        \"\"\"\n        self.traj = traj\n        self.top = traj.topology\n        self.res_A = self.get_residues(chain_index=chainids[0], reverse=False)\n        self.res_B = self.get_residues(chain_index=chainids[1], reverse=True)\n        self.mean_reference_frames = np.empty((len(self.res_A), 1, 4, 3))\n        self.base_frames = self.get_base_reference_frames()\n        self.analyse_frames()\n\n    def get_residues(self, chain_index, reverse=False):\n        \"\"\"Get residues from specified chain.\"\"\"\n        if chain_index &gt;= len(self.top._chains):\n            raise IndexError(\"Chain index out of range.\")\n        chain = self.top._chains[chain_index]\n        residues = chain._residues\n        return list(reversed(residues)) if reverse else residues\n\n    def load_reference_bases(self):\n        \"\"\"Load reference bases from local files.\"\"\"\n        # Not used at the moment??\n        bases = ['C', 'G', 'T', 'A']\n        #return {f'D{base}': md.load_pdb(get_data_file_path(f'./atomic/NDB96_{base}.pdb')) for base in bases}\n        return {f'D{base}': md.load_hdf5(get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in bases}\n\n    def get_base_vectors(self, res):\n        \"\"\"Compute base vectors from reference base.\"\"\"\n        ref_base = ReferenceBase(res)\n        return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n\n    def get_base_reference_frames(self):\n        \"\"\"Get reference frames for each residue.\"\"\"\n        reference_frames = {} # Dictionary to store the base vectors for each residue\n        for res in self.res_A + self.res_B:\n            res_traj = self.traj.atom_slice([at.index for at in res.atoms])\n            base_vectors = self.get_base_vectors(res_traj)\n            reference_frames[res] = base_vectors # Store the base vectors for the residue index (with shape (4, n_frames, 3))\n        return reference_frames\n\n    def reshape_input(self,input_A,input_B,is_step=False):\n\n        \"\"\"This function reshapes the input to the correct format for the calculations. \n        And splits the input into rotation matrices and origins for the calculations.\n\n        Returns:\n        --------\n        rotation_A/rotation_B : ndarray\n            The rotation matrices of shape (n, 3, 3) for the first triad.\n        origin_A/origin_B : ndarray\n            The origins of shape (n, 3) for the first triad.\n        original_shape : tuple\n            The original shape of the input.\"\"\"\n\n        # Store original shape\n        original_shape = input_A.shape\n\n        # Flatten frames to compute rotation matrices for each time step simultaneously\n        input_A_ = input_A.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n        input_B_ = input_B.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n\n        # Extract the triads without origin (rotation matrices)\n        rotation_A = input_A_[:,1:]  # shape (n, 3, 3)\n        rotation_B = input_B_[:,1:]  # shape (n, 3, 3)\n\n        if not is_step:\n            # flip (connecting the backbones) and the (baseplane normals).\n            # so the second and third vector b_L, b_N\n            rotation_B[:,[1,2]] *= -1\n\n        # Extract origins of triads\n        origin_A = input_A_[:,0]  # shape (n, 3)\n        origin_B = input_B_[:,0]  # shape (n, 3)\n\n        return rotation_A, rotation_B, origin_A, origin_B, original_shape\n\n\n    def compute_parameters(self, rotation_A, rotation_B, origin_A, origin_B):\n        \"\"\"Calculate the parameters between each base pair and mean reference frames.\n        See chapter 2: Kinematics of rigid base and rigid base pair models of DNA\n        Of Thesis: \"A DNA Coarse-Grain Rigid Base Model and Parameter Estimation from Molecular Dynamics Simulations\" by Daiva Petkevi\u010di\u016bt\u0117\n\n        Rotations contain rotation matrices of shape (n, 3, 3) and origins contain the origins of shape (n, 3).\n\n        Returns:\n        --------\n        rigid_parameters : ndarray\n            The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.\n        trans_mid : ndarray\n            The mean translational vector of shape (n, 3) between the triads.\n        rotation_mid : ndarray\n            The mean rotation matrix of shape (n, 3, 3) between the triads.\n        \"\"\"\n\n        # Linear interpolation of translations\n        trans_mid = 0.5 * (origin_A + origin_B)\n\n        # Relative translation\n        trans_AB = origin_A - origin_B\n\n        # Get relative rotation matrix of base pair\n        rotation_BA = rotation_B.transpose(0,2,1) @ rotation_A  # returns shape (n, 3, 3)\n\n        # Get rotation angles based on  rotation matrices\n        rotation_angle_BA = RigidBody.extract_omega_values(rotation_BA)\n\n        # Compute halfway rotation matrix and triad (mid frame)\n        rotation_halfway = RigidBody.get_rotation_matrix(rotation_angle_BA * 0.5)\n\n        # Get rotation matrix of base pair (aka mean rotation frame)\n        rotation_mid = rotation_B @ rotation_halfway \n\n        # Get transaltional coordinate vector and convert to angstroms\n        translational_parameters = np.einsum('ijk,ik-&gt;ij',rotation_mid.transpose(0,2,1), trans_AB) * 10\n\n        # Get rotational parameters and convert to degrees\n        rotational_parameters = np.rad2deg(np.einsum('ijk,ik-&gt;ij', rotation_BA.transpose(0,2,1), rotation_angle_BA))\n\n        # Merge translational and rotational parameters\n        rigid_parameters = np.hstack((translational_parameters, rotational_parameters))\n\n        # Return the parameters and the mean reference frame\n        return rigid_parameters, trans_mid, rotation_mid\n\n\n    def calculate_parameters(self,frames_A, frames_B, is_step=False):\n        \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n        Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads.\n        The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame.\n        With the order of the vectors being: b_R, b_L, b_D, b_N.\n\n        Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.\n\n\n        Returns:\n        --------\n        params : ndarray\n            The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.\n        mean_reference_frames : ndarray\n            The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.\"\"\"\n\n        # Reshape frames\n        rotation_A, rotation_B, origin_A, origin_B, original_shape = self.reshape_input(frames_A,frames_B, is_step=is_step)\n\n        # Compute parameters\n        if not is_step:\n            # Flip from row to column representation of the rotation matrices\n            rotation_A = rotation_A.transpose(0,2,1)\n            rotation_B = rotation_B.transpose(0,2,1)\n            params, mean_origin, mean_rotation = self.compute_parameters(rotation_A, rotation_B, origin_A, origin_B)\n        else:\n            # Switch the input of the B and A triads to get the correct parameters\n            params, mean_origin, mean_rotation = self.compute_parameters(rotation_B, rotation_A, origin_B, origin_A)\n\n        # Reshape the parameters to the original shape\n        params = params.reshape(original_shape[0], original_shape[1], 6).swapaxes(0, 1)\n\n        # Collect mean reference frames from mid frames of each base pair\n        mean_reference_frames = np.hstack((mean_origin[:, np.newaxis, :],mean_rotation)).reshape(original_shape)\n\n        if is_step:\n            # Creating an array of zeros with shape (10000, 1, 6)\n            extra_column = np.zeros((params.shape[0], 1, 6))\n\n            # Concatenating the existing array and the extra column along the second axis\n            params = np.concatenate((extra_column,params), axis=1)\n\n        # Return the parameters and the mean reference frames\n        return  params, mean_reference_frames if not is_step else params\n\n\n    def analyse_frames(self):\n        \"\"\"Analyze the trajectory and compute parameters.\"\"\"\n\n        # Get base reference frames for each residue\n        frames_A = np.array([self.base_frames[res] for res in self.res_A])\n        frames_B = np.array([self.base_frames[res] for res in self.res_B])\n\n        # Compute parameters between each base pair and mean reference frames\n        self.bp_params, self.mean_reference_frames = self.calculate_parameters(frames_A, frames_B)\n\n        # Extract mean reference frames for each neighboring base pair\n        B1_triads = self.mean_reference_frames[:-1] # select all but the last frame\n        B2_triads = self.mean_reference_frames[1:] # select all but the first frame\n\n        # Compute parameters between each base pair and mean reference frames\n        self.step_params = self.calculate_parameters(B1_triads, B2_triads, is_step=True)[0]\n\n        # Store mean reference frame / aka base pair triads as frames and transpose rotation matrices back to row wise\n        self.frames = self.mean_reference_frames\n        self.frames[:, :, 1:, :] = np.transpose(self.frames[:, :, 1:, :], axes=(0, 1, 3, 2))\n        self._clean_parameters()\n\n    def _clean_parameters(self):\n        \"\"\"Clean the parameters by removing the first and last frame.\"\"\"\n        self.step_parameter_names = ['shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n        self.base_parameter_names = ['shear', 'stretch', 'stagger', 'buckle', 'propeller', 'opening']\n        self.names = self.base_parameter_names + self.step_parameter_names\n        self.parameters = np.dstack((self.bp_params, self.step_params))\n\n    def get_parameters(self,step=False,base=False):\n        \"\"\"Return the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n        if step and not base:\n            return self.step_params, self.step_parameter_names\n        elif base and not step:\n            return self.bp_params, self.base_parameter_names\n        elif not step and not base:\n            return self.parameters, self.names\n\n    def get_parameter(self,name='twist'):\n        \"\"\"Get the parameter of the DNA structure\n        Args:\n            name: str\n                parameter name\n        Returns:\n            parameter: ndarray\n                parameter in shape (n_frames, n_base_pairs)\"\"\"\n\n        if name not in self.names:\n            raise ValueError(f\"Parameter {name} not found.\")\n        return self.parameters[:,:,self.names.index(name)]\n\n\n    def plot_parameters(self, fig=None, ax=None, mean=True, std=True,figsize=[10,3.5], save=False,step=True,base=True,base_color='cornflowerblue',step_color='coral'):\n        \"\"\"Plot the rigid base parameters of the DNA structure\n        Args:\n            fig: figure\n            ax: axis\n            mean: plot mean\n            std: plot standard deviation\n            figsize: figure size\n            save: save figure\n        Returns:\n            figure, axis\"\"\"\n\n        import matplotlib.pyplot as plt\n\n        cols = step + base\n\n        if fig is None and ax is None:\n            fig,ax = plt.subplots(cols,6, figsize=[12,2*cols])\n            ax = ax.flatten()\n        if step and not base:\n            names = self.step_parameter_names\n        elif base and not step:\n            names = self.base_parameter_names\n        elif base and step:\n            names = self.names\n\n        for _,name in enumerate(names):\n            if name in self.step_parameter_names:\n                color = step_color\n            else:\n                color = base_color\n            para = self.get_parameter(name)\n            mean = np.mean(para, axis=0)\n            std = np.std(para, axis=0)\n            x = range(len(mean))\n            #ax[_].errorbar(x,mean, yerr=std, fmt='-', color=color)\n            ax[_].fill_between(x, mean-std, mean+std, color=color, alpha=0.2)\n            ax[_].plot(mean, color=color,lw=1)    \n            ax[_].scatter(x=x,y=mean,color=color,s=10)\n            ax[_].set_title(name)\n\n        fig.tight_layout()\n        if save:\n            fig.savefig('parameters.png')\n        return fig, ax \n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.__init__","title":"<code>__init__(traj, chainids=[0, 1], frames_only=False)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>_type_</code> <p>description</p> required <code>chainids</code> <code>list</code> <p>description. Defaults to [0,1].</p> <code>[0, 1]</code> <code>frames_only</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> Source code in <code>pymdna/geometry.py</code> <pre><code>def __init__(self, traj, chainids=[0,1],frames_only=False):\n    \"\"\"_summary_\n\n    Args:\n        traj (_type_): _description_\n        chainids (list, optional): _description_. Defaults to [0,1].\n        frames_only (bool, optional): _description_. Defaults to False.\n    \"\"\"\n    self.traj = traj\n    self.top = traj.topology\n    self.res_A = self.get_residues(chain_index=chainids[0], reverse=False)\n    self.res_B = self.get_residues(chain_index=chainids[1], reverse=True)\n    self.mean_reference_frames = np.empty((len(self.res_A), 1, 4, 3))\n    self.base_frames = self.get_base_reference_frames()\n    self.analyse_frames()\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.analyse_frames","title":"<code>analyse_frames()</code>","text":"<p>Analyze the trajectory and compute parameters.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def analyse_frames(self):\n    \"\"\"Analyze the trajectory and compute parameters.\"\"\"\n\n    # Get base reference frames for each residue\n    frames_A = np.array([self.base_frames[res] for res in self.res_A])\n    frames_B = np.array([self.base_frames[res] for res in self.res_B])\n\n    # Compute parameters between each base pair and mean reference frames\n    self.bp_params, self.mean_reference_frames = self.calculate_parameters(frames_A, frames_B)\n\n    # Extract mean reference frames for each neighboring base pair\n    B1_triads = self.mean_reference_frames[:-1] # select all but the last frame\n    B2_triads = self.mean_reference_frames[1:] # select all but the first frame\n\n    # Compute parameters between each base pair and mean reference frames\n    self.step_params = self.calculate_parameters(B1_triads, B2_triads, is_step=True)[0]\n\n    # Store mean reference frame / aka base pair triads as frames and transpose rotation matrices back to row wise\n    self.frames = self.mean_reference_frames\n    self.frames[:, :, 1:, :] = np.transpose(self.frames[:, :, 1:, :], axes=(0, 1, 3, 2))\n    self._clean_parameters()\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.calculate_parameters","title":"<code>calculate_parameters(frames_A, frames_B, is_step=False)</code>","text":"<p>Calculate the parameters between each base pair and mean reference frames.</p> <p>Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads. The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame. With the order of the vectors being: b_R, b_L, b_D, b_N.</p> <p>Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.</p>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.calculate_parameters--returns","title":"Returns:","text":"<p>params : ndarray     The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair. mean_reference_frames : ndarray     The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def calculate_parameters(self,frames_A, frames_B, is_step=False):\n    \"\"\"Calculate the parameters between each base pair and mean reference frames.\n\n    Assumes frames are of shape (n_frames, n_residues, 4, 3) where the last two dimensions are the base triads.\n    The base triads consist of an origin (first index) and three vectors (latter 3 indices) representing the base frame.\n    With the order of the vectors being: b_R, b_L, b_D, b_N.\n\n    Note the vectors are stored rowwise in the base triads, and not the usual column representation of the rotation matrices.\n\n\n    Returns:\n    --------\n    params : ndarray\n        The parameters of shape (n_frames, n_residues, 6) representing the relative translation and rotation between each base pair.\n    mean_reference_frames : ndarray\n        The mean reference frames of shape (n_bp, n_frames, 4, 3) representing the mean reference frame of each base pair.\"\"\"\n\n    # Reshape frames\n    rotation_A, rotation_B, origin_A, origin_B, original_shape = self.reshape_input(frames_A,frames_B, is_step=is_step)\n\n    # Compute parameters\n    if not is_step:\n        # Flip from row to column representation of the rotation matrices\n        rotation_A = rotation_A.transpose(0,2,1)\n        rotation_B = rotation_B.transpose(0,2,1)\n        params, mean_origin, mean_rotation = self.compute_parameters(rotation_A, rotation_B, origin_A, origin_B)\n    else:\n        # Switch the input of the B and A triads to get the correct parameters\n        params, mean_origin, mean_rotation = self.compute_parameters(rotation_B, rotation_A, origin_B, origin_A)\n\n    # Reshape the parameters to the original shape\n    params = params.reshape(original_shape[0], original_shape[1], 6).swapaxes(0, 1)\n\n    # Collect mean reference frames from mid frames of each base pair\n    mean_reference_frames = np.hstack((mean_origin[:, np.newaxis, :],mean_rotation)).reshape(original_shape)\n\n    if is_step:\n        # Creating an array of zeros with shape (10000, 1, 6)\n        extra_column = np.zeros((params.shape[0], 1, 6))\n\n        # Concatenating the existing array and the extra column along the second axis\n        params = np.concatenate((extra_column,params), axis=1)\n\n    # Return the parameters and the mean reference frames\n    return  params, mean_reference_frames if not is_step else params\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.compute_parameters","title":"<code>compute_parameters(rotation_A, rotation_B, origin_A, origin_B)</code>","text":"<p>Calculate the parameters between each base pair and mean reference frames. See chapter 2: Kinematics of rigid base and rigid base pair models of DNA Of Thesis: \"A DNA Coarse-Grain Rigid Base Model and Parameter Estimation from Molecular Dynamics Simulations\" by Daiva Petkevi\u010di\u016bt\u0117</p> <p>Rotations contain rotation matrices of shape (n, 3, 3) and origins contain the origins of shape (n, 3).</p>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.compute_parameters--returns","title":"Returns:","text":"<p>rigid_parameters : ndarray     The parameters of shape (n, 12) representing the relative translation and rotation between each base pair. trans_mid : ndarray     The mean translational vector of shape (n, 3) between the triads. rotation_mid : ndarray     The mean rotation matrix of shape (n, 3, 3) between the triads.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def compute_parameters(self, rotation_A, rotation_B, origin_A, origin_B):\n    \"\"\"Calculate the parameters between each base pair and mean reference frames.\n    See chapter 2: Kinematics of rigid base and rigid base pair models of DNA\n    Of Thesis: \"A DNA Coarse-Grain Rigid Base Model and Parameter Estimation from Molecular Dynamics Simulations\" by Daiva Petkevi\u010di\u016bt\u0117\n\n    Rotations contain rotation matrices of shape (n, 3, 3) and origins contain the origins of shape (n, 3).\n\n    Returns:\n    --------\n    rigid_parameters : ndarray\n        The parameters of shape (n, 12) representing the relative translation and rotation between each base pair.\n    trans_mid : ndarray\n        The mean translational vector of shape (n, 3) between the triads.\n    rotation_mid : ndarray\n        The mean rotation matrix of shape (n, 3, 3) between the triads.\n    \"\"\"\n\n    # Linear interpolation of translations\n    trans_mid = 0.5 * (origin_A + origin_B)\n\n    # Relative translation\n    trans_AB = origin_A - origin_B\n\n    # Get relative rotation matrix of base pair\n    rotation_BA = rotation_B.transpose(0,2,1) @ rotation_A  # returns shape (n, 3, 3)\n\n    # Get rotation angles based on  rotation matrices\n    rotation_angle_BA = RigidBody.extract_omega_values(rotation_BA)\n\n    # Compute halfway rotation matrix and triad (mid frame)\n    rotation_halfway = RigidBody.get_rotation_matrix(rotation_angle_BA * 0.5)\n\n    # Get rotation matrix of base pair (aka mean rotation frame)\n    rotation_mid = rotation_B @ rotation_halfway \n\n    # Get transaltional coordinate vector and convert to angstroms\n    translational_parameters = np.einsum('ijk,ik-&gt;ij',rotation_mid.transpose(0,2,1), trans_AB) * 10\n\n    # Get rotational parameters and convert to degrees\n    rotational_parameters = np.rad2deg(np.einsum('ijk,ik-&gt;ij', rotation_BA.transpose(0,2,1), rotation_angle_BA))\n\n    # Merge translational and rotational parameters\n    rigid_parameters = np.hstack((translational_parameters, rotational_parameters))\n\n    # Return the parameters and the mean reference frame\n    return rigid_parameters, trans_mid, rotation_mid\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.get_base_reference_frames","title":"<code>get_base_reference_frames()</code>","text":"<p>Get reference frames for each residue.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def get_base_reference_frames(self):\n    \"\"\"Get reference frames for each residue.\"\"\"\n    reference_frames = {} # Dictionary to store the base vectors for each residue\n    for res in self.res_A + self.res_B:\n        res_traj = self.traj.atom_slice([at.index for at in res.atoms])\n        base_vectors = self.get_base_vectors(res_traj)\n        reference_frames[res] = base_vectors # Store the base vectors for the residue index (with shape (4, n_frames, 3))\n    return reference_frames\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.get_base_vectors","title":"<code>get_base_vectors(res)</code>","text":"<p>Compute base vectors from reference base.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def get_base_vectors(self, res):\n    \"\"\"Compute base vectors from reference base.\"\"\"\n    ref_base = ReferenceBase(res)\n    return np.array([ref_base.b_R, ref_base.b_L, ref_base.b_D, ref_base.b_N]).swapaxes(0,1)\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.get_parameter","title":"<code>get_parameter(name='twist')</code>","text":"<p>Get the parameter of the DNA structure Args:     name: str         parameter name Returns:     parameter: ndarray         parameter in shape (n_frames, n_base_pairs)</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def get_parameter(self,name='twist'):\n    \"\"\"Get the parameter of the DNA structure\n    Args:\n        name: str\n            parameter name\n    Returns:\n        parameter: ndarray\n            parameter in shape (n_frames, n_base_pairs)\"\"\"\n\n    if name not in self.names:\n        raise ValueError(f\"Parameter {name} not found.\")\n    return self.parameters[:,:,self.names.index(name)]\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.get_parameters","title":"<code>get_parameters(step=False, base=False)</code>","text":"<p>Return the computed parameters of shape (n_frames, n_base_pairs, n_parameters)</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def get_parameters(self,step=False,base=False):\n    \"\"\"Return the computed parameters of shape (n_frames, n_base_pairs, n_parameters)\"\"\"\n    if step and not base:\n        return self.step_params, self.step_parameter_names\n    elif base and not step:\n        return self.bp_params, self.base_parameter_names\n    elif not step and not base:\n        return self.parameters, self.names\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.get_residues","title":"<code>get_residues(chain_index, reverse=False)</code>","text":"<p>Get residues from specified chain.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def get_residues(self, chain_index, reverse=False):\n    \"\"\"Get residues from specified chain.\"\"\"\n    if chain_index &gt;= len(self.top._chains):\n        raise IndexError(\"Chain index out of range.\")\n    chain = self.top._chains[chain_index]\n    residues = chain._residues\n    return list(reversed(residues)) if reverse else residues\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.load_reference_bases","title":"<code>load_reference_bases()</code>","text":"<p>Load reference bases from local files.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def load_reference_bases(self):\n    \"\"\"Load reference bases from local files.\"\"\"\n    # Not used at the moment??\n    bases = ['C', 'G', 'T', 'A']\n    #return {f'D{base}': md.load_pdb(get_data_file_path(f'./atomic/NDB96_{base}.pdb')) for base in bases}\n    return {f'D{base}': md.load_hdf5(get_data_file_path(f'./atomic/bases/BDNA_{base}.h5')) for base in bases}\n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.plot_parameters","title":"<code>plot_parameters(fig=None, ax=None, mean=True, std=True, figsize=[10, 3.5], save=False, step=True, base=True, base_color='cornflowerblue', step_color='coral')</code>","text":"<p>Plot the rigid base parameters of the DNA structure Args:     fig: figure     ax: axis     mean: plot mean     std: plot standard deviation     figsize: figure size     save: save figure Returns:     figure, axis</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def plot_parameters(self, fig=None, ax=None, mean=True, std=True,figsize=[10,3.5], save=False,step=True,base=True,base_color='cornflowerblue',step_color='coral'):\n    \"\"\"Plot the rigid base parameters of the DNA structure\n    Args:\n        fig: figure\n        ax: axis\n        mean: plot mean\n        std: plot standard deviation\n        figsize: figure size\n        save: save figure\n    Returns:\n        figure, axis\"\"\"\n\n    import matplotlib.pyplot as plt\n\n    cols = step + base\n\n    if fig is None and ax is None:\n        fig,ax = plt.subplots(cols,6, figsize=[12,2*cols])\n        ax = ax.flatten()\n    if step and not base:\n        names = self.step_parameter_names\n    elif base and not step:\n        names = self.base_parameter_names\n    elif base and step:\n        names = self.names\n\n    for _,name in enumerate(names):\n        if name in self.step_parameter_names:\n            color = step_color\n        else:\n            color = base_color\n        para = self.get_parameter(name)\n        mean = np.mean(para, axis=0)\n        std = np.std(para, axis=0)\n        x = range(len(mean))\n        #ax[_].errorbar(x,mean, yerr=std, fmt='-', color=color)\n        ax[_].fill_between(x, mean-std, mean+std, color=color, alpha=0.2)\n        ax[_].plot(mean, color=color,lw=1)    \n        ax[_].scatter(x=x,y=mean,color=color,s=10)\n        ax[_].set_title(name)\n\n    fig.tight_layout()\n    if save:\n        fig.savefig('parameters.png')\n    return fig, ax \n</code></pre>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.reshape_input","title":"<code>reshape_input(input_A, input_B, is_step=False)</code>","text":"<p>This function reshapes the input to the correct format for the calculations.  And splits the input into rotation matrices and origins for the calculations.</p>"},{"location":"geometry-reference/#pymdna.geometry.NucleicFrames.reshape_input--returns","title":"Returns:","text":"<p>rotation_A/rotation_B : ndarray     The rotation matrices of shape (n, 3, 3) for the first triad. origin_A/origin_B : ndarray     The origins of shape (n, 3) for the first triad. original_shape : tuple     The original shape of the input.</p> Source code in <code>pymdna/geometry.py</code> <pre><code>def reshape_input(self,input_A,input_B,is_step=False):\n\n    \"\"\"This function reshapes the input to the correct format for the calculations. \n    And splits the input into rotation matrices and origins for the calculations.\n\n    Returns:\n    --------\n    rotation_A/rotation_B : ndarray\n        The rotation matrices of shape (n, 3, 3) for the first triad.\n    origin_A/origin_B : ndarray\n        The origins of shape (n, 3) for the first triad.\n    original_shape : tuple\n        The original shape of the input.\"\"\"\n\n    # Store original shape\n    original_shape = input_A.shape\n\n    # Flatten frames to compute rotation matrices for each time step simultaneously\n    input_A_ = input_A.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n    input_B_ = input_B.reshape(-1,original_shape[-2],original_shape[-1])  # shape (n, 4, 3)\n\n    # Extract the triads without origin (rotation matrices)\n    rotation_A = input_A_[:,1:]  # shape (n, 3, 3)\n    rotation_B = input_B_[:,1:]  # shape (n, 3, 3)\n\n    if not is_step:\n        # flip (connecting the backbones) and the (baseplane normals).\n        # so the second and third vector b_L, b_N\n        rotation_B[:,[1,2]] *= -1\n\n    # Extract origins of triads\n    origin_A = input_A_[:,0]  # shape (n, 3)\n    origin_B = input_B_[:,0]  # shape (n, 3)\n\n    return rotation_A, rotation_B, origin_A, origin_B, original_shape\n</code></pre>"},{"location":"how-to-guides/","title":"How-To Guides","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"how-to-guides/#how-to-add-two-numbers","title":"How To Add Two Numbers?","text":"<p>You have two numbers and you need to add them together. You're in luck! The <code>calculator</code> package can help you get this done.</p> <p>Download the code from this GitHub repository and place the <code>calculator/</code> folder in the same directory as your Python script:</p> <pre><code>your_project/\n\u2502\n\u251c\u2500\u2500 calculator/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 calculations.py\n\u2502\n\u2514\u2500\u2500 your_script.py\n</code></pre> <p>Inside of <code>your_script.py</code> you can now import the <code>add()</code> function from the <code>calculator.calculations</code> module:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n</code></pre> <p>After you've imported the function, you can use it to add any two numbers that you need to add:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n\nprint(add(20, 22))  # OUTPUT: 42.0\n</code></pre> <p>You're now able to add any two numbers, and you'll always get a <code>float</code> as a result.</p>"},{"location":"modules-analyse/","title":"Analysis Modules","text":""},{"location":"modules-analyse/#rigid-base-parameters","title":"Rigid Base Parameters","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The traj argument must be provided.</li> <li>The chainids argument is optional and defaults to [0, 1].</li> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1]):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The traj argument must be provided.\n        - The chainids argument is optional and defaults to [0, 1].\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        # Compute the rigid base parameters of a DNA structure\n        traj = md.load('dna.pdb')\n        rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])\"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids)\n</code></pre>"},{"location":"modules-analyse/#pymdna.nucleic.compute_rigid_parameters--compute-the-rigid-base-parameters-of-a-dna-structure","title":"Compute the rigid base parameters of a DNA structure","text":"<p>traj = md.load('dna.pdb') rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])</p>"},{"location":"modules-analyse/#linking-number","title":"Linking Number","text":"<p>Compute the linking number of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_linking_number(traj, chainids=[0,1]):\n    \"\"\"Compute the linking number of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules-analyse/#curvature","title":"Curvature","text":"<p>Compute the curvature of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_curvature(traj, chainids=[0,1]):\n    \"\"\"Compute the curvature of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules-analyse/#groove-widths","title":"Groove Widths","text":"<p>Compute the groove width of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_groove_width(traj, chainids=[0,1]):\n    \"\"\"Compute the groove width of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules-build/","title":"Build","text":""},{"location":"modules-build/#generate-dna-structure","title":"Generate DNA structure","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>If control_points are provided, the sequence argument is ignored.</li> <li>If sequence is provided, the control_points argument is ignored.</li> <li>If circular is True, the DNA structure will be closed.</li> <li>If circular is False, the DNA structure will be open.</li> <li>The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.</li> </ul> Source code in <code>pymdna/nucleic.py</code> <pre><code>def make(sequence: str = None, control_points: np.ndarray = None, circular : bool = False, closed: bool = False, n_bp : int = None, dLk : int = None):\n    \"\"\"Generate a DNA structure from a given DNA sequence and control points.\n\n    Args:\n        sequence (str, optional): DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)\n        control_points (ndarray, optional): Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)\n        closed (bool, optional): Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)\n        n_bp (int, optional): Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)\n        dLk (int, optional): Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - If control_points are provided, the sequence argument is ignored.\n        - If sequence is provided, the control_points argument is ignored.\n        - If circular is True, the DNA structure will be closed.\n        - If circular is False, the DNA structure will be open.\n        - The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.\n    \"\"\"\n\n    # Check if control points are provided, otherwise generate a straight line\n    if control_points is not None:\n        if len(control_points) &lt; 4:\n            raise ValueError('Control points should contain at least 4 points [x, y, z]')\n        elif len(control_points) &gt; 4 and n_bp is None:\n            n_bp = len(control_points)  # Number of base pairs\n    elif control_points is None and circular:\n        control_points = Shapes.circle(radius=1)\n        closed = True\n    else:\n        # Linear strand of control points\n        control_points = Shapes.line(length=1)\n\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n    spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    return Nucleic(sequence=sequence, n_bp=n_bp, frames=spline.frames, chainids=[0, 1], circular=circular)\n</code></pre>"},{"location":"modules-build/#extend-dna-structure","title":"Extend DNA structure","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> <li>If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.</li> <li>If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.</li> <li>If the shape is not provided, a straight line shape will be used for extension.</li> <li>If the DNA structure is not in the form of frames, it will be converted to frames before extension.</li> <li>If minimize is set to True, the new DNA structure will be minimized after extension.</li> </ul> Example <p>nuc = Nucleic() nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int, sequence: str = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure.\n        sequence (str, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n        - If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.\n        - If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.\n        - If the shape is not provided, a straight line shape will be used for extension.\n        - If the DNA structure is not in the form of frames, it will be converted to frames before extension.\n        - If minimize is set to True, the new DNA structure will be minimized after extension.\n\n    Example:\n        &gt;&gt;&gt; nuc = Nucleic()\n        &gt;&gt;&gt; nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')\n    if not n_bp and not fixed_endpoints:\n        raise ValueError(\"Either a fixed endpoint or a length must be specified for extension.\")    \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"modules-build/#connect-two-dna-strands","title":"Connect two DNA strands","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Note: The minimization does not use excluded volume interactions by default. This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def connect(Nucleic0, Nucleic1, sequence: str = None, n_bp: int = None, leader: int = 0, frame: int = -1, margin: int = 1, minimize: bool = True, exvol_rad: float = 0.0, temperature: int = 300):\n    \"\"\"Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.\n\n    The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure.\n    To connect the two strands, a straight line is interpolated between the two ends,\n    and the optimal number of base pairs is distributed to achieve a neutral twist.\n\n    Note:\n    The minimization does not use excluded volume interactions by default.\n    This is because the excluded volume interactions require the EV beads to have no overlap.\n    However, in the initial configuration, the EV beads are likely to have overlap.\n    If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.\n\n    Args:\n        Nucleic0 (Nucleic): First DNA structure to connect.\n        Nucleic1 (Nucleic): Second DNA structure to connect.\n        sequence (str, optional): DNA sequence of the connecting DNA strand. Default is None.\n        n_bp (int, optional): Number of base pairs of the connecting DNA strand. Default is None.\n        leader (int, optional): The leader of the DNA structure to connect. Default is 0.\n        frame (int, optional): The time frame to connect. Default is -1.\n        margin (int, optional): Number of base pairs to fix at the end. Default is 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure. Default is True.\n        exvol_rad (float, optional): Radius for excluded volume interactions during minimization. Default is 0.0.\n        temperature (int, optional): Temperature for minimization. Default is 300.\n\n    Returns:\n        Nucleic (object): DNA structure with the two DNA structures connected.\n\n    Raises:\n        ValueError: If either of the DNA structures is circular.\n\n    Example:\n        # Connect two DNA structures\n        connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)\n    \"\"\"\n    if Nucleic0.circular or Nucleic1.circular:\n        raise ValueError('Cannot connect circular DNA structures')\n\n    if sequence is not None and n_bp is None:\n        n_bp = len(sequence)\n\n    # Connect the two DNA structures\n    connector = Connector(Nucleic0, Nucleic1, sequence=sequence, n_bp=n_bp, leader=leader, frame=frame, margin=margin)\n    if minimize:\n        connector.connected_nuc.minimize(exvol_rad=exvol_rad, temperature=temperature, fixed=connector.fixed)\n    return connector.connected_nuc\n</code></pre>"},{"location":"modules-build/#pymdna.nucleic.connect--connect-two-dna-structures","title":"Connect two DNA structures","text":"<p>connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)</p>"},{"location":"modules-modify/","title":"Modify","text":""},{"location":"modules-modify/#mutate-dna-sequence","title":"Mutate DNA sequence","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> <p>Examples:</p>"},{"location":"modules-modify/#pymdna.nucleic.Nucleic.mutate--create-a-dna-object","title":"Create a DNA object","text":"<p>dna = DNA()</p>"},{"location":"modules-modify/#pymdna.nucleic.Nucleic.mutate--mutate-the-dna-trajectory","title":"Mutate the DNA trajectory","text":"<p>mutations = {0: 'A', 1: 'T', 2: 'G'} dna.mutate(mutations=mutations, complementary=True, frame=-1)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Examples:\n        # Create a DNA object\n        dna = DNA()\n\n        # Mutate the DNA trajectory\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"modules-modify/#methylation-of-nucleobase","title":"Methylation of Nucleobase","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <ul> <li>If the DNA structure is not loaded, a ValueError will be raised.</li> <li>If the methylations list is empty, a ValueError will be raised.</li> </ul> Example <p>nuc = Nucleic() nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            - If the DNA structure is not loaded, a ValueError will be raised.\n            - If the methylations list is empty, a ValueError will be raised.\n\n        Example:\n            &gt;&gt;&gt; nuc = Nucleic()\n            &gt;&gt;&gt; nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)\n        \"\"\"\n        if self.traj is None:\n            raise ValueError('DNA structure is not loaded')\n        if len(methylations) == 0:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre>"},{"location":"modules-modify/#flip-of-nucleobase-in-hoogsteen-fashion","title":"Flip of Nucleobase in Hoogsteen Fashion","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <p>This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping. The <code>fliplist</code> parameter specifies the base pairs to flip. If no <code>fliplist</code> is provided, a <code>ValueError</code> is raised. The <code>deg</code> parameter specifies the degrees to flip. By default, it is set to 180 degrees. The <code>frame</code> parameter specifies the frame to flip. By default, it is set to -1.</p> Example <p>dna = Nucleic() dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping.\n            The `fliplist` parameter specifies the base pairs to flip. If no `fliplist` is provided, a `ValueError` is raised.\n            The `deg` parameter specifies the degrees to flip. By default, it is set to 180 degrees.\n            The `frame` parameter specifies the frame to flip. By default, it is set to -1.\n\n        Example:\n            &gt;&gt;&gt; dna = Nucleic()\n            &gt;&gt;&gt; dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"modules/","title":"Reference","text":""},{"location":"modules/#build","title":"Build","text":""},{"location":"modules/#make","title":"Make","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>If control_points are provided, the sequence argument is ignored.</li> <li>If sequence is provided, the control_points argument is ignored.</li> <li>If circular is True, the DNA structure will be closed.</li> <li>If circular is False, the DNA structure will be open.</li> <li>The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.</li> </ul> Source code in <code>pymdna/nucleic.py</code> <pre><code>def make(sequence: str = None, control_points: np.ndarray = None, circular : bool = False, closed: bool = False, n_bp : int = None, dLk : int = None):\n    \"\"\"Generate a DNA structure from a given DNA sequence and control points.\n\n    Args:\n        sequence (str, optional): DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)\n        control_points (ndarray, optional): Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)\n        closed (bool, optional): Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)\n        n_bp (int, optional): Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)\n        dLk (int, optional): Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - If control_points are provided, the sequence argument is ignored.\n        - If sequence is provided, the control_points argument is ignored.\n        - If circular is True, the DNA structure will be closed.\n        - If circular is False, the DNA structure will be open.\n        - The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.\n    \"\"\"\n\n    # Check if control points are provided, otherwise generate a straight line\n    if control_points is not None:\n        if len(control_points) &lt; 4:\n            raise ValueError('Control points should contain at least 4 points [x, y, z]')\n        elif len(control_points) &gt; 4 and n_bp is None:\n            n_bp = len(control_points)  # Number of base pairs\n    elif control_points is None and circular:\n        control_points = Shapes.circle(radius=1)\n        closed = True\n    else:\n        # Linear strand of control points\n        control_points = Shapes.line(length=1)\n\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n    spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    return Nucleic(sequence=sequence, n_bp=n_bp, frames=spline.frames, chainids=[0, 1], circular=circular)\n</code></pre>"},{"location":"modules/#extend","title":"Extend","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> <li>If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.</li> <li>If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.</li> <li>If the shape is not provided, a straight line shape will be used for extension.</li> <li>If the DNA structure is not in the form of frames, it will be converted to frames before extension.</li> <li>If minimize is set to True, the new DNA structure will be minimized after extension.</li> </ul> Example <p>nuc = Nucleic() nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int, sequence: str = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure.\n        sequence (str, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n        - If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.\n        - If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.\n        - If the shape is not provided, a straight line shape will be used for extension.\n        - If the DNA structure is not in the form of frames, it will be converted to frames before extension.\n        - If minimize is set to True, the new DNA structure will be minimized after extension.\n\n    Example:\n        &gt;&gt;&gt; nuc = Nucleic()\n        &gt;&gt;&gt; nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')\n    if not n_bp and not fixed_endpoints:\n        raise ValueError(\"Either a fixed endpoint or a length must be specified for extension.\")    \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"modules/#connect","title":"Connect","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Note: The minimization does not use excluded volume interactions by default. This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def connect(Nucleic0, Nucleic1, sequence: str = None, n_bp: int = None, leader: int = 0, frame: int = -1, margin: int = 1, minimize: bool = True, exvol_rad: float = 0.0, temperature: int = 300):\n    \"\"\"Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.\n\n    The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure.\n    To connect the two strands, a straight line is interpolated between the two ends,\n    and the optimal number of base pairs is distributed to achieve a neutral twist.\n\n    Note:\n    The minimization does not use excluded volume interactions by default.\n    This is because the excluded volume interactions require the EV beads to have no overlap.\n    However, in the initial configuration, the EV beads are likely to have overlap.\n    If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.\n\n    Args:\n        Nucleic0 (Nucleic): First DNA structure to connect.\n        Nucleic1 (Nucleic): Second DNA structure to connect.\n        sequence (str, optional): DNA sequence of the connecting DNA strand. Default is None.\n        n_bp (int, optional): Number of base pairs of the connecting DNA strand. Default is None.\n        leader (int, optional): The leader of the DNA structure to connect. Default is 0.\n        frame (int, optional): The time frame to connect. Default is -1.\n        margin (int, optional): Number of base pairs to fix at the end. Default is 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure. Default is True.\n        exvol_rad (float, optional): Radius for excluded volume interactions during minimization. Default is 0.0.\n        temperature (int, optional): Temperature for minimization. Default is 300.\n\n    Returns:\n        Nucleic (object): DNA structure with the two DNA structures connected.\n\n    Raises:\n        ValueError: If either of the DNA structures is circular.\n\n    Example:\n        # Connect two DNA structures\n        connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)\n    \"\"\"\n    if Nucleic0.circular or Nucleic1.circular:\n        raise ValueError('Cannot connect circular DNA structures')\n\n    if sequence is not None and n_bp is None:\n        n_bp = len(sequence)\n\n    # Connect the two DNA structures\n    connector = Connector(Nucleic0, Nucleic1, sequence=sequence, n_bp=n_bp, leader=leader, frame=frame, margin=margin)\n    if minimize:\n        connector.connected_nuc.minimize(exvol_rad=exvol_rad, temperature=temperature, fixed=connector.fixed)\n    return connector.connected_nuc\n</code></pre>"},{"location":"modules/#pymdna.nucleic.connect--connect-two-dna-structures","title":"Connect two DNA structures","text":"<p>connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)</p>"},{"location":"modules/#modify","title":"Modify","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> <p>Examples:</p> <p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <ul> <li>If the DNA structure is not loaded, a ValueError will be raised.</li> <li>If the methylations list is empty, a ValueError will be raised.</li> </ul> Example <p>nuc = Nucleic() nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            - If the DNA structure is not loaded, a ValueError will be raised.\n            - If the methylations list is empty, a ValueError will be raised.\n\n        Example:\n            &gt;&gt;&gt; nuc = Nucleic()\n            &gt;&gt;&gt; nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)\n        \"\"\"\n        if self.traj is None:\n            raise ValueError('DNA structure is not loaded')\n        if len(methylations) == 0:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre> <p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <p>This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping. The <code>fliplist</code> parameter specifies the base pairs to flip. If no <code>fliplist</code> is provided, a <code>ValueError</code> is raised. The <code>deg</code> parameter specifies the degrees to flip. By default, it is set to 180 degrees. The <code>frame</code> parameter specifies the frame to flip. By default, it is set to -1.</p> Example <p>dna = Nucleic() dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping.\n            The `fliplist` parameter specifies the base pairs to flip. If no `fliplist` is provided, a `ValueError` is raised.\n            The `deg` parameter specifies the degrees to flip. By default, it is set to 180 degrees.\n            The `frame` parameter specifies the frame to flip. By default, it is set to -1.\n\n        Example:\n            &gt;&gt;&gt; dna = Nucleic()\n            &gt;&gt;&gt; dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"modules/#pymdna.nucleic.Nucleic.mutate--create-a-dna-object","title":"Create a DNA object","text":"<p>dna = DNA()</p>"},{"location":"modules/#pymdna.nucleic.Nucleic.mutate--mutate-the-dna-trajectory","title":"Mutate the DNA trajectory","text":"<p>mutations = {0: 'A', 1: 'T', 2: 'G'} dna.mutate(mutations=mutations, complementary=True, frame=-1)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Examples:\n        # Create a DNA object\n        dna = DNA()\n\n        # Mutate the DNA trajectory\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"modules/#analyse-modules","title":"Analyse Modules","text":""},{"location":"modules/#rigid-base-parameters","title":"Rigid Base Parameters","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The traj argument must be provided.</li> <li>The chainids argument is optional and defaults to [0, 1].</li> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1]):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The traj argument must be provided.\n        - The chainids argument is optional and defaults to [0, 1].\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        # Compute the rigid base parameters of a DNA structure\n        traj = md.load('dna.pdb')\n        rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])\"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids)\n</code></pre>"},{"location":"modules/#pymdna.nucleic.compute_rigid_parameters--compute-the-rigid-base-parameters-of-a-dna-structure","title":"Compute the rigid base parameters of a DNA structure","text":"<p>traj = md.load('dna.pdb') rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])</p>"},{"location":"modules/#linking-number","title":"Linking Number","text":"<p>Compute the linking number of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_linking_number(traj, chainids=[0,1]):\n    \"\"\"Compute the linking number of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#curvature","title":"Curvature","text":"<p>Compute the curvature of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_curvature(traj, chainids=[0,1]):\n    \"\"\"Compute the curvature of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#groove-widths","title":"Groove Widths","text":"<p>Compute the groove width of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_groove_width(traj, chainids=[0,1]):\n    \"\"\"Compute the groove width of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"nucleic-reference/","title":"Nucleic class","text":"<p>Contains mdna DNA structure with reference frames and trajectory</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>class Nucleic:\n\n    \"\"\"Contains mdna DNA structure with reference frames and trajectory\"\"\"\n\n    def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=None, circular=None):\n            \"\"\"Initializes the DNA structure.\n\n            Args:\n                sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n                n_bp (int): The number of base pairs. Default is None.\n                traj (object): The MDTraj trajectory. Default is None.\n                frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n                chainids (list): The chain IDs. Default is None.\n                circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n            Raises:\n                ValueError: If both traj and frames are provided.\n                ValueError: If frames have an invalid shape.\n                ValueError: If the number of base pairs in the sequence and frames do not match.\n                ValueError: If neither traj nor frames are provided.\n\n            Notes:\n                - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n                - If frames is provided, n_bp will be determined from the shape of frames.\n                - If sequence is provided, it will be checked against the number of base pairs.\n\n            Attributes:\n                sequence (str): The DNA sequence.\n                n_bp (int): The number of base pairs.\n                traj (object): The MDTraj trajectory.\n                frames (np.ndarray): The reference frames of the DNA structure.\n                chainids (list): The chain IDs.\n                circular (bool): A flag that indicates if the structure is circular/closed.\n                rigid (None): A container for rigid base parameters class output.\n                minimizer (None): A container for minimizer class output.\n            \"\"\"\n            # Check for trajectory\n            if traj is not None:\n                if frames is not None:\n                    raise ValueError('Provide either a trajectory or reference frames, not both')\n                # Extract sequence from the trajectory\n                sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n                n_bp = len(sequence)\n                frames = None  # Nucleic class will handle extraction from traj\n\n            # Check for reference frames\n            elif frames is not None:\n                if frames.ndim == 3:\n                    # Case (n_bp, 4, 3)\n                    frames = np.expand_dims(frames, axis=1)\n                if frames.ndim != 4:\n                    raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n                n_bp = frames.shape[0]\n                if sequence is not None:\n                    if len(sequence) != n_bp:\n                        raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                    else:\n                        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n            else:\n                raise ValueError('Provide either a trajectory or reference frames')\n\n            self.sequence, self.n_bp = sequence, n_bp\n            self.traj = traj\n            self.frames = frames\n            self.chainids = chainids\n            self.circular = self._is_circular() if circular is None else circular \n            self.rigid = None # Container for rigid base parameters class output\n            self.minimizer = None # Container for minimizer class output\n\n    def describe(self):\n        \"\"\"Print the DNA structure information\"\"\"\n        print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n        print('Sequence:', ''.join(self.sequence))\n\n        if self.traj is not None:\n            print('Trajectory:',self.traj)\n        else:\n            print('Trajectory not loaded')\n\n        if self.frames is not None:\n            print('Frames: ', self.frames.shape)\n        else:\n            print('Frames not loaded')\n\n    def _frames_to_traj(self, frame=-1):\n        \"\"\"Convert reference frames to trajectory\"\"\"\n        if self.frames is None:\n            raise ValueError('Load reference frames first')\n        self.traj = None\n        generator = StructureGenerator(frames=self.frames[:,frame,:,:], sequence=self.sequence, circular=self.circular)\n        self.traj = generator.get_traj()\n\n    def _traj_to_frames(self):\n        \"\"\"Convert trajectory to reference frames\"\"\"\n        if self.traj is None:\n            raise ValueError('Load trajectory first')\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        self.frames =self.rigid.frames\n\n    def get_frames(self):\n        \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n        Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n        where n_frames is the number of frames, n_bp is the number of base pairs, \n        and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n        Returns:\n            frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n        if self.frames is None:\n            self._traj_to_frames()\n        return self.frames\n\n    def get_traj(self):\n        \"\"\"Get the trajectory of the current state of the DNA structure\n        Returns:\n            MDtraj object\"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n\n        if self.traj.n_atoms &gt; 99999:\n            print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n        return self.traj\n\n    def get_rigid_parameters(self):\n        \"\"\"Get the rigid base parameters class object of the DNA structure\n\n        Returns:\n            NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n        if self.rigid is None and self.traj is not None:\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        elif self.rigid is None and self.traj is None:\n            self._frames_to_traj()\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        else:\n            return self.rigid\n\n    def _is_circular(self, frame=0):\n        \"\"\"Detect if the DNA structure is circular for a given chain and frame\n\n        Parameters\n        ----------\n        chainid : int, optional\n            ID of the chain to check, by default 0\n        frame : int, optional\n            Frame index to check, by default 0\n\n        Returns\n        -------\n        bool\n            True if the DNA is circular, False otherwise\n        \"\"\"\n        if self.frames is None:\n            self._traj_to_frames()\n\n        start = self.frames[0,frame,0]\n        end = self.frames[-1,frame,0]\n        distance = np.linalg.norm(start - end)\n\n        # 0.34 nm is roughly the distance between base pairs and 20 is the minimum number of base pairs for circular DNA\n        return distance &lt; 1 and self.frames.shape[0] &gt; 20 \n\n    def _plot_chain(self, ax, traj, chainid, frame, lw=1, markersize=2, color='k'):\n        \"\"\"Plot the DNA structure of a chain\"\"\"\n        phosphor = traj.top.select(f'name P and chainid {chainid}')\n        x = traj.xyz[frame, phosphor, 0]\n        y = traj.xyz[frame, phosphor, 1]\n        z = traj.xyz[frame, phosphor, 2]\n\n        ax.plot(x, y, z, '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n        if self.circular:\n            # Connect the last point to the first point\n            ax.plot([x[-1], x[0]], [y[-1], y[0]], [z[-1], z[0]], '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n    def _plot_helical_axis(self, ax, frame, lw=1):\n        helical_axis = self.frames[:,frame,0]\n        ax.plot(helical_axis[:,0],helical_axis[:,1],helical_axis[:,2],':',c='k',lw=lw*0.7)\n        if self.circular:\n            ax.plot([helical_axis[-1,0],helical_axis[0,0]],[helical_axis[-1,1],helical_axis[0,1]],[helical_axis[-1,2],helical_axis[0,2]],':',c='k',lw=lw*0.7)\n\n    def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey'):\n        \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n        Args:\n            ax (object, optional): Matplotlib axis. Default is None.\n            fig (object, optional): Figure axis. Default is None.\n            save (bool, optional): Save image as png. Default is False.\n            frame (int, optional): Index of trajectory to visualize. Default is -1.\n            markersize (int, optional): Width of backbone plot. Default is 2.\n            lw (int, optional): Line width of plots. Default is 1.\n            helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n            backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n            lead (bool, optional): Plot leading strand. Default is False.\n            anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n            triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n            length (float, optional): Length of triad vectors. Default is 0.23.\n            color_lead (str, optional): Color of the leading strand. Default is 'k'.\n            color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n\n        Notes:\n            - The function draws a 3D representation of the DNA structure using matplotlib.\n            - The DNA structure can include a helical axis, backbone, lead strand, anti-sense strand, and triads.\n            - The function requires either the trajectory or reference frames to be loaded before calling.\n\n        Example:\n            nuc = Nucleic()\n            nuc.load_traj('trajectory.dcd')\n            nuc.draw(ax=plt.gca(), save=True, frame=10, markersize=3, lw=2, helical_axis=True, backbone=True, lead=True, anti=True, triads=True, length=0.2, color_lead='r', color_anti='b')\n        \"\"\"\n\n        # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n        # in shape (time/n_frames, n_bp, 4, 3)\n\n        if self.traj is None:\n            self._frames_to_traj()\n        elif self.frames is None:\n            self._traj_to_frames()\n\n        if fig is None and ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n\n        if backbone:\n            lead = True\n            anti = True\n        if lead:\n            self._plot_chain(ax, self.traj, 0, frame=frame, markersize=markersize, lw=lw, color=color_lead)\n        if anti:\n            self._plot_chain(ax, self.traj, 1, frame=frame, markersize=markersize, lw=lw, color=color_anti)\n        if helical_axis:\n            self._plot_helical_axis(ax, frame=frame, lw=lw)\n        if triads:\n            for triad in self.frames:\n                triad = triad[frame]\n                ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n        ax.axis('equal')\n        ax.axis('off')\n        if save:\n            fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n\n    def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 20):\n        \"\"\"\n        Minimize the DNA structure. This method updates the  of the DNA structure.\n\n        Args:\n            frame (int): The trajectory frame to minimize. Defaults to -1.\n            simple (bool): Whether to use simple equilibration. Defaults to False.\n            equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n            endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n            fixed (list): List of fixed base pairs. Defaults to an empty list.\n            exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n            temperature (int): Temperature for equilibration. Defaults to 300.\n            dump_every (int): Frequency of dumping frames. Defaults to 20.\n\n        Additional keyword arguments can be provided and will be passed to the minimizer.\n\n        Notes:\n\n            For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n            This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n            The other option is to use the full equilibration, which is based on the actual energy of the system.\n            We assume the energy to converge exponentially to the equilibrated value.\n            This works fairly well for most examples I checked but is not entirely robust. \n            Considering autocorrelation has some issues when there are relaxations at different timescales.\n            Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n            It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n        Example:\n            nuc = load(traj)\n            nuc.minimize(simple=True, temperature=310, exvol_rad=2.5)\n        \"\"\"\n        self.minimizer = Minimizer(self)\n        self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n        # Update the reference frames\n        self._frames_to_traj()\n\n    def get_MC_traj(self):\n        \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n        if self.minimizer is None:\n            raise ValueError('Run minimization first')\n        return self.minimizer.get_MC_traj()\n\n    def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1):\n        \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n        The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n        Args:\n            mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n            complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n            frame (int, optional): The frame to mutate. Defaults to -1.\n\n        Raises:\n            ValueError: If no mutation dictionary is provided.\n\n        Notes:\n            - Valid nucleobases for mutations include:\n                - Canonical bases: A, T, G, C, U\n                - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n                - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n                - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n        Examples:\n            # Create a DNA object\n            dna = DNA()\n\n            # Mutate the DNA trajectory\n            mutations = {0: 'A', 1: 'T', 2: 'G'}\n            dna.mutate(mutations=mutations, complementary=True, frame=-1)\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if mutations is None:\n            raise ValueError('Provide a mutation dictionary')\n\n        # TODO: Check if valid letters in mutations dictionary\n\n        mutant = Mutate(self.traj[frame], mutations, complementary=complementary)\n        self.traj = mutant.get_traj()\n        # Update sequence\n        self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n\n\n    def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n            \"\"\"Flips the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n                deg (int): The degrees to flip. Defaults to 180.\n                frame (int): The frame to flip. Defaults to -1.\n\n            Raises:\n                ValueError: If no fliplist is provided.\n\n            Notes:\n                This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping.\n                The `fliplist` parameter specifies the base pairs to flip. If no `fliplist` is provided, a `ValueError` is raised.\n                The `deg` parameter specifies the degrees to flip. By default, it is set to 180 degrees.\n                The `frame` parameter specifies the frame to flip. By default, it is set to -1.\n\n            Example:\n                &gt;&gt;&gt; dna = Nucleic()\n                &gt;&gt;&gt; dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)\n\n            \"\"\"\n\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(fliplist) == 0:\n                raise ValueError('Provide a fliplist')\n\n            flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n            self.traj = flipper.get_traj()\n\n    def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n            \"\"\"Methylate the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                methylations (list): List of base pairs to methylate. Defaults to [].\n                CpG (bool): Whether to methylate CpG sites. Defaults to False.\n                leading_strand (int): The leading strand to methylate. Defaults to 0.\n                frame (int): The frame to methylate. Defaults to -1.\n\n            Raises:\n                ValueError: If the DNA structure is not loaded.\n                ValueError: If the methylations list is empty.\n\n            Notes:\n                - If the DNA structure is not loaded, a ValueError will be raised.\n                - If the methylations list is empty, a ValueError will be raised.\n\n            Example:\n                &gt;&gt;&gt; nuc = Nucleic()\n                &gt;&gt;&gt; nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)\n            \"\"\"\n            if self.traj is None:\n                raise ValueError('DNA structure is not loaded')\n            if len(methylations) == 0:\n                raise ValueError('Provide a non-empty methylations list')\n\n            methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n            self.traj = methylator.get_traj()\n\n    def extend(self, n_bp: int, sequence: str = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True):  \n        \"\"\"Extend the DNA structure in the specified direction.\n            The method updates the attributes of the DNA object.\n\n\n        Args:\n            n_bp (int): Number of base pairs to extend the DNA structure.\n            sequence (str, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n            fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n            forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n            frame (int, optional): The time frame to extend. Defaults to -1.\n            shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n            margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n            minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n\n        Raises:\n            ValueError: If the DNA structure is circular and cannot be extended.\n            ValueError: If neither a fixed endpoint nor a length is specified for extension.\n            ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n        Notes:\n            - If the DNA structure is circular, it cannot be extended.\n            - If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.\n            - If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.\n            - If the shape is not provided, a straight line shape will be used for extension.\n            - If the DNA structure is not in the form of frames, it will be converted to frames before extension.\n            - If minimize is set to True, the new DNA structure will be minimized after extension.\n\n        Example:\n            &gt;&gt;&gt; nuc = Nucleic()\n            &gt;&gt;&gt; nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)\n        \"\"\"\n        if self.circular:\n            raise ValueError('Cannot extend circular DNA structure')\n        if not n_bp and not fixed_endpoints:\n            raise ValueError(\"Either a fixed endpoint or a length must be specified for extension.\")    \n        if self.traj is None:\n            self._frames_to_traj()\n        if shape is None:\n            shape = Shapes.line(length=1)\n        if self.frames is None:\n            self._traj_to_frames()\n\n        # Check the input sequence and number of base pairs\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n        extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n        # Also update, n_bp, sequence, frames etc\n        self.nuc = extender.nuc\n\n        if minimize:\n            self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints)\n\n        # Update attributes\n        self.sequence = self.nuc.sequence\n        self.traj = self.nuc.get_traj()\n        self.frames = self.nuc.get_frames()\n        self.n_bp = self.nuc.n_bp\n\n    def invert(self):\n        \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n         The method updates attributes of the DNA object.\n\n         Raises:\n            NotImplementedError.\"\"\"\n        raise NotImplementedError('Not implemented yet')\n\n    def get_linking_number(self, frame : int = -1):\n        \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n        Args:\n            frame (int, optional): Time frame of trajectory, by default -1\n\n        Returns:\n            linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n        \"\"\"\n\n        from pmcpy import pylk\n\n        if self.frames is None:\n                self._traj_to_frames()\n        frames = self.frames[:,frame,:,:]\n        positions = frames[:,0]\n        triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n        writhe = pylk.writhe(positions)\n        lk = pylk.triads2link(positions, triads)\n        return np.array([lk, writhe, lk - writhe])\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.__init__","title":"<code>__init__(sequence=None, n_bp=None, traj=None, frames=None, chainids=None, circular=None)</code>","text":"<p>Initializes the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence, e.g. 'CGCGAATTCGCG'.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>The number of base pairs. Default is None.</p> <code>None</code> <code>traj</code> <code>object</code> <p>The MDTraj trajectory. Default is None.</p> <code>None</code> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure. Default is None.</p> <code>None</code> <code>chainids</code> <code>list</code> <p>The chain IDs. Default is None.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both traj and frames are provided.</p> <code>ValueError</code> <p>If frames have an invalid shape.</p> <code>ValueError</code> <p>If the number of base pairs in the sequence and frames do not match.</p> <code>ValueError</code> <p>If neither traj nor frames are provided.</p> Notes <ul> <li>If traj is provided, sequence and n_bp will be extracted from the trajectory.</li> <li>If frames is provided, n_bp will be determined from the shape of frames.</li> <li>If sequence is provided, it will be checked against the number of base pairs.</li> </ul> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>str</code> <p>The DNA sequence.</p> <code>n_bp</code> <code>int</code> <p>The number of base pairs.</p> <code>traj</code> <code>object</code> <p>The MDTraj trajectory.</p> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure.</p> <code>chainids</code> <code>list</code> <p>The chain IDs.</p> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed.</p> <code>rigid</code> <code>None</code> <p>A container for rigid base parameters class output.</p> <code>minimizer</code> <code>None</code> <p>A container for minimizer class output.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=None, circular=None):\n        \"\"\"Initializes the DNA structure.\n\n        Args:\n            sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n            n_bp (int): The number of base pairs. Default is None.\n            traj (object): The MDTraj trajectory. Default is None.\n            frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n            chainids (list): The chain IDs. Default is None.\n            circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n        Raises:\n            ValueError: If both traj and frames are provided.\n            ValueError: If frames have an invalid shape.\n            ValueError: If the number of base pairs in the sequence and frames do not match.\n            ValueError: If neither traj nor frames are provided.\n\n        Notes:\n            - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n            - If frames is provided, n_bp will be determined from the shape of frames.\n            - If sequence is provided, it will be checked against the number of base pairs.\n\n        Attributes:\n            sequence (str): The DNA sequence.\n            n_bp (int): The number of base pairs.\n            traj (object): The MDTraj trajectory.\n            frames (np.ndarray): The reference frames of the DNA structure.\n            chainids (list): The chain IDs.\n            circular (bool): A flag that indicates if the structure is circular/closed.\n            rigid (None): A container for rigid base parameters class output.\n            minimizer (None): A container for minimizer class output.\n        \"\"\"\n        # Check for trajectory\n        if traj is not None:\n            if frames is not None:\n                raise ValueError('Provide either a trajectory or reference frames, not both')\n            # Extract sequence from the trajectory\n            sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n            n_bp = len(sequence)\n            frames = None  # Nucleic class will handle extraction from traj\n\n        # Check for reference frames\n        elif frames is not None:\n            if frames.ndim == 3:\n                # Case (n_bp, 4, 3)\n                frames = np.expand_dims(frames, axis=1)\n            if frames.ndim != 4:\n                raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n            n_bp = frames.shape[0]\n            if sequence is not None:\n                if len(sequence) != n_bp:\n                    raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                else:\n                    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n        else:\n            raise ValueError('Provide either a trajectory or reference frames')\n\n        self.sequence, self.n_bp = sequence, n_bp\n        self.traj = traj\n        self.frames = frames\n        self.chainids = chainids\n        self.circular = self._is_circular() if circular is None else circular \n        self.rigid = None # Container for rigid base parameters class output\n        self.minimizer = None # Container for minimizer class output\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.describe","title":"<code>describe()</code>","text":"<p>Print the DNA structure information</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def describe(self):\n    \"\"\"Print the DNA structure information\"\"\"\n    print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n    print('Sequence:', ''.join(self.sequence))\n\n    if self.traj is not None:\n        print('Trajectory:',self.traj)\n    else:\n        print('Trajectory not loaded')\n\n    if self.frames is not None:\n        print('Frames: ', self.frames.shape)\n    else:\n        print('Frames not loaded')\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.draw","title":"<code>draw(ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23, color_lead='k', color_anti='darkgrey')</code>","text":"<p>Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>object</code> <p>Matplotlib axis. Default is None.</p> <code>None</code> <code>fig</code> <code>object</code> <p>Figure axis. Default is None.</p> <code>None</code> <code>save</code> <code>bool</code> <p>Save image as png. Default is False.</p> <code>False</code> <code>frame</code> <code>int</code> <p>Index of trajectory to visualize. Default is -1.</p> <code>-1</code> <code>markersize</code> <code>int</code> <p>Width of backbone plot. Default is 2.</p> <code>2</code> <code>lw</code> <code>int</code> <p>Line width of plots. Default is 1.</p> <code>1</code> <code>helical_axis</code> <code>bool</code> <p>Plot central axis passing through frame origins. Default is True.</p> <code>True</code> <code>backbone</code> <code>bool</code> <p>Plot backbone as 'o-' line plot through phosphor atoms. Default is True.</p> <code>True</code> <code>lead</code> <code>bool</code> <p>Plot leading strand. Default is False.</p> <code>False</code> <code>anti</code> <code>bool</code> <p>Plot anti-sense opposing leading strand. Default is False.</p> <code>False</code> <code>triads</code> <code>bool</code> <p>Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.</p> <code>False</code> <code>length</code> <code>float</code> <p>Length of triad vectors. Default is 0.23.</p> <code>0.23</code> <code>color_lead</code> <code>str</code> <p>Color of the leading strand. Default is 'k'.</p> <code>'k'</code> <code>color_anti</code> <code>str</code> <p>Color of the anti strand. Default is 'darkgrey'.</p> <code>'darkgrey'</code> Notes <ul> <li>The function draws a 3D representation of the DNA structure using matplotlib.</li> <li>The DNA structure can include a helical axis, backbone, lead strand, anti-sense strand, and triads.</li> <li>The function requires either the trajectory or reference frames to be loaded before calling.</li> </ul> Example <p>nuc = Nucleic() nuc.load_traj('trajectory.dcd') nuc.draw(ax=plt.gca(), save=True, frame=10, markersize=3, lw=2, helical_axis=True, backbone=True, lead=True, anti=True, triads=True, length=0.2, color_lead='r', color_anti='b')</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey'):\n    \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n    Args:\n        ax (object, optional): Matplotlib axis. Default is None.\n        fig (object, optional): Figure axis. Default is None.\n        save (bool, optional): Save image as png. Default is False.\n        frame (int, optional): Index of trajectory to visualize. Default is -1.\n        markersize (int, optional): Width of backbone plot. Default is 2.\n        lw (int, optional): Line width of plots. Default is 1.\n        helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n        backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n        lead (bool, optional): Plot leading strand. Default is False.\n        anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n        triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n        length (float, optional): Length of triad vectors. Default is 0.23.\n        color_lead (str, optional): Color of the leading strand. Default is 'k'.\n        color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n\n    Notes:\n        - The function draws a 3D representation of the DNA structure using matplotlib.\n        - The DNA structure can include a helical axis, backbone, lead strand, anti-sense strand, and triads.\n        - The function requires either the trajectory or reference frames to be loaded before calling.\n\n    Example:\n        nuc = Nucleic()\n        nuc.load_traj('trajectory.dcd')\n        nuc.draw(ax=plt.gca(), save=True, frame=10, markersize=3, lw=2, helical_axis=True, backbone=True, lead=True, anti=True, triads=True, length=0.2, color_lead='r', color_anti='b')\n    \"\"\"\n\n    # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n    # in shape (time/n_frames, n_bp, 4, 3)\n\n    if self.traj is None:\n        self._frames_to_traj()\n    elif self.frames is None:\n        self._traj_to_frames()\n\n    if fig is None and ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n\n    if backbone:\n        lead = True\n        anti = True\n    if lead:\n        self._plot_chain(ax, self.traj, 0, frame=frame, markersize=markersize, lw=lw, color=color_lead)\n    if anti:\n        self._plot_chain(ax, self.traj, 1, frame=frame, markersize=markersize, lw=lw, color=color_anti)\n    if helical_axis:\n        self._plot_helical_axis(ax, frame=frame, lw=lw)\n    if triads:\n        for triad in self.frames:\n            triad = triad[frame]\n            ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n    ax.axis('equal')\n    ax.axis('off')\n    if save:\n        fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.extend","title":"<code>extend(n_bp, sequence=None, fixed_endpoints=False, forward=True, frame=-1, shape=None, margin=1, minimize=True)</code>","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> <li>If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.</li> <li>If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.</li> <li>If the shape is not provided, a straight line shape will be used for extension.</li> <li>If the DNA structure is not in the form of frames, it will be converted to frames before extension.</li> <li>If minimize is set to True, the new DNA structure will be minimized after extension.</li> </ul> Example <p>nuc = Nucleic() nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int, sequence: str = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure.\n        sequence (str, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n        - If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.\n        - If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.\n        - If the shape is not provided, a straight line shape will be used for extension.\n        - If the DNA structure is not in the form of frames, it will be converted to frames before extension.\n        - If minimize is set to True, the new DNA structure will be minimized after extension.\n\n    Example:\n        &gt;&gt;&gt; nuc = Nucleic()\n        &gt;&gt;&gt; nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')\n    if not n_bp and not fixed_endpoints:\n        raise ValueError(\"Either a fixed endpoint or a length must be specified for extension.\")    \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.flip","title":"<code>flip(fliplist=[], deg=180, frame=-1)</code>","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <p>This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping. The <code>fliplist</code> parameter specifies the base pairs to flip. If no <code>fliplist</code> is provided, a <code>ValueError</code> is raised. The <code>deg</code> parameter specifies the degrees to flip. By default, it is set to 180 degrees. The <code>frame</code> parameter specifies the frame to flip. By default, it is set to -1.</p> Example <p>dna = Nucleic() dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping.\n            The `fliplist` parameter specifies the base pairs to flip. If no `fliplist` is provided, a `ValueError` is raised.\n            The `deg` parameter specifies the degrees to flip. By default, it is set to 180 degrees.\n            The `frame` parameter specifies the frame to flip. By default, it is set to -1.\n\n        Example:\n            &gt;&gt;&gt; dna = Nucleic()\n            &gt;&gt;&gt; dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.get_MC_traj","title":"<code>get_MC_traj()</code>","text":"<p>Get the MC sampling energy minimization trajectory of the new spline.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_MC_traj(self):\n    \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n    if self.minimizer is None:\n        raise ValueError('Run minimization first')\n    return self.minimizer.get_MC_traj()\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.get_frames","title":"<code>get_frames()</code>","text":"<p>Get the reference frames of the DNA structure belonging to the base steps: Returns: array of reference frames of shape (n_frames, n_bp, 4, 3) where n_frames is the number of frames, n_bp is the number of base pairs,  and 4 corresponds to the origin and the 3 vectors of the reference frame</p> <p>Returns:</p> Name Type Description <code>frames</code> <code>ndarray</code> <p>reference frames of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_frames(self):\n    \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n    Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n    where n_frames is the number of frames, n_bp is the number of base pairs, \n    and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n    Returns:\n        frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n    if self.frames is None:\n        self._traj_to_frames()\n    return self.frames\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.get_linking_number","title":"<code>get_linking_number(frame=-1)</code>","text":"<p>Get the linking number of the DNA structure based on Gauss's linking number theorem.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>Time frame of trajectory, by default -1</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>linking_number</code> <code>ndarray</code> <p>Numpy array containing the linking number, writhe, and twist corresponding to the time frame</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_linking_number(self, frame : int = -1):\n    \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n    Args:\n        frame (int, optional): Time frame of trajectory, by default -1\n\n    Returns:\n        linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n    \"\"\"\n\n    from pmcpy import pylk\n\n    if self.frames is None:\n            self._traj_to_frames()\n    frames = self.frames[:,frame,:,:]\n    positions = frames[:,0]\n    triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n    writhe = pylk.writhe(positions)\n    lk = pylk.triads2link(positions, triads)\n    return np.array([lk, writhe, lk - writhe])\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.get_rigid_parameters","title":"<code>get_rigid_parameters()</code>","text":"<p>Get the rigid base parameters class object of the DNA structure</p> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_rigid_parameters(self):\n    \"\"\"Get the rigid base parameters class object of the DNA structure\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n    if self.rigid is None and self.traj is not None:\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    elif self.rigid is None and self.traj is None:\n        self._frames_to_traj()\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    else:\n        return self.rigid\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.get_traj","title":"<code>get_traj()</code>","text":"<p>Get the trajectory of the current state of the DNA structure Returns:     MDtraj object</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_traj(self):\n    \"\"\"Get the trajectory of the current state of the DNA structure\n    Returns:\n        MDtraj object\"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n\n    if self.traj.n_atoms &gt; 99999:\n        print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n    return self.traj\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.invert","title":"<code>invert()</code>","text":"<p>Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5 The method updates attributes of the DNA object.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def invert(self):\n    \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n     The method updates attributes of the DNA object.\n\n     Raises:\n        NotImplementedError.\"\"\"\n    raise NotImplementedError('Not implemented yet')\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.methylate","title":"<code>methylate(methylations=[], CpG=False, leading_strand=0, frame=-1)</code>","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <ul> <li>If the DNA structure is not loaded, a ValueError will be raised.</li> <li>If the methylations list is empty, a ValueError will be raised.</li> </ul> Example <p>nuc = Nucleic() nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            - If the DNA structure is not loaded, a ValueError will be raised.\n            - If the methylations list is empty, a ValueError will be raised.\n\n        Example:\n            &gt;&gt;&gt; nuc = Nucleic()\n            &gt;&gt;&gt; nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)\n        \"\"\"\n        if self.traj is None:\n            raise ValueError('DNA structure is not loaded')\n        if len(methylations) == 0:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.minimize","title":"<code>minimize(frame=-1, exvol_rad=2.0, temperature=300, simple=False, equilibrate_writhe=False, endpoints_fixed=False, fixed=[], dump_every=20)</code>","text":"<p>Minimize the DNA structure. This method updates the  of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The trajectory frame to minimize. Defaults to -1.</p> <code>-1</code> <code>simple</code> <code>bool</code> <p>Whether to use simple equilibration. Defaults to False.</p> <code>False</code> <code>equilibrate_writhe</code> <code>bool</code> <p>Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.</p> <code>False</code> <code>endpoints_fixed</code> <code>bool</code> <p>Whether the endpoints are fixed. Defaults to False.</p> <code>False</code> <code>fixed</code> <code>list</code> <p>List of fixed base pairs. Defaults to an empty list.</p> <code>[]</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults to 300.</p> <code>300</code> <code>dump_every</code> <code>int</code> <p>Frequency of dumping frames. Defaults to 20.</p> <code>20</code> <p>Additional keyword arguments can be provided and will be passed to the minimizer.</p> <p>Notes:</p> <pre><code>For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \nThis options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration.\n\nThe other option is to use the full equilibration, which is based on the actual energy of the system.\nWe assume the energy to converge exponentially to the equilibrated value.\nThis works fairly well for most examples I checked but is not entirely robust. \nConsidering autocorrelation has some issues when there are relaxations at different timescales.\nAlso, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \nIt is really non-trivial to set a criterion for whether or not a globally stable value is reached.\n</code></pre> Example <p>nuc = load(traj) nuc.minimize(simple=True, temperature=310, exvol_rad=2.5)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 20):\n    \"\"\"\n    Minimize the DNA structure. This method updates the  of the DNA structure.\n\n    Args:\n        frame (int): The trajectory frame to minimize. Defaults to -1.\n        simple (bool): Whether to use simple equilibration. Defaults to False.\n        equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n        endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n        fixed (list): List of fixed base pairs. Defaults to an empty list.\n        exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n        temperature (int): Temperature for equilibration. Defaults to 300.\n        dump_every (int): Frequency of dumping frames. Defaults to 20.\n\n    Additional keyword arguments can be provided and will be passed to the minimizer.\n\n    Notes:\n\n        For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n        This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n        The other option is to use the full equilibration, which is based on the actual energy of the system.\n        We assume the energy to converge exponentially to the equilibrated value.\n        This works fairly well for most examples I checked but is not entirely robust. \n        Considering autocorrelation has some issues when there are relaxations at different timescales.\n        Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n        It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n    Example:\n        nuc = load(traj)\n        nuc.minimize(simple=True, temperature=310, exvol_rad=2.5)\n    \"\"\"\n    self.minimizer = Minimizer(self)\n    self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n    # Update the reference frames\n    self._frames_to_traj()\n</code></pre>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.mutate","title":"<code>mutate(mutations=None, complementary=True, frame=-1)</code>","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> <p>Examples:</p>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.mutate--create-a-dna-object","title":"Create a DNA object","text":"<p>dna = DNA()</p>"},{"location":"nucleic-reference/#pymdna.nucleic.Nucleic.mutate--mutate-the-dna-trajectory","title":"Mutate the DNA trajectory","text":"<p>mutations = {0: 'A', 1: 'T', 2: 'G'} dna.mutate(mutations=mutations, complementary=True, frame=-1)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Examples:\n        # Create a DNA object\n        dna = DNA()\n\n        # Mutate the DNA trajectory\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>mdna</code> project code.</p>"},{"location":"reference/#pymdna.nucleic.Nucleic","title":"<code>Nucleic</code>","text":"<p>Contains mdna DNA structure with reference frames and trajectory</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>class Nucleic:\n\n    \"\"\"Contains mdna DNA structure with reference frames and trajectory\"\"\"\n\n    def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=None, circular=None):\n            \"\"\"Initializes the DNA structure.\n\n            Args:\n                sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n                n_bp (int): The number of base pairs. Default is None.\n                traj (object): The MDTraj trajectory. Default is None.\n                frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n                chainids (list): The chain IDs. Default is None.\n                circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n            Raises:\n                ValueError: If both traj and frames are provided.\n                ValueError: If frames have an invalid shape.\n                ValueError: If the number of base pairs in the sequence and frames do not match.\n                ValueError: If neither traj nor frames are provided.\n\n            Notes:\n                - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n                - If frames is provided, n_bp will be determined from the shape of frames.\n                - If sequence is provided, it will be checked against the number of base pairs.\n\n            Attributes:\n                sequence (str): The DNA sequence.\n                n_bp (int): The number of base pairs.\n                traj (object): The MDTraj trajectory.\n                frames (np.ndarray): The reference frames of the DNA structure.\n                chainids (list): The chain IDs.\n                circular (bool): A flag that indicates if the structure is circular/closed.\n                rigid (None): A container for rigid base parameters class output.\n                minimizer (None): A container for minimizer class output.\n            \"\"\"\n            # Check for trajectory\n            if traj is not None:\n                if frames is not None:\n                    raise ValueError('Provide either a trajectory or reference frames, not both')\n                # Extract sequence from the trajectory\n                sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n                n_bp = len(sequence)\n                frames = None  # Nucleic class will handle extraction from traj\n\n            # Check for reference frames\n            elif frames is not None:\n                if frames.ndim == 3:\n                    # Case (n_bp, 4, 3)\n                    frames = np.expand_dims(frames, axis=1)\n                if frames.ndim != 4:\n                    raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n                n_bp = frames.shape[0]\n                if sequence is not None:\n                    if len(sequence) != n_bp:\n                        raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                    else:\n                        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n            else:\n                raise ValueError('Provide either a trajectory or reference frames')\n\n            self.sequence, self.n_bp = sequence, n_bp\n            self.traj = traj\n            self.frames = frames\n            self.chainids = chainids\n            self.circular = self._is_circular() if circular is None else circular \n            self.rigid = None # Container for rigid base parameters class output\n            self.minimizer = None # Container for minimizer class output\n\n    def describe(self):\n        \"\"\"Print the DNA structure information\"\"\"\n        print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n        print('Sequence:', ''.join(self.sequence))\n\n        if self.traj is not None:\n            print('Trajectory:',self.traj)\n        else:\n            print('Trajectory not loaded')\n\n        if self.frames is not None:\n            print('Frames: ', self.frames.shape)\n        else:\n            print('Frames not loaded')\n\n    def _frames_to_traj(self, frame=-1):\n        \"\"\"Convert reference frames to trajectory\"\"\"\n        if self.frames is None:\n            raise ValueError('Load reference frames first')\n        self.traj = None\n        generator = StructureGenerator(frames=self.frames[:,frame,:,:], sequence=self.sequence, circular=self.circular)\n        self.traj = generator.get_traj()\n\n    def _traj_to_frames(self):\n        \"\"\"Convert trajectory to reference frames\"\"\"\n        if self.traj is None:\n            raise ValueError('Load trajectory first')\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        self.frames =self.rigid.frames\n\n    def get_frames(self):\n        \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n        Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n        where n_frames is the number of frames, n_bp is the number of base pairs, \n        and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n        Returns:\n            frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n        if self.frames is None:\n            self._traj_to_frames()\n        return self.frames\n\n    def get_traj(self):\n        \"\"\"Get the trajectory of the current state of the DNA structure\n        Returns:\n            MDtraj object\"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n\n        if self.traj.n_atoms &gt; 99999:\n            print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n        return self.traj\n\n    def get_rigid_parameters(self):\n        \"\"\"Get the rigid base parameters class object of the DNA structure\n\n        Returns:\n            NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n        if self.rigid is None and self.traj is not None:\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        elif self.rigid is None and self.traj is None:\n            self._frames_to_traj()\n            self.rigid = NucleicFrames(self.traj, self.chainids)\n            return self.rigid\n        else:\n            return self.rigid\n\n    def _is_circular(self, frame=0):\n        \"\"\"Detect if the DNA structure is circular for a given chain and frame\n\n        Parameters\n        ----------\n        chainid : int, optional\n            ID of the chain to check, by default 0\n        frame : int, optional\n            Frame index to check, by default 0\n\n        Returns\n        -------\n        bool\n            True if the DNA is circular, False otherwise\n        \"\"\"\n        if self.frames is None:\n            self._traj_to_frames()\n\n        start = self.frames[0,frame,0]\n        end = self.frames[-1,frame,0]\n        distance = np.linalg.norm(start - end)\n\n        # 0.34 nm is roughly the distance between base pairs and 20 is the minimum number of base pairs for circular DNA\n        return distance &lt; 1 and self.frames.shape[0] &gt; 20 \n\n    def _plot_chain(self, ax, traj, chainid, frame, lw=1, markersize=2, color='k'):\n        \"\"\"Plot the DNA structure of a chain\"\"\"\n        phosphor = traj.top.select(f'name P and chainid {chainid}')\n        x = traj.xyz[frame, phosphor, 0]\n        y = traj.xyz[frame, phosphor, 1]\n        z = traj.xyz[frame, phosphor, 2]\n\n        ax.plot(x, y, z, '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n        if self.circular:\n            # Connect the last point to the first point\n            ax.plot([x[-1], x[0]], [y[-1], y[0]], [z[-1], z[0]], '-o', c=color, markersize=markersize*1.2, lw=lw)\n\n    def _plot_helical_axis(self, ax, frame, lw=1):\n        helical_axis = self.frames[:,frame,0]\n        ax.plot(helical_axis[:,0],helical_axis[:,1],helical_axis[:,2],':',c='k',lw=lw*0.7)\n        if self.circular:\n            ax.plot([helical_axis[-1,0],helical_axis[0,0]],[helical_axis[-1,1],helical_axis[0,1]],[helical_axis[-1,2],helical_axis[0,2]],':',c='k',lw=lw*0.7)\n\n    def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey'):\n        \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n        Args:\n            ax (object, optional): Matplotlib axis. Default is None.\n            fig (object, optional): Figure axis. Default is None.\n            save (bool, optional): Save image as png. Default is False.\n            frame (int, optional): Index of trajectory to visualize. Default is -1.\n            markersize (int, optional): Width of backbone plot. Default is 2.\n            lw (int, optional): Line width of plots. Default is 1.\n            helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n            backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n            lead (bool, optional): Plot leading strand. Default is False.\n            anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n            triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n            length (float, optional): Length of triad vectors. Default is 0.23.\n            color_lead (str, optional): Color of the leading strand. Default is 'k'.\n            color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n\n        Notes:\n            - The function draws a 3D representation of the DNA structure using matplotlib.\n            - The DNA structure can include a helical axis, backbone, lead strand, anti-sense strand, and triads.\n            - The function requires either the trajectory or reference frames to be loaded before calling.\n\n        Example:\n            nuc = Nucleic()\n            nuc.load_traj('trajectory.dcd')\n            nuc.draw(ax=plt.gca(), save=True, frame=10, markersize=3, lw=2, helical_axis=True, backbone=True, lead=True, anti=True, triads=True, length=0.2, color_lead='r', color_anti='b')\n        \"\"\"\n\n        # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n        # in shape (time/n_frames, n_bp, 4, 3)\n\n        if self.traj is None:\n            self._frames_to_traj()\n        elif self.frames is None:\n            self._traj_to_frames()\n\n        if fig is None and ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n\n        if backbone:\n            lead = True\n            anti = True\n        if lead:\n            self._plot_chain(ax, self.traj, 0, frame=frame, markersize=markersize, lw=lw, color=color_lead)\n        if anti:\n            self._plot_chain(ax, self.traj, 1, frame=frame, markersize=markersize, lw=lw, color=color_anti)\n        if helical_axis:\n            self._plot_helical_axis(ax, frame=frame, lw=lw)\n        if triads:\n            for triad in self.frames:\n                triad = triad[frame]\n                ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n                ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n        ax.axis('equal')\n        ax.axis('off')\n        if save:\n            fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n\n    def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 20):\n        \"\"\"\n        Minimize the DNA structure. This method updates the  of the DNA structure.\n\n        Args:\n            frame (int): The trajectory frame to minimize. Defaults to -1.\n            simple (bool): Whether to use simple equilibration. Defaults to False.\n            equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n            endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n            fixed (list): List of fixed base pairs. Defaults to an empty list.\n            exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n            temperature (int): Temperature for equilibration. Defaults to 300.\n            dump_every (int): Frequency of dumping frames. Defaults to 20.\n\n        Additional keyword arguments can be provided and will be passed to the minimizer.\n\n        Notes:\n\n            For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n            This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n            The other option is to use the full equilibration, which is based on the actual energy of the system.\n            We assume the energy to converge exponentially to the equilibrated value.\n            This works fairly well for most examples I checked but is not entirely robust. \n            Considering autocorrelation has some issues when there are relaxations at different timescales.\n            Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n            It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n        Example:\n            nuc = load(traj)\n            nuc.minimize(simple=True, temperature=310, exvol_rad=2.5)\n        \"\"\"\n        self.minimizer = Minimizer(self)\n        self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n        # Update the reference frames\n        self._frames_to_traj()\n\n    def get_MC_traj(self):\n        \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n        if self.minimizer is None:\n            raise ValueError('Run minimization first')\n        return self.minimizer.get_MC_traj()\n\n    def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1):\n        \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n        The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n        Args:\n            mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n            complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n            frame (int, optional): The frame to mutate. Defaults to -1.\n\n        Raises:\n            ValueError: If no mutation dictionary is provided.\n\n        Notes:\n            - Valid nucleobases for mutations include:\n                - Canonical bases: A, T, G, C, U\n                - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n                - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n                - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n        Examples:\n            # Create a DNA object\n            dna = DNA()\n\n            # Mutate the DNA trajectory\n            mutations = {0: 'A', 1: 'T', 2: 'G'}\n            dna.mutate(mutations=mutations, complementary=True, frame=-1)\n        \"\"\"\n        if self.traj is None:\n            self._frames_to_traj()\n        if mutations is None:\n            raise ValueError('Provide a mutation dictionary')\n\n        # TODO: Check if valid letters in mutations dictionary\n\n        mutant = Mutate(self.traj[frame], mutations, complementary=complementary)\n        self.traj = mutant.get_traj()\n        # Update sequence\n        self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n\n\n    def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n            \"\"\"Flips the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n                deg (int): The degrees to flip. Defaults to 180.\n                frame (int): The frame to flip. Defaults to -1.\n\n            Raises:\n                ValueError: If no fliplist is provided.\n\n            Notes:\n                This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping.\n                The `fliplist` parameter specifies the base pairs to flip. If no `fliplist` is provided, a `ValueError` is raised.\n                The `deg` parameter specifies the degrees to flip. By default, it is set to 180 degrees.\n                The `frame` parameter specifies the frame to flip. By default, it is set to -1.\n\n            Example:\n                &gt;&gt;&gt; dna = Nucleic()\n                &gt;&gt;&gt; dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)\n\n            \"\"\"\n\n            if self.traj is None:\n                self._frames_to_traj()\n            if len(fliplist) == 0:\n                raise ValueError('Provide a fliplist')\n\n            flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n            self.traj = flipper.get_traj()\n\n    def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n            \"\"\"Methylate the nucleobases of the DNA structure.\n            The method updates the `traj` attribute of the DNA object.\n\n\n            Args:\n                methylations (list): List of base pairs to methylate. Defaults to [].\n                CpG (bool): Whether to methylate CpG sites. Defaults to False.\n                leading_strand (int): The leading strand to methylate. Defaults to 0.\n                frame (int): The frame to methylate. Defaults to -1.\n\n            Raises:\n                ValueError: If the DNA structure is not loaded.\n                ValueError: If the methylations list is empty.\n\n            Notes:\n                - If the DNA structure is not loaded, a ValueError will be raised.\n                - If the methylations list is empty, a ValueError will be raised.\n\n            Example:\n                &gt;&gt;&gt; nuc = Nucleic()\n                &gt;&gt;&gt; nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)\n            \"\"\"\n            if self.traj is None:\n                raise ValueError('DNA structure is not loaded')\n            if len(methylations) == 0:\n                raise ValueError('Provide a non-empty methylations list')\n\n            methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n            self.traj = methylator.get_traj()\n\n    def extend(self, n_bp: int, sequence: str = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True):  \n        \"\"\"Extend the DNA structure in the specified direction.\n            The method updates the attributes of the DNA object.\n\n\n        Args:\n            n_bp (int): Number of base pairs to extend the DNA structure.\n            sequence (str, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n            fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n            forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n            frame (int, optional): The time frame to extend. Defaults to -1.\n            shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n            margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n            minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n\n        Raises:\n            ValueError: If the DNA structure is circular and cannot be extended.\n            ValueError: If neither a fixed endpoint nor a length is specified for extension.\n            ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n        Notes:\n            - If the DNA structure is circular, it cannot be extended.\n            - If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.\n            - If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.\n            - If the shape is not provided, a straight line shape will be used for extension.\n            - If the DNA structure is not in the form of frames, it will be converted to frames before extension.\n            - If minimize is set to True, the new DNA structure will be minimized after extension.\n\n        Example:\n            &gt;&gt;&gt; nuc = Nucleic()\n            &gt;&gt;&gt; nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)\n        \"\"\"\n        if self.circular:\n            raise ValueError('Cannot extend circular DNA structure')\n        if not n_bp and not fixed_endpoints:\n            raise ValueError(\"Either a fixed endpoint or a length must be specified for extension.\")    \n        if self.traj is None:\n            self._frames_to_traj()\n        if shape is None:\n            shape = Shapes.line(length=1)\n        if self.frames is None:\n            self._traj_to_frames()\n\n        # Check the input sequence and number of base pairs\n        sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n        extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n        # Also update, n_bp, sequence, frames etc\n        self.nuc = extender.nuc\n\n        if minimize:\n            self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints)\n\n        # Update attributes\n        self.sequence = self.nuc.sequence\n        self.traj = self.nuc.get_traj()\n        self.frames = self.nuc.get_frames()\n        self.n_bp = self.nuc.n_bp\n\n    def invert(self):\n        \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n         The method updates attributes of the DNA object.\n\n         Raises:\n            NotImplementedError.\"\"\"\n        raise NotImplementedError('Not implemented yet')\n\n    def get_linking_number(self, frame : int = -1):\n        \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n        Args:\n            frame (int, optional): Time frame of trajectory, by default -1\n\n        Returns:\n            linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n        \"\"\"\n\n        from pmcpy import pylk\n\n        if self.frames is None:\n                self._traj_to_frames()\n        frames = self.frames[:,frame,:,:]\n        positions = frames[:,0]\n        triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n        writhe = pylk.writhe(positions)\n        lk = pylk.triads2link(positions, triads)\n        return np.array([lk, writhe, lk - writhe])\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.__init__","title":"<code>__init__(sequence=None, n_bp=None, traj=None, frames=None, chainids=None, circular=None)</code>","text":"<p>Initializes the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence, e.g. 'CGCGAATTCGCG'.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>The number of base pairs. Default is None.</p> <code>None</code> <code>traj</code> <code>object</code> <p>The MDTraj trajectory. Default is None.</p> <code>None</code> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure. Default is None.</p> <code>None</code> <code>chainids</code> <code>list</code> <p>The chain IDs. Default is None.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both traj and frames are provided.</p> <code>ValueError</code> <p>If frames have an invalid shape.</p> <code>ValueError</code> <p>If the number of base pairs in the sequence and frames do not match.</p> <code>ValueError</code> <p>If neither traj nor frames are provided.</p> Notes <ul> <li>If traj is provided, sequence and n_bp will be extracted from the trajectory.</li> <li>If frames is provided, n_bp will be determined from the shape of frames.</li> <li>If sequence is provided, it will be checked against the number of base pairs.</li> </ul> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>str</code> <p>The DNA sequence.</p> <code>n_bp</code> <code>int</code> <p>The number of base pairs.</p> <code>traj</code> <code>object</code> <p>The MDTraj trajectory.</p> <code>frames</code> <code>ndarray</code> <p>The reference frames of the DNA structure.</p> <code>chainids</code> <code>list</code> <p>The chain IDs.</p> <code>circular</code> <code>bool</code> <p>A flag that indicates if the structure is circular/closed.</p> <code>rigid</code> <code>None</code> <p>A container for rigid base parameters class output.</p> <code>minimizer</code> <code>None</code> <p>A container for minimizer class output.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def __init__(self, sequence=None, n_bp=None, traj=None, frames=None, chainids=None, circular=None):\n        \"\"\"Initializes the DNA structure.\n\n        Args:\n            sequence (str): The DNA sequence, e.g. 'CGCGAATTCGCG'.\n            n_bp (int): The number of base pairs. Default is None.\n            traj (object): The MDTraj trajectory. Default is None.\n            frames (np.ndarray): The reference frames of the DNA structure. Default is None.\n            chainids (list): The chain IDs. Default is None.\n            circular (bool): A flag that indicates if the structure is circular/closed. Default is None.\n\n        Raises:\n            ValueError: If both traj and frames are provided.\n            ValueError: If frames have an invalid shape.\n            ValueError: If the number of base pairs in the sequence and frames do not match.\n            ValueError: If neither traj nor frames are provided.\n\n        Notes:\n            - If traj is provided, sequence and n_bp will be extracted from the trajectory.\n            - If frames is provided, n_bp will be determined from the shape of frames.\n            - If sequence is provided, it will be checked against the number of base pairs.\n\n        Attributes:\n            sequence (str): The DNA sequence.\n            n_bp (int): The number of base pairs.\n            traj (object): The MDTraj trajectory.\n            frames (np.ndarray): The reference frames of the DNA structure.\n            chainids (list): The chain IDs.\n            circular (bool): A flag that indicates if the structure is circular/closed.\n            rigid (None): A container for rigid base parameters class output.\n            minimizer (None): A container for minimizer class output.\n        \"\"\"\n        # Check for trajectory\n        if traj is not None:\n            if frames is not None:\n                raise ValueError('Provide either a trajectory or reference frames, not both')\n            # Extract sequence from the trajectory\n            sequence = get_sequence_letters(traj, leading_chain=chainids[0])\n            n_bp = len(sequence)\n            frames = None  # Nucleic class will handle extraction from traj\n\n        # Check for reference frames\n        elif frames is not None:\n            if frames.ndim == 3:\n                # Case (n_bp, 4, 3)\n                frames = np.expand_dims(frames, axis=1)\n            if frames.ndim != 4:\n                raise ValueError('Frames should be of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3)')\n            n_bp = frames.shape[0]\n            if sequence is not None:\n                if len(sequence) != n_bp:\n                    raise ValueError('Number of base pairs in the sequence and frames do not match')  \n                else:\n                    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)      \n        else:\n            raise ValueError('Provide either a trajectory or reference frames')\n\n        self.sequence, self.n_bp = sequence, n_bp\n        self.traj = traj\n        self.frames = frames\n        self.chainids = chainids\n        self.circular = self._is_circular() if circular is None else circular \n        self.rigid = None # Container for rigid base parameters class output\n        self.minimizer = None # Container for minimizer class output\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.describe","title":"<code>describe()</code>","text":"<p>Print the DNA structure information</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def describe(self):\n    \"\"\"Print the DNA structure information\"\"\"\n    print(f'{\"Circular \" if self.circular else \"\"}DNA structure with {self.n_bp} base pairs')\n    print('Sequence:', ''.join(self.sequence))\n\n    if self.traj is not None:\n        print('Trajectory:',self.traj)\n    else:\n        print('Trajectory not loaded')\n\n    if self.frames is not None:\n        print('Frames: ', self.frames.shape)\n    else:\n        print('Frames not loaded')\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.draw","title":"<code>draw(ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23, color_lead='k', color_anti='darkgrey')</code>","text":"<p>Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>object</code> <p>Matplotlib axis. Default is None.</p> <code>None</code> <code>fig</code> <code>object</code> <p>Figure axis. Default is None.</p> <code>None</code> <code>save</code> <code>bool</code> <p>Save image as png. Default is False.</p> <code>False</code> <code>frame</code> <code>int</code> <p>Index of trajectory to visualize. Default is -1.</p> <code>-1</code> <code>markersize</code> <code>int</code> <p>Width of backbone plot. Default is 2.</p> <code>2</code> <code>lw</code> <code>int</code> <p>Line width of plots. Default is 1.</p> <code>1</code> <code>helical_axis</code> <code>bool</code> <p>Plot central axis passing through frame origins. Default is True.</p> <code>True</code> <code>backbone</code> <code>bool</code> <p>Plot backbone as 'o-' line plot through phosphor atoms. Default is True.</p> <code>True</code> <code>lead</code> <code>bool</code> <p>Plot leading strand. Default is False.</p> <code>False</code> <code>anti</code> <code>bool</code> <p>Plot anti-sense opposing leading strand. Default is False.</p> <code>False</code> <code>triads</code> <code>bool</code> <p>Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.</p> <code>False</code> <code>length</code> <code>float</code> <p>Length of triad vectors. Default is 0.23.</p> <code>0.23</code> <code>color_lead</code> <code>str</code> <p>Color of the leading strand. Default is 'k'.</p> <code>'k'</code> <code>color_anti</code> <code>str</code> <p>Color of the anti strand. Default is 'darkgrey'.</p> <code>'darkgrey'</code> Notes <ul> <li>The function draws a 3D representation of the DNA structure using matplotlib.</li> <li>The DNA structure can include a helical axis, backbone, lead strand, anti-sense strand, and triads.</li> <li>The function requires either the trajectory or reference frames to be loaded before calling.</li> </ul> Example <p>nuc = Nucleic() nuc.load_traj('trajectory.dcd') nuc.draw(ax=plt.gca(), save=True, frame=10, markersize=3, lw=2, helical_axis=True, backbone=True, lead=True, anti=True, triads=True, length=0.2, color_lead='r', color_anti='b')</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def draw(self, ax=None, fig=None, save=False, frame=-1, markersize=2, lw=1, helical_axis=True, backbone=True, lead=False, anti=False, triads=False, length=0.23,color_lead='k',color_anti='darkgrey'):\n    \"\"\"Draws a 3D representation of the DNA structure with optional helical axis, backbone, lead, anti, and triads.\n\n    Args:\n        ax (object, optional): Matplotlib axis. Default is None.\n        fig (object, optional): Figure axis. Default is None.\n        save (bool, optional): Save image as png. Default is False.\n        frame (int, optional): Index of trajectory to visualize. Default is -1.\n        markersize (int, optional): Width of backbone plot. Default is 2.\n        lw (int, optional): Line width of plots. Default is 1.\n        helical_axis (bool, optional): Plot central axis passing through frame origins. Default is True.\n        backbone (bool, optional): Plot backbone as 'o-' line plot through phosphor atoms. Default is True.\n        lead (bool, optional): Plot leading strand. Default is False.\n        anti (bool, optional): Plot anti-sense opposing leading strand. Default is False.\n        triads (bool, optional): Plot triads in order of b_L (blue), b_N (green), b_T (red). Default is False.\n        length (float, optional): Length of triad vectors. Default is 0.23.\n        color_lead (str, optional): Color of the leading strand. Default is 'k'.\n        color_anti (str, optional): Color of the anti strand. Default is 'darkgrey'.\n\n    Notes:\n        - The function draws a 3D representation of the DNA structure using matplotlib.\n        - The DNA structure can include a helical axis, backbone, lead strand, anti-sense strand, and triads.\n        - The function requires either the trajectory or reference frames to be loaded before calling.\n\n    Example:\n        nuc = Nucleic()\n        nuc.load_traj('trajectory.dcd')\n        nuc.draw(ax=plt.gca(), save=True, frame=10, markersize=3, lw=2, helical_axis=True, backbone=True, lead=True, anti=True, triads=True, length=0.2, color_lead='r', color_anti='b')\n    \"\"\"\n\n    # TODO: handle circular DNA and when trajectory is not loaded make frames uniform \n    # in shape (time/n_frames, n_bp, 4, 3)\n\n    if self.traj is None:\n        self._frames_to_traj()\n    elif self.frames is None:\n        self._traj_to_frames()\n\n    if fig is None and ax is None:\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n\n    if backbone:\n        lead = True\n        anti = True\n    if lead:\n        self._plot_chain(ax, self.traj, 0, frame=frame, markersize=markersize, lw=lw, color=color_lead)\n    if anti:\n        self._plot_chain(ax, self.traj, 1, frame=frame, markersize=markersize, lw=lw, color=color_anti)\n    if helical_axis:\n        self._plot_helical_axis(ax, frame=frame, lw=lw)\n    if triads:\n        for triad in self.frames:\n            triad = triad[frame]\n            ax.scatter(triad[0,0],triad[0,1],triad[0,2],c='k',s=markersize*1.2)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[1,0],triad[1,1],triad[1,2],color='b',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[2,0],triad[2,1],triad[2,2],color='g',length=length)\n            ax.quiver(triad[0,0],triad[0,1],triad[0,2],triad[3,0],triad[3,1],triad[3,2],color='r',length=length)\n\n    ax.axis('equal')\n    ax.axis('off')\n    if save:\n        fig.savefig('dna.png', dpi=300,bbox_inches='tight')\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.extend","title":"<code>extend(n_bp, sequence=None, fixed_endpoints=False, forward=True, frame=-1, shape=None, margin=1, minimize=True)</code>","text":"<p>Extend the DNA structure in the specified direction.     The method updates the attributes of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>n_bp</code> <code>int</code> <p>Number of base pairs to extend the DNA structure.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.</p> <code>None</code> <code>fixed_endpoints</code> <code>bool</code> <p>Whether to fix the endpoints of the DNA structure during extension. Defaults to False.</p> <code>False</code> <code>forward</code> <code>bool</code> <p>Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The time frame to extend. Defaults to -1.</p> <code>-1</code> <code>shape</code> <code>ndarray</code> <p>Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.</p> <code>None</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure after extension. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is circular and cannot be extended.</p> <code>ValueError</code> <p>If neither a fixed endpoint nor a length is specified for extension.</p> <code>ValueError</code> <p>If the input sequence is invalid or the number of base pairs is invalid.</p> Notes <ul> <li>If the DNA structure is circular, it cannot be extended.</li> <li>If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.</li> <li>If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.</li> <li>If the shape is not provided, a straight line shape will be used for extension.</li> <li>If the DNA structure is not in the form of frames, it will be converted to frames before extension.</li> <li>If minimize is set to True, the new DNA structure will be minimized after extension.</li> </ul> Example <p>nuc = Nucleic() nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def extend(self, n_bp: int, sequence: str = None, fixed_endpoints: bool = False, forward: bool = True, frame: int = -1, shape: np.ndarray = None, margin: int = 1, minimize: bool = True):  \n    \"\"\"Extend the DNA structure in the specified direction.\n        The method updates the attributes of the DNA object.\n\n\n    Args:\n        n_bp (int): Number of base pairs to extend the DNA structure.\n        sequence (str, optional): DNA sequence to extend the DNA structure. If not provided, the sequence will be generated randomly. Defaults to None.\n        fixed_endpoints (bool, optional): Whether to fix the endpoints of the DNA structure during extension. Defaults to False.\n        forward (bool, optional): Whether to extend the DNA structure in the forward direction. If False, the DNA structure will be extended in the backward direction. Defaults to True.\n        frame (int, optional): The time frame to extend. Defaults to -1.\n        shape (np.ndarray, optional): Control points of the shape to be used for extension. The shape should be a numpy array of shape (n, 3), where n is greater than 3. Defaults to None.\n        margin (int, optional): Number of base pairs to fix at the end/start of the DNA structure during extension. Defaults to 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure after extension. Defaults to True.\n\n    Raises:\n        ValueError: If the DNA structure is circular and cannot be extended.\n        ValueError: If neither a fixed endpoint nor a length is specified for extension.\n        ValueError: If the input sequence is invalid or the number of base pairs is invalid.\n\n    Notes:\n        - If the DNA structure is circular, it cannot be extended.\n        - If neither a fixed endpoint nor a length is specified for extension, a ValueError will be raised.\n        - If the input sequence is provided, it will be used to extend the DNA structure. Otherwise, the sequence will be generated randomly.\n        - If the shape is not provided, a straight line shape will be used for extension.\n        - If the DNA structure is not in the form of frames, it will be converted to frames before extension.\n        - If minimize is set to True, the new DNA structure will be minimized after extension.\n\n    Example:\n        &gt;&gt;&gt; nuc = Nucleic()\n        &gt;&gt;&gt; nuc.extend(n_bp=10, sequence='ATCG', fixed_endpoints=True, forward=True, frame=-1, shape=None, margin=2, minimize=True)\n    \"\"\"\n    if self.circular:\n        raise ValueError('Cannot extend circular DNA structure')\n    if not n_bp and not fixed_endpoints:\n        raise ValueError(\"Either a fixed endpoint or a length must be specified for extension.\")    \n    if self.traj is None:\n        self._frames_to_traj()\n    if shape is None:\n        shape = Shapes.line(length=1)\n    if self.frames is None:\n        self._traj_to_frames()\n\n    # Check the input sequence and number of base pairs\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    extender = Extender(self, n_bp=n_bp, sequence=sequence, fixed_endpoints=fixed_endpoints, frame=frame, forward=forward, shape=shape, margin=margin)\n    # Also update, n_bp, sequence, frames etc\n    self.nuc = extender.nuc\n\n    if minimize:\n        self.nuc.minimize(fixed=extender.fixed, endpoints_fixed=fixed_endpoints)\n\n    # Update attributes\n    self.sequence = self.nuc.sequence\n    self.traj = self.nuc.get_traj()\n    self.frames = self.nuc.get_frames()\n    self.n_bp = self.nuc.n_bp\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.flip","title":"<code>flip(fliplist=[], deg=180, frame=-1)</code>","text":"<p>Flips the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>fliplist</code> <code>list</code> <p>A list of base pairs to flip. Defaults to an empty list.</p> <code>[]</code> <code>deg</code> <code>int</code> <p>The degrees to flip. Defaults to 180.</p> <code>180</code> <code>frame</code> <code>int</code> <p>The frame to flip. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no fliplist is provided.</p> Notes <p>This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping. The <code>fliplist</code> parameter specifies the base pairs to flip. If no <code>fliplist</code> is provided, a <code>ValueError</code> is raised. The <code>deg</code> parameter specifies the degrees to flip. By default, it is set to 180 degrees. The <code>frame</code> parameter specifies the frame to flip. By default, it is set to -1.</p> Example <p>dna = Nucleic() dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def flip(self, fliplist: list = [], deg: int = 180, frame: int = -1):\n        \"\"\"Flips the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            fliplist (list): A list of base pairs to flip. Defaults to an empty list.\n            deg (int): The degrees to flip. Defaults to 180.\n            frame (int): The frame to flip. Defaults to -1.\n\n        Raises:\n            ValueError: If no fliplist is provided.\n\n        Notes:\n            This method flips the nucleobases of the DNA structure. It uses the Hoogsteen algorithm to perform the flipping.\n            The `fliplist` parameter specifies the base pairs to flip. If no `fliplist` is provided, a `ValueError` is raised.\n            The `deg` parameter specifies the degrees to flip. By default, it is set to 180 degrees.\n            The `frame` parameter specifies the frame to flip. By default, it is set to -1.\n\n        Example:\n            &gt;&gt;&gt; dna = Nucleic()\n            &gt;&gt;&gt; dna.flip(fliplist=[(1, 2), (3, 4)], deg=90, frame=0)\n\n        \"\"\"\n\n        if self.traj is None:\n            self._frames_to_traj()\n        if len(fliplist) == 0:\n            raise ValueError('Provide a fliplist')\n\n        flipper = Hoogsteen(self.traj, fliplist=fliplist, deg=deg, verbose=True)\n        self.traj = flipper.get_traj()\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.get_MC_traj","title":"<code>get_MC_traj()</code>","text":"<p>Get the MC sampling energy minimization trajectory of the new spline.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_MC_traj(self):\n    \"\"\"Get the MC sampling energy minimization trajectory of the new spline.\"\"\"\n    if self.minimizer is None:\n        raise ValueError('Run minimization first')\n    return self.minimizer.get_MC_traj()\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.get_frames","title":"<code>get_frames()</code>","text":"<p>Get the reference frames of the DNA structure belonging to the base steps: Returns: array of reference frames of shape (n_frames, n_bp, 4, 3) where n_frames is the number of frames, n_bp is the number of base pairs,  and 4 corresponds to the origin and the 3 vectors of the reference frame</p> <p>Returns:</p> Name Type Description <code>frames</code> <code>ndarray</code> <p>reference frames of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_frames(self):\n    \"\"\"Get the reference frames of the DNA structure belonging to the base steps:\n    Returns: array of reference frames of shape (n_frames, n_bp, 4, 3)\n    where n_frames is the number of frames, n_bp is the number of base pairs, \n    and 4 corresponds to the origin and the 3 vectors of the reference frame\n\n    Returns:\n        frames (np.ndarray): reference frames of the DNA structure\"\"\"\n\n    if self.frames is None:\n        self._traj_to_frames()\n    return self.frames\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.get_linking_number","title":"<code>get_linking_number(frame=-1)</code>","text":"<p>Get the linking number of the DNA structure based on Gauss's linking number theorem.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>Time frame of trajectory, by default -1</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>linking_number</code> <code>ndarray</code> <p>Numpy array containing the linking number, writhe, and twist corresponding to the time frame</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_linking_number(self, frame : int = -1):\n    \"\"\"Get the linking number of the DNA structure based on Gauss's linking number theorem.\n\n    Args:\n        frame (int, optional): Time frame of trajectory, by default -1\n\n    Returns:\n        linking_number (np.ndarray): Numpy array containing the linking number, writhe, and twist corresponding to the time frame\n    \"\"\"\n\n    from pmcpy import pylk\n\n    if self.frames is None:\n            self._traj_to_frames()\n    frames = self.frames[:,frame,:,:]\n    positions = frames[:,0]\n    triads = frames[:,1:].transpose(0,2,1) # Flip row vectors to columns\n\n    writhe = pylk.writhe(positions)\n    lk = pylk.triads2link(positions, triads)\n    return np.array([lk, writhe, lk - writhe])\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.get_rigid_parameters","title":"<code>get_rigid_parameters()</code>","text":"<p>Get the rigid base parameters class object of the DNA structure</p> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_rigid_parameters(self):\n    \"\"\"Get the rigid base parameters class object of the DNA structure\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\"\"\"\n    if self.rigid is None and self.traj is not None:\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    elif self.rigid is None and self.traj is None:\n        self._frames_to_traj()\n        self.rigid = NucleicFrames(self.traj, self.chainids)\n        return self.rigid\n    else:\n        return self.rigid\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.get_traj","title":"<code>get_traj()</code>","text":"<p>Get the trajectory of the current state of the DNA structure Returns:     MDtraj object</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def get_traj(self):\n    \"\"\"Get the trajectory of the current state of the DNA structure\n    Returns:\n        MDtraj object\"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n\n    if self.traj.n_atoms &gt; 99999:\n        print('Warning: Trajectory contains more than 99999 atoms, consider saving as .h5')\n    return self.traj\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.invert","title":"<code>invert()</code>","text":"<p>Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5 The method updates attributes of the DNA object.</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def invert(self):\n    \"\"\"Inverse the direction of the DNA structure so from 5' to 3' to 3' to 5\n     The method updates attributes of the DNA object.\n\n     Raises:\n        NotImplementedError.\"\"\"\n    raise NotImplementedError('Not implemented yet')\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.methylate","title":"<code>methylate(methylations=[], CpG=False, leading_strand=0, frame=-1)</code>","text":"<p>Methylate the nucleobases of the DNA structure. The method updates the <code>traj</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>methylations</code> <code>list</code> <p>List of base pairs to methylate. Defaults to [].</p> <code>[]</code> <code>CpG</code> <code>bool</code> <p>Whether to methylate CpG sites. Defaults to False.</p> <code>False</code> <code>leading_strand</code> <code>int</code> <p>The leading strand to methylate. Defaults to 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The frame to methylate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DNA structure is not loaded.</p> <code>ValueError</code> <p>If the methylations list is empty.</p> Notes <ul> <li>If the DNA structure is not loaded, a ValueError will be raised.</li> <li>If the methylations list is empty, a ValueError will be raised.</li> </ul> Example <p>nuc = Nucleic() nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def methylate(self, methylations: list = [], CpG: bool = False, leading_strand: int = 0, frame: int = -1):\n        \"\"\"Methylate the nucleobases of the DNA structure.\n        The method updates the `traj` attribute of the DNA object.\n\n\n        Args:\n            methylations (list): List of base pairs to methylate. Defaults to [].\n            CpG (bool): Whether to methylate CpG sites. Defaults to False.\n            leading_strand (int): The leading strand to methylate. Defaults to 0.\n            frame (int): The frame to methylate. Defaults to -1.\n\n        Raises:\n            ValueError: If the DNA structure is not loaded.\n            ValueError: If the methylations list is empty.\n\n        Notes:\n            - If the DNA structure is not loaded, a ValueError will be raised.\n            - If the methylations list is empty, a ValueError will be raised.\n\n        Example:\n            &gt;&gt;&gt; nuc = Nucleic()\n            &gt;&gt;&gt; nuc.methylate(methylations=[1, 3, 5], CpG=True, leading_strand=1, frame=0)\n        \"\"\"\n        if self.traj is None:\n            raise ValueError('DNA structure is not loaded')\n        if len(methylations) == 0:\n            raise ValueError('Provide a non-empty methylations list')\n\n        methylator = Methylate(self.traj, methylations=methylations, CpG=CpG, leading_strand=leading_strand)\n        self.traj = methylator.get_traj()\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.minimize","title":"<code>minimize(frame=-1, exvol_rad=2.0, temperature=300, simple=False, equilibrate_writhe=False, endpoints_fixed=False, fixed=[], dump_every=20)</code>","text":"<p>Minimize the DNA structure. This method updates the  of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The trajectory frame to minimize. Defaults to -1.</p> <code>-1</code> <code>simple</code> <code>bool</code> <p>Whether to use simple equilibration. Defaults to False.</p> <code>False</code> <code>equilibrate_writhe</code> <code>bool</code> <p>Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.</p> <code>False</code> <code>endpoints_fixed</code> <code>bool</code> <p>Whether the endpoints are fixed. Defaults to False.</p> <code>False</code> <code>fixed</code> <code>list</code> <p>List of fixed base pairs. Defaults to an empty list.</p> <code>[]</code> <code>exvol_rad</code> <code>float</code> <p>Excluded volume radius. Defaults to 2.0.</p> <code>2.0</code> <code>temperature</code> <code>int</code> <p>Temperature for equilibration. Defaults to 300.</p> <code>300</code> <code>dump_every</code> <code>int</code> <p>Frequency of dumping frames. Defaults to 20.</p> <code>20</code> <p>Additional keyword arguments can be provided and will be passed to the minimizer.</p> <p>Notes:</p> <pre><code>For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \nThis options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration.\n\nThe other option is to use the full equilibration, which is based on the actual energy of the system.\nWe assume the energy to converge exponentially to the equilibrated value.\nThis works fairly well for most examples I checked but is not entirely robust. \nConsidering autocorrelation has some issues when there are relaxations at different timescales.\nAlso, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \nIt is really non-trivial to set a criterion for whether or not a globally stable value is reached.\n</code></pre> Example <p>nuc = load(traj) nuc.minimize(simple=True, temperature=310, exvol_rad=2.5)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def minimize(self, frame: int = -1, exvol_rad : float = 2.0, temperature : int = 300,  simple : bool = False, equilibrate_writhe : bool = False, endpoints_fixed : bool = False, fixed : List[int] = [], dump_every : int = 20):\n    \"\"\"\n    Minimize the DNA structure. This method updates the  of the DNA structure.\n\n    Args:\n        frame (int): The trajectory frame to minimize. Defaults to -1.\n        simple (bool): Whether to use simple equilibration. Defaults to False.\n        equilibrate_writhe (bool): Whether to equilibrate writhe. Defaults to False. Only works for simple equilibration.\n        endpoints_fixed (bool): Whether the endpoints are fixed. Defaults to False.\n        fixed (list): List of fixed base pairs. Defaults to an empty list.\n        exvol_rad (float): Excluded volume radius. Defaults to 2.0.\n        temperature (int): Temperature for equilibration. Defaults to 300.\n        dump_every (int): Frequency of dumping frames. Defaults to 20.\n\n    Additional keyword arguments can be provided and will be passed to the minimizer.\n\n    Notes:\n\n        For the simple equilibation, we rely on checking whether the considered quantity starts to fluctuate around a fixed value. \n        This options is compatible with With the argument equilibrate_writhe, which you can specify that writhe should also be considered for equilibration. \n\n        The other option is to use the full equilibration, which is based on the actual energy of the system.\n        We assume the energy to converge exponentially to the equilibrated value.\n        This works fairly well for most examples I checked but is not entirely robust. \n        Considering autocorrelation has some issues when there are relaxations at different timescales.\n        Also, I wasn't able to use something consistent to equilibrate writhe, since that involves a barrier crossing. \n        It is really non-trivial to set a criterion for whether or not a globally stable value is reached. \n\n    Example:\n        nuc = load(traj)\n        nuc.minimize(simple=True, temperature=310, exvol_rad=2.5)\n    \"\"\"\n    self.minimizer = Minimizer(self)\n    self.minimizer.minimize(frame=frame, exvol_rad=exvol_rad, temperature=temperature, simple=simple, equilibrate_writhe=equilibrate_writhe, endpoints_fixed=endpoints_fixed, fixed=fixed, dump_every=dump_every)    \n    # Update the reference frames\n    self._frames_to_traj()\n</code></pre>"},{"location":"reference/#pymdna.nucleic.Nucleic.mutate","title":"<code>mutate(mutations=None, complementary=True, frame=-1)</code>","text":"<p>Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure. The method updates the <code>traj</code> attribute and the <code>sequence</code> attribute of the DNA object.</p> <p>Parameters:</p> Name Type Description Default <code>mutations</code> <code>dict</code> <p>A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, <code>mutations = {0: 'A', 1: 'T', 2: 'G'}</code> will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.</p> <code>None</code> <code>complementary</code> <code>bool</code> <p>Whether to mutate the complementary strand. Defaults to True.</p> <code>True</code> <code>frame</code> <code>int</code> <p>The frame to mutate. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no mutation dictionary is provided.</p> Notes <ul> <li>Valid nucleobases for mutations include:<ul> <li>Canonical bases: A, T, G, C, U</li> <li>Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)</li> <li>Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)</li> <li>Hydrophobic pairs: d5SICS (L), dNaM (M)</li> </ul> </li> </ul> <p>Examples:</p>"},{"location":"reference/#pymdna.nucleic.Nucleic.mutate--create-a-dna-object","title":"Create a DNA object","text":"<p>dna = DNA()</p>"},{"location":"reference/#pymdna.nucleic.Nucleic.mutate--mutate-the-dna-trajectory","title":"Mutate the DNA trajectory","text":"<p>mutations = {0: 'A', 1: 'T', 2: 'G'} dna.mutate(mutations=mutations, complementary=True, frame=-1)</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def mutate(self, mutations: dict = None, complementary: bool = True, frame: int = -1):\n    \"\"\"Mutate the DNA trajectory, updating the topology and coordinates of the DNA structure.\n    The method updates the `traj` attribute and the `sequence` attribute of the DNA object.\n\n\n    Args:\n        mutations (dict, optional): A dictionary containing the mutation information. The keys represent the indices of the base pairs to be mutated, and the values represent the new nucleobases. For example, `mutations = {0: 'A', 1: 'T', 2: 'G'}` will mutate the first three base pairs to A, T, and G, respectively. Defaults to None.\n        complementary (bool, optional): Whether to mutate the complementary strand. Defaults to True.\n        frame (int, optional): The frame to mutate. Defaults to -1.\n\n    Raises:\n        ValueError: If no mutation dictionary is provided.\n\n    Notes:\n        - Valid nucleobases for mutations include:\n            - Canonical bases: A, T, G, C, U\n            - Hachimoji: B [A_ana], S [T_ana], P [C_ana], Z [G_ana] (DOI: 10.1126/science.aat0971)\n            - Fluorescent: 2-aminopurine 2AP (E), triC (D) (DOI: 10.1002/anie.201001312), tricyclic cytosine base analogue (1tuq)\n            - Hydrophobic pairs: d5SICS (L), dNaM (M)\n\n    Examples:\n        # Create a DNA object\n        dna = DNA()\n\n        # Mutate the DNA trajectory\n        mutations = {0: 'A', 1: 'T', 2: 'G'}\n        dna.mutate(mutations=mutations, complementary=True, frame=-1)\n    \"\"\"\n    if self.traj is None:\n        self._frames_to_traj()\n    if mutations is None:\n        raise ValueError('Provide a mutation dictionary')\n\n    # TODO: Check if valid letters in mutations dictionary\n\n    mutant = Mutate(self.traj[frame], mutations, complementary=complementary)\n    self.traj = mutant.get_traj()\n    # Update sequence\n    self.sequence = ''.join(get_sequence_letters(self.traj, leading_chain=self.chainids[0]))\n</code></pre>"},{"location":"reference/#pymdna.nucleic.compute_curvature","title":"<code>compute_curvature(traj, chainids=[0, 1])</code>","text":"<p>Compute the curvature of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_curvature(traj, chainids=[0,1]):\n    \"\"\"Compute the curvature of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#pymdna.nucleic.compute_groove_width","title":"<code>compute_groove_width(traj, chainids=[0, 1])</code>","text":"<p>Compute the groove width of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_groove_width(traj, chainids=[0,1]):\n    \"\"\"Compute the groove width of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#pymdna.nucleic.compute_linking_number","title":"<code>compute_linking_number(traj, chainids=[0, 1])</code>","text":"<p>Compute the linking number of the DNA structure</p> Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_linking_number(traj, chainids=[0,1]):\n    \"\"\"Compute the linking number of the DNA structure\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#pymdna.nucleic.compute_rigid_parameters","title":"<code>compute_rigid_parameters(traj, chainids=[0, 1])</code>","text":"<p>Compute the rigid base parameters of the DNA structure.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure.</p> required <code>chainids</code> <code>list</code> <p>List of chain IDs of the DNA structure. Default is [0, 1].</p> <code>[0, 1]</code> <p>Returns:</p> Name Type Description <code>NucleicFrames</code> <code>object</code> <p>Object representing the rigid base parameters of the DNA structure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the traj argument is not provided.</p> Notes <ul> <li>The traj argument must be provided.</li> <li>The chainids argument is optional and defaults to [0, 1].</li> <li>The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def compute_rigid_parameters(traj, chainids=[0,1]):\n    \"\"\"Compute the rigid base parameters of the DNA structure.\n\n    Args:\n        traj (object): MDtraj trajectory containing the DNA structure.\n        chainids (list, optional): List of chain IDs of the DNA structure. Default is [0, 1].\n\n    Returns:\n        NucleicFrames (object): Object representing the rigid base parameters of the DNA structure.\n\n    Raises:\n        ValueError: If the traj argument is not provided.\n\n    Notes:\n        - The traj argument must be provided.\n        - The chainids argument is optional and defaults to [0, 1].\n        - The returned NucleicFrames object contains information about the rigid base parameters of the DNA structure, such as the positions and orientations of the base steps.\n\n    Example:\n        # Compute the rigid base parameters of a DNA structure\n        traj = md.load('dna.pdb')\n        rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])\"\"\"\n    if traj is None:\n        raise ValueError(\"The traj argument must be provided.\")\n    return NucleicFrames(traj, chainids)\n</code></pre>"},{"location":"reference/#pymdna.nucleic.compute_rigid_parameters--compute-the-rigid-base-parameters-of-a-dna-structure","title":"Compute the rigid base parameters of a DNA structure","text":"<p>traj = md.load('dna.pdb') rigid_params = compute_rigid_parameters(traj, chainids=[0, 1])</p>"},{"location":"reference/#pymdna.nucleic.connect","title":"<code>connect(Nucleic0, Nucleic1, sequence=None, n_bp=None, leader=0, frame=-1, margin=1, minimize=True, exvol_rad=0.0, temperature=300)</code>","text":"<p>Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.</p> <p>The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure. To connect the two strands, a straight line is interpolated between the two ends, and the optimal number of base pairs is distributed to achieve a neutral twist.</p> <p>Note: The minimization does not use excluded volume interactions by default. This is because the excluded volume interactions require the EV beads to have no overlap. However, in the initial configuration, the EV beads are likely to have overlap. If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.</p> <p>Parameters:</p> Name Type Description Default <code>Nucleic0</code> <code>Nucleic</code> <p>First DNA structure to connect.</p> required <code>Nucleic1</code> <code>Nucleic</code> <p>Second DNA structure to connect.</p> required <code>sequence</code> <code>str</code> <p>DNA sequence of the connecting DNA strand. Default is None.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs of the connecting DNA strand. Default is None.</p> <code>None</code> <code>leader</code> <code>int</code> <p>The leader of the DNA structure to connect. Default is 0.</p> <code>0</code> <code>frame</code> <code>int</code> <p>The time frame to connect. Default is -1.</p> <code>-1</code> <code>margin</code> <code>int</code> <p>Number of base pairs to fix at the end. Default is 1.</p> <code>1</code> <code>minimize</code> <code>bool</code> <p>Whether to minimize the new DNA structure. Default is True.</p> <code>True</code> <code>exvol_rad</code> <code>float</code> <p>Radius for excluded volume interactions during minimization. Default is 0.0.</p> <code>0.0</code> <code>temperature</code> <code>int</code> <p>Temperature for minimization. Default is 300.</p> <code>300</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure with the two DNA structures connected.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either of the DNA structures is circular.</p> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def connect(Nucleic0, Nucleic1, sequence: str = None, n_bp: int = None, leader: int = 0, frame: int = -1, margin: int = 1, minimize: bool = True, exvol_rad: float = 0.0, temperature: int = 300):\n    \"\"\"Connect two DNA structures by creating a new DNA structure with a connecting DNA strand.\n\n    The 3' end of the first DNA structure is connected to the 5' end of the second DNA structure.\n    To connect the two strands, a straight line is interpolated between the two ends,\n    and the optimal number of base pairs is distributed to achieve a neutral twist.\n\n    Note:\n    The minimization does not use excluded volume interactions by default.\n    This is because the excluded volume interactions require the EV beads to have no overlap.\n    However, in the initial configuration, the EV beads are likely to have overlap.\n    If desired, the resulting Nucleic object can be further minimized with the excluded volume interactions.\n\n    Args:\n        Nucleic0 (Nucleic): First DNA structure to connect.\n        Nucleic1 (Nucleic): Second DNA structure to connect.\n        sequence (str, optional): DNA sequence of the connecting DNA strand. Default is None.\n        n_bp (int, optional): Number of base pairs of the connecting DNA strand. Default is None.\n        leader (int, optional): The leader of the DNA structure to connect. Default is 0.\n        frame (int, optional): The time frame to connect. Default is -1.\n        margin (int, optional): Number of base pairs to fix at the end. Default is 1.\n        minimize (bool, optional): Whether to minimize the new DNA structure. Default is True.\n        exvol_rad (float, optional): Radius for excluded volume interactions during minimization. Default is 0.0.\n        temperature (int, optional): Temperature for minimization. Default is 300.\n\n    Returns:\n        Nucleic (object): DNA structure with the two DNA structures connected.\n\n    Raises:\n        ValueError: If either of the DNA structures is circular.\n\n    Example:\n        # Connect two DNA structures\n        connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)\n    \"\"\"\n    if Nucleic0.circular or Nucleic1.circular:\n        raise ValueError('Cannot connect circular DNA structures')\n\n    if sequence is not None and n_bp is None:\n        n_bp = len(sequence)\n\n    # Connect the two DNA structures\n    connector = Connector(Nucleic0, Nucleic1, sequence=sequence, n_bp=n_bp, leader=leader, frame=frame, margin=margin)\n    if minimize:\n        connector.connected_nuc.minimize(exvol_rad=exvol_rad, temperature=temperature, fixed=connector.fixed)\n    return connector.connected_nuc\n</code></pre>"},{"location":"reference/#pymdna.nucleic.connect--connect-two-dna-structures","title":"Connect two DNA structures","text":"<p>connected_dna = connect(Nucleic0, Nucleic1, sequence='ATCG', n_bp=4, leader=0, frame=-1, margin=2, minimize=True, exvol_rad=0.5, temperature=310)</p>"},{"location":"reference/#pymdna.nucleic.load","title":"<code>load(traj=None, frames=None, sequence=None, chainids=[0, 1], circular=None)</code>","text":"<p>Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>object</code> <p>MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>frames</code> <code>array</code> <p>Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)</p> <code>None</code> <code>sequence</code> <code>str</code> <p>DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)</p> <code>None</code> <code>chainids</code> <code>list</code> <p>Chain IDs of the DNA structure. (default: [0,1])</p> <code>[0, 1]</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>If traj is provided, the frames and sequence arguments are ignored.</li> <li>If frames is provided, the traj and sequence arguments are ignored.</li> <li>If sequence is provided, the traj and frames arguments are ignored.</li> <li>If circular is not provided, it will be determined based on the input data.</li> </ul> Source code in <code>pymdna/nucleic.py</code> <pre><code>def load(traj=None, frames=None, sequence=None, chainids=[0,1], circular=None):\n    \"\"\"Load DNA representation from either base step mean reference frames/spline frames or an MDtraj trajectory.\n\n    Args:\n        traj (object, optional): MDtraj trajectory containing the DNA structure. If provided, the frames and sequence arguments are ignored. (default: None)\n        frames (np.array, optional): Base step mean reference frames of shape (n_bp, n_timesteps, 4, 3) or (n_bp, 4, 3). If provided, the traj and sequence arguments are ignored. (default: None)\n        sequence (str, optional): DNA sequence. If provided, the traj and frames arguments are ignored. (default: None)\n        chainids (list, optional): Chain IDs of the DNA structure. (default: [0,1])\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If not provided, it will be determined based on the input data. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - If traj is provided, the frames and sequence arguments are ignored.\n        - If frames is provided, the traj and sequence arguments are ignored.\n        - If sequence is provided, the traj and frames arguments are ignored.\n        - If circular is not provided, it will be determined based on the input data.\n    \"\"\"\n    return Nucleic(sequence=sequence, n_bp=None, traj=traj, frames=frames, chainids=chainids, circular=None)\n</code></pre>"},{"location":"reference/#pymdna.nucleic.make","title":"<code>make(sequence=None, control_points=None, circular=False, closed=False, n_bp=None, dLk=None)</code>","text":"<p>Generate a DNA structure from a given DNA sequence and control points.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)</p> <code>None</code> <code>control_points</code> <code>ndarray</code> <p>Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)</p> <code>False</code> <code>closed</code> <code>bool</code> <p>Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)</p> <code>False</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)</p> <code>None</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Nucleic</code> <code>object</code> <p>DNA structure object.</p> Notes <ul> <li>If control_points are provided, the sequence argument is ignored.</li> <li>If sequence is provided, the control_points argument is ignored.</li> <li>If circular is True, the DNA structure will be closed.</li> <li>If circular is False, the DNA structure will be open.</li> <li>The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.</li> </ul> Source code in <code>pymdna/nucleic.py</code> <pre><code>def make(sequence: str = None, control_points: np.ndarray = None, circular : bool = False, closed: bool = False, n_bp : int = None, dLk : int = None):\n    \"\"\"Generate a DNA structure from a given DNA sequence and control points.\n\n    Args:\n        sequence (str, optional): DNA sequence code. If not provided, the default sequence 'CGCGAATTCGCG' will be used. (default: None)\n        control_points (ndarray, optional): Control points of the DNA structure. Should be a numpy array of shape (n, 3) where n is the number of control points. If not provided, a straight line will be used as the default control points. (default: None)\n        circular (bool, optional): Flag indicating if the DNA structure is circular/closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. (default: False)\n        closed (bool, optional): Flag indicating if the DNA structure is closed. If True, the DNA structure will be closed. If False, the DNA structure will be open. This argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead. (default: False)\n        n_bp (int, optional): Number of base pairs to scale the shape with. If not provided, the number of base pairs will be determined based on the length of the control points or the sequence. (default: None)\n        dLk (int, optional): Change in twist in terms of Linking number of the DNA structure. If not provided, a neutral twist based on bp_per_turn = 10.5 will be used. (default: None)\n\n    Returns:\n        Nucleic (object): DNA structure object.\n\n    Notes:\n        - If control_points are provided, the sequence argument is ignored.\n        - If sequence is provided, the control_points argument is ignored.\n        - If circular is True, the DNA structure will be closed.\n        - If circular is False, the DNA structure will be open.\n        - The closed argument is deprecated and will be removed in a future version. Please use the 'circular' argument instead.\n    \"\"\"\n\n    # Check if control points are provided, otherwise generate a straight line\n    if control_points is not None:\n        if len(control_points) &lt; 4:\n            raise ValueError('Control points should contain at least 4 points [x, y, z]')\n        elif len(control_points) &gt; 4 and n_bp is None:\n            n_bp = len(control_points)  # Number of base pairs\n    elif control_points is None and circular:\n        control_points = Shapes.circle(radius=1)\n        closed = True\n    else:\n        # Linear strand of control points\n        control_points = Shapes.line(length=1)\n\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n    spline = SplineFrames(control_points=control_points, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    return Nucleic(sequence=sequence, n_bp=n_bp, frames=spline.frames, chainids=[0, 1], circular=circular)\n</code></pre>"},{"location":"reference/#pymdna.nucleic.sequence_to_md","title":"<code>sequence_to_md(sequence=None, time=10, time_unit='picoseconds', temperature=310, solvated=False, filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)</code>","text":"<p>Simulate DNA sequence using OpenMM.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>DNA sequence code.</p> <code>None</code> <code>time</code> <code>int</code> <p>Simulation time.</p> <code>10</code> <code>time_unit</code> <code>str</code> <p>Time unit (picoseconds or nanoseconds).</p> <code>'picoseconds'</code> <code>temperature</code> <code>int</code> <p>Temperature in Kelvin.</p> <code>310</code> <code>solvated</code> <code>bool</code> <p>Solvate DNA with water and ions.</p> <code>False</code> <code>filename</code> <code>str</code> <p>Filename for pdb output.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Save the trajectory.</p> <code>True</code> <code>output</code> <code>str</code> <p>Output format for the trajectory (GROMACS or HDF5).</p> <code>'GROMACS'</code> <code>shape</code> <code>str</code> <p>Shape of the DNA structure (linear or circular).</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs in the DNA structure.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Flag indicating if the DNA structure is circular.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in linking number of the DNA structure.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MDTraj</code> <code>object</code> <p>MDtraj trajectory object of DNA structure.</p> Notes <ul> <li>This function uses the OpenMM library to simulate the behavior of a DNA sequence.</li> <li>The simulation can be performed for a specified time period at a given temperature.</li> <li>The DNA structure can be solvated with water and ions.</li> <li>The trajectory of the simulation can be saved in either GROMACS or HDF5 format.</li> <li>The shape of the DNA structure can be specified as linear or circular.</li> <li>The number of base pairs in the DNA structure can be provided.</li> <li>The change in linking number of the DNA structure can be specified.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def sequence_to_md(sequence=None, time=10, time_unit='picoseconds',temperature=310, solvated=False,  filename='my_dna', save=True, output='GROMACS',shape=None,n_bp=None,circular=False,dLk=None):\n    \"\"\"Simulate DNA sequence using OpenMM.\n\n        Args:\n            sequence (str): DNA sequence code.\n            time (int): Simulation time.\n            time_unit (str): Time unit (picoseconds or nanoseconds).\n            temperature (int): Temperature in Kelvin.\n            solvated (bool): Solvate DNA with water and ions.\n            filename (str): Filename for pdb output.\n            save (bool): Save the trajectory.\n            output (str): Output format for the trajectory (GROMACS or HDF5).\n            shape (str): Shape of the DNA structure (linear or circular).\n            n_bp (int): Number of base pairs in the DNA structure.\n            circular (bool): Flag indicating if the DNA structure is circular.\n            dLk (int): Change in linking number of the DNA structure.\n\n        Returns:\n            MDTraj (object): MDtraj trajectory object of DNA structure.\n\n        Notes:\n            - This function uses the OpenMM library to simulate the behavior of a DNA sequence.\n            - The simulation can be performed for a specified time period at a given temperature.\n            - The DNA structure can be solvated with water and ions.\n            - The trajectory of the simulation can be saved in either GROMACS or HDF5 format.\n            - The shape of the DNA structure can be specified as linear or circular.\n            - The number of base pairs in the DNA structure can be provided.\n            - The change in linking number of the DNA structure can be specified.\n\n        Example:\n            # Simulate a linear DNA structure for 100 picoseconds at 300 K\n            trajectory = sequence_to_md(sequence='ATCG', time=100, time_unit='picoseconds', temperature=300, shape='linear')\n        \"\"\"\n\n    # TODO update with make function\n    try:\n        import openmm as mm\n        import openmm.app as app\n        import openmm.unit as unit\n        from mdtraj.reporters import HDF5Reporter\n        import mdtraj as md\n        openmm_available = True\n    except ImportError:\n        openmm_available = False\n        print(\"Openmm is not installed. You shall not pass.\")\n\n    pdb = sequence_to_pdb(sequence=sequence, filename='my_dna', save=True, output='GROMACS',shape=None,n_bp=None,circular=False,dLk=None)\n\n    if not openmm_available:\n        print('But here is your DNA structure')\n        return pdb\n    else:\n        if time_unit == 'picoseconds':\n            time_unit = time * unit.picoseconds\n        elif time_unit == 'nanoseconds':\n            time_unit = time * unit.nanoseconds\n\n        time = time * time_unit\n        time_step = 2 * unit.femtoseconds\n        temperature = 310 *unit.kelvin\n        steps = int(time/time_step)\n\n        print(f'Initialize DNA openMM simulation at {temperature._value} K for', time, 'time units')\n        topology = pdb.topology.to_openmm()\n        modeller = app.Modeller(topology, pdb.xyz[0])\n\n        forcefield = app.ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')\n        modeller.addHydrogens(forcefield)\n        if solvated:\n            print('Solvate DNA with padding of 1.0 nm and 0.1 M KCl')\n            modeller.addSolvent(forcefield, padding=1.0*unit.nanometers, ionicStrength=0.1*unit.molar, positiveIon='K+')\n\n        system = forcefield.createSystem(modeller.topology, nonbondedMethod=app.CutoffNonPeriodic)\n        integrator = mm.LangevinIntegrator(temperature, 1.0/unit.picoseconds, time_step)\n\n        simulation = app.Simulation(modeller.topology, system, integrator)\n        simulation.context.setPositions(modeller.positions)\n        simulation.reporters.append(HDF5Reporter(f'./{sequence}'+'.h5', 100))\n        simulation.reporters.append(app.StateDataReporter(f'./output_{sequence}.csv', 100, step=True, potentialEnergy=True, temperature=True,speed=True))\n\n        print('Minimize energy')\n        simulation.minimizeEnergy()\n\n        print('Run simulation for', steps, 'steps')\n        simulation.step(steps)\n        simulation.reporters[0].close()\n        print('Simulation completed')\n        print('Saved trajectory as:', f'./{sequence}'+'.h5')\n        traj = md.load_hdf5(f'./{sequence}'+'.h5')\n        return traj\n</code></pre>"},{"location":"reference/#pymdna.nucleic.sequence_to_md--simulate-a-linear-dna-structure-for-100-picoseconds-at-300-k","title":"Simulate a linear DNA structure for 100 picoseconds at 300 K","text":"<p>trajectory = sequence_to_md(sequence='ATCG', time=100, time_unit='picoseconds', temperature=300, shape='linear')</p>"},{"location":"reference/#pymdna.nucleic.sequence_to_pdb","title":"<code>sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)</code>","text":"<p>Generate a DNA structure from a DNA sequence code.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The DNA sequence code. Default is 'CGCGAATTCGCG'.</p> <code>'CGCGAATTCGCG'</code> <code>filename</code> <code>str</code> <p>The filename for the pdb output. Default is 'my_dna'.</p> <code>'my_dna'</code> <code>save</code> <code>bool</code> <p>Whether to save the pdb file. Default is True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The type of pdb DNA format. Default is 'GROMACS'.</p> <code>'GROMACS'</code> <code>shape</code> <code>ndarray</code> <p>Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.</p> <code>None</code> <code>n_bp</code> <code>int</code> <p>Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.</p> <code>None</code> <code>circular</code> <code>bool</code> <p>Indicates if the structure is circular/closed. Default is False.</p> <code>False</code> <code>dLk</code> <code>int</code> <p>Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.</p> <code>None</code> <p>Returns:</p> Type Description <code>Trajectory</code> <p>md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence is not provided.</p> Notes <ul> <li>The sequence argument must be provided.</li> <li>The returned MDtraj object contains the DNA structure generated from the sequence and control points.</li> <li>If the output is set to 'GROMACS', the DNA structure is edited to make it compatible with the AMBER force field.</li> <li>The pdb file is saved in the current directory with the specified filename.</li> </ul> Example Source code in <code>pymdna/nucleic.py</code> <pre><code>def sequence_to_pdb(sequence: str = 'CGCGAATTCGCG', filename: str = 'my_dna', save: bool = True, output: str = 'GROMACS', shape: np.ndarray = None, n_bp: int = None, circular: bool = False, dLk: int = None) -&gt; md.Trajectory:\n    \"\"\"Generate a DNA structure from a DNA sequence code.\n\n    Args:\n        sequence (str, optional): The DNA sequence code. Default is 'CGCGAATTCGCG'.\n        filename (str, optional): The filename for the pdb output. Default is 'my_dna'.\n        save (bool, optional): Whether to save the pdb file. Default is True.\n        output (str, optional): The type of pdb DNA format. Default is 'GROMACS'.\n        shape (np.ndarray, optional): Control points of shape (n,3) with n &gt; 3 that is used for spline interpolation to determine DNA shape. Default is None, which is a straight line.\n        n_bp (int, optional): Number of base pairs to scale shape with. Default is None, then the sequence is used to determine n_bp.\n        circular (bool, optional): Indicates if the structure is circular/closed. Default is False.\n        dLk (int, optional): Change in twist in terms of Linking number of DNA structure to output. Default is None, which corresponds to a neutral twist based on bp_per_turn = 10.5.\n\n    Returns:\n        md.Trajectory: An MDtraj trajectory object of the DNA structure (containing only a single frame).\n\n    Raises:\n        ValueError: If the sequence is not provided.\n\n    Notes:\n        - The sequence argument must be provided.\n        - The returned MDtraj object contains the DNA structure generated from the sequence and control points.\n        - If the output is set to 'GROMACS', the DNA structure is edited to make it compatible with the AMBER force field.\n        - The pdb file is saved in the current directory with the specified filename.\n\n    Example:\n        # Generate a DNA structure from a sequence\n        traj = sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)\n    \"\"\"\n\n    # Check if the sequence is provided\n    if sequence is None:\n        raise ValueError(\"The sequence argument must be provided.\")\n\n    # TODO: Update with make function\n    sequence, n_bp = _check_input(sequence=sequence, n_bp=n_bp)\n\n    # Linear strand of control points\n    if shape is None:\n        shape = Shapes.line(length=1)\n\n    # Convert the control points to a spline\n    spline = SplineFrames(control_points=shape, n_bp=n_bp, closed=circular, dLk=dLk)\n\n    # Generate the DNA structure\n    generator = StructureGenerator(sequence=sequence, spline=spline, circular=circular)\n\n    # Edit the DNA structure to make it compatible with the AMBER force field\n    traj = generator.traj\n    if output == 'GROMACS':\n        phosphor_termini = traj.top.select(f'name P OP1 OP2 and resid 0 {traj.top.chain(0).n_residues}')\n        all_atoms = traj.top.select('all')\n        traj = traj.atom_slice([at for at in all_atoms if at not in phosphor_termini])\n\n    # Save the DNA structure as a pdb file\n    if save:\n        traj.save(f'./{filename}.pdb')\n\n    return traj\n</code></pre>"},{"location":"reference/#pymdna.nucleic.sequence_to_pdb--generate-a-dna-structure-from-a-sequence","title":"Generate a DNA structure from a sequence","text":"<p>traj = sequence_to_pdb(sequence='CGCGAATTCGCG', filename='my_dna', save=True, output='GROMACS', shape=None, n_bp=None, circular=False, dLk=None)</p>"},{"location":"shapes-reference/","title":"Shapes class","text":"<p>Class for generating parametric shapes in 3D space.</p> Source code in <code>pymdna/utils.py</code> <pre><code>class Shapes:\n    \"\"\"Class for generating parametric shapes in 3D space.\n    \"\"\"\n\n    def __init__(self, parametric_function, t_values=None, num_points=100):\n        self.num_points = num_points\n        self.parametric_function = parametric_function\n        self.points = self._generate_points(t_values)\n\n    def _generate_points(self,t_values=None):\n        x_values, y_values, z_values = self.parametric_function(t_values)\n        return np.stack((x_values, y_values, z_values), axis=1)\n\n    @classmethod\n    def circle(cls, radius=1, t_values=None, num_points=100):\n        \"\"\"Create a circle in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the circle of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * np.cos(t_values),\n            radius * np.sin(t_values),\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def line(cls, length=1, num_points=100):\n        \"\"\"Create a line in 3D space.\n\n        Args:\n            length (int, optional): _description_. Defaults to 1.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the line of shape (num_points, 3)\n        \"\"\"\n        t_values = np.linspace(0, 1, num=num_points)\n        parametric_function = lambda t_values: (\n            t_values * length,\n            np.zeros_like(t_values),\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def helix(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n        \"\"\"Create a helix in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            pitch (int, optional): _description_. Defaults to 1.\n            height (int, optional): _description_. Defaults to 1.\n            num_turns (int, optional): _description_. Defaults to 1.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the helix of shape (num_points, 3)\n        \"\"\"\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * np.cos(t_values),\n            radius * np.sin(t_values),\n            height * t_values / (2 * np.pi) - pitch * num_turns * t_values / (2 * np.pi)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def spiral(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n        \"\"\"Create a spiral in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            pitch (int, optional): _description_. Defaults to 1.\n            height (int, optional): _description_. Defaults to 1.\n            num_turns (int, optional): _description_. Defaults to 1.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the spiral of shape (num_points, 3)\n        \"\"\"\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        parametric_function = lambda t_values: (\n            radius * t_values * np.cos(t_values),\n            radius * t_values * np.sin(t_values),\n            height * t_values / (2 * np.pi) * pitch\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def mobius_strip(cls, radius=1, width=0.5, num_twists=1, t_values=None, num_points=100):\n        \"\"\"Create a Mobius strip in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            width (float, optional): _description_. Defaults to 0.5.\n            num_twists (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the Mobius strip of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        u_values = np.linspace(0, width, num=num_points)\n        u, t = np.meshgrid(u_values, t_values)\n        x_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.cos(t)\n        y_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.sin(t)\n        z_values = u * np.sin(t / 2) * np.cos(num_twists * t)\n        parametric_function = lambda t_values: (\n            x_values.flatten(),\n            y_values.flatten(),\n            z_values.flatten()\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def square(cls, side_length=1,t_values=None,num_points=100):\n        \"\"\"Create a square in 3D space.\n\n        Args:\n            side_length (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the square of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 1, num=num_points)\n        parametric_function = lambda t_values: (\n            side_length * (2 * (t_values &lt; 0.25) - 1),\n            side_length * (2 * (t_values &gt;= 0.25) &amp; (t_values &lt; 0.5)) - side_length,\n            np.zeros_like(t_values)\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def trefoil(cls, radius=1, num_turns=1,t_values=None,num_points=100):\n        \"\"\"Create a trefoil knot in 3D space.\n\n        Args:\n            radius (int, optional): _description_. Defaults to 1.\n            num_turns (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the trefoil knot of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n        x_values = np.sin(t_values) + 2 * np.sin(2 * t_values)\n        y_values = np.cos(t_values) - 2 * np.cos(2 * t_values)\n        z_values = -np.sin(3 * t_values)\n        parametric_function = lambda t_values: (\n            radius * x_values,\n            radius * y_values,\n            radius * z_values\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def square(cls, side=1, t_values=None,num_points=100):\n        \"\"\"Create a square in 3D space.\n\n        Args:\n            side (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the square of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 4, num=num_points)\n        # Calculate x and y coordinates based on t_values\n        x_values = np.zeros_like(t_values)\n        y_values = np.zeros_like(t_values)\n        for i, t in enumerate(t_values):\n            if 0 &lt;= t &lt; 1:\n                x_values[i] = t * side\n                y_values[i] = 0\n            elif 1 &lt;= t &lt; 2:\n                x_values[i] = side\n                y_values[i] = (t - 1) * side\n            elif 2 &lt;= t &lt; 3:\n                x_values[i] = (3 - t) * side\n                y_values[i] = side\n            elif 3 &lt;= t &lt;= 4:\n                x_values[i] = 0\n                y_values[i] = (4 - t) * side\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (\n            x_values,\n            y_values,\n            z_values\n        )\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def heart(cls, a=1, b=1, c=1,t_values=None,num_points=100):\n        \"\"\"Create a heart shape in 3D space.\n\n        Args:\n            a (int, optional): _description_. Defaults to 1.\n            b (int, optional): _description_. Defaults to 1.\n            c (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the heart shape of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(-np.pi, np.pi, num=num_points)\n        x_values = a * np.sin(t_values) ** 3\n        y_values = b * np.cos(t_values) - c * np.cos(2 * t_values)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def ellipse(cls, a=1, b=1, t_values=None,num_points=100):\n        \"\"\"Create an ellipse in 3D space.\n\n        Args:\n            a (int, optional): _description_. Defaults to 1.\n            b (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the ellipse of shape (num_points, 3) \n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        x_values = a * np.cos(t_values)\n        y_values = b * np.sin(t_values)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def lemniscate_of_bernoulli(cls, a=1, b=1, t_values=None,num_points=100):\n        \"\"\"Create a lemniscate of Bernoulli in 3D space.\n\n        Args:\n            a (int, optional): _description_. Defaults to 1.\n            b (int, optional): _description_. Defaults to 1.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the leminscate of Bernouli of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        x_values = a * np.sqrt(2) * np.cos(t_values) / (np.sin(t_values) ** 2 + 1)\n        y_values = b * np.sqrt(2) * np.cos(t_values) * np.sin(t_values) / (np.sin(t_values) ** 2 + 1)\n        z_values = np.zeros_like(t_values)\n        parametric_function = lambda t_values: (x_values, y_values, z_values)\n        return cls(parametric_function, t_values).points\n\n    @classmethod\n    def torus_helix(cls, R=1, r=2, num_windings=3, t_values=None, num_points=100):\n        \"\"\"Create a torus helix in 3D space.\n\n        Args:\n            R (int, optional): _description_. Defaults to 1.\n            r (int, optional): _description_. Defaults to 2.\n            num_windings (int, optional): _description_. Defaults to 3.\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the torus helix of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n\n        parametric_function = lambda t_values: (\n            (R + r * np.cos(num_windings*t_values)) * np.cos( t_values),\n            (R + r * np.cos(num_windings*t_values)) * np.sin( t_values),\n            r * np.sin(t_values)\n        )\n        return cls(parametric_function, t_values, num_points=num_points).points\n\n    @classmethod\n    def bonus(cls, t_values=None,num_points=100):\n        \"\"\"Create a bonus shape in 3D space.\n\n        Credit: https://www.geogebra.org/m/pH8wD3rW, Author:Simona Riva\"\n\n        Args:\n            t_values (_type_, optional): _description_. Defaults to None.\n            num_points (int, optional): _description_. Defaults to 100.\n\n        Returns:\n            points (np.ndarray): points on the bonus function of shape (num_points, 3)\n        \"\"\"\n        if t_values is None:\n            t_values = np.linspace(0, 2 * np.pi, num=num_points)\n        t = t_values\n        parametric_function = lambda t: (\n                                        -(721*np.sin(t))/4 + 196/3*np.sin(2*t) - 86/3*np.sin(3*t) - 131/2*np.sin(4*t) + 477/14*np.sin(5*t) \n                                        + 27*np.sin(6*t) - 29/2*np.sin(7*t) + 68/5*np.sin(8*t) + 1/10*np.sin(9*t) + 23/4*np.sin(10*t) \n                                        - 19/2*np.sin(12*t) - 85/21*np.sin(13*t) + 2/3*np.sin(14*t) + 27/5*np.sin(15*t) + 7/4*np.sin(16*t) \n                                        + 17/9*np.sin(17*t) - 4*np.sin(18*t) - 1/2*np.sin(19*t) + 1/6*np.sin(20*t) + 6/7*np.sin(21*t) \n                                        - 1/8*np.sin(22*t) + 1/3*np.sin(23*t) + 3/2*np.sin(24*t) + 13/5*np.sin(25*t) + np.sin(26*t) \n                                        - 2*np.sin(27*t) + 3/5*np.sin(28*t) - 1/5*np.sin(29*t) + 1/5*np.sin(30*t) + (2337*np.cos(t))/8 \n                                        - 43/5*np.cos(2*t) + 322/5*np.cos(3*t) - 117/5*np.cos(4*t) - 26/5*np.cos(5*t) - 23/3*np.cos(6*t) \n                                        + 143/4*np.cos(7*t) - 11/4*np.cos(8*t) - 31/3*np.cos(9*t) - 13/4*np.cos(10*t) - 9/2*np.cos(11*t) \n                                        + 41/20*np.cos(12*t) + 8*np.cos(13*t) + 2/3*np.cos(14*t) + 6*np.cos(15*t) + 17/4*np.cos(16*t) \n                                        - 3/2*np.cos(17*t) - 29/10*np.cos(18*t) + 11/6*np.cos(19*t) + 12/5*np.cos(20*t) + 3/2*np.cos(21*t) \n                                        + 11/12*np.cos(22*t) - 4/5*np.cos(23*t) + np.cos(24*t) + 17/8*np.cos(25*t) - 7/2*np.cos(26*t) \n                                        - 5/6*np.cos(27*t) - 11/10*np.cos(28*t) + 1/2*np.cos(29*t) - 1/5*np.cos(30*t),\n                                        -(637/2)*np.sin(t) - (188/5)*np.sin(2*t) - (11/7)*np.sin(3*t) - (12/5)*np.sin(4*t) + (11/3)*np.sin(5*t)\n                                        - (37/4)*np.sin(6*t) + (8/3)*np.sin(7*t) + (65/6)*np.sin(8*t) - (32/5)*np.sin(9*t) - (41/4)*np.sin(10*t)\n                                        - (38/3)*np.sin(11*t) - (47/8)*np.sin(12*t) + (5/4)*np.sin(13*t) - (41/7)*np.sin(14*t) - (7/3)*np.sin(15*t)\n                                        - (13/7)*np.sin(16*t) + (17/4)*np.sin(17*t) - (9/4)*np.sin(18*t) + (8/9)*np.sin(19*t) + (3/5)*np.sin(20*t)\n                                        - (2/5)*np.sin(21*t) + (4/3)*np.sin(22*t) + (1/3)*np.sin(23*t) + (3/5)*np.sin(24*t) - (3/5)*np.sin(25*t)\n                                        + (6/5)*np.sin(26*t) - (1/5)*np.sin(27*t) + (10/9)*np.sin(28*t) + (1/3)*np.sin(29*t) - (3/4)*np.sin(30*t)\n                                        - (125/2)*np.cos(t) - (521/9)*np.cos(2*t) - (359/3)*np.cos(3*t) + (47/3)*np.cos(4*t) - (33/2)*np.cos(5*t)\n                                        - (5/4)*np.cos(6*t) + (31/8)*np.cos(7*t) + (9/10)*np.cos(8*t) - (119/4)*np.cos(9*t) - (17/2)*np.cos(10*t)\n                                        + (22/3)*np.cos(11*t) + (15/4)*np.cos(12*t) - (5/2)*np.cos(13*t) + (19/6)*np.cos(14*t) + (7/4)*np.cos(15*t)\n                                        + (31/4)*np.cos(16*t) - np.cos(17*t) + (11/10)*np.cos(18*t) - (2/3)*np.cos(19*t) + (13/3)*np.cos(20*t)\n                                        - (5/4)*np.cos(21*t) + (2/3)*np.cos(22*t) + (1/4)*np.cos(23*t) + (5/6)*np.cos(24*t) + (3/4)*np.cos(26*t)\n                                        - (1/2)*np.cos(27*t) - (1/10)*np.cos(28*t) - (1/3)*np.cos(29*t) - (1/19)*np.cos(30*t),\n                                        np.zeros_like(t))\n        return cls(parametric_function, t_values).points*0.1\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.bonus","title":"<code>bonus(t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a bonus shape in 3D space.</p> <p>Credit: https://www.geogebra.org/m/pH8wD3rW, Author:Simona Riva\"</p> <p>Parameters:</p> Name Type Description Default <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the bonus function of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef bonus(cls, t_values=None,num_points=100):\n    \"\"\"Create a bonus shape in 3D space.\n\n    Credit: https://www.geogebra.org/m/pH8wD3rW, Author:Simona Riva\"\n\n    Args:\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the bonus function of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    t = t_values\n    parametric_function = lambda t: (\n                                    -(721*np.sin(t))/4 + 196/3*np.sin(2*t) - 86/3*np.sin(3*t) - 131/2*np.sin(4*t) + 477/14*np.sin(5*t) \n                                    + 27*np.sin(6*t) - 29/2*np.sin(7*t) + 68/5*np.sin(8*t) + 1/10*np.sin(9*t) + 23/4*np.sin(10*t) \n                                    - 19/2*np.sin(12*t) - 85/21*np.sin(13*t) + 2/3*np.sin(14*t) + 27/5*np.sin(15*t) + 7/4*np.sin(16*t) \n                                    + 17/9*np.sin(17*t) - 4*np.sin(18*t) - 1/2*np.sin(19*t) + 1/6*np.sin(20*t) + 6/7*np.sin(21*t) \n                                    - 1/8*np.sin(22*t) + 1/3*np.sin(23*t) + 3/2*np.sin(24*t) + 13/5*np.sin(25*t) + np.sin(26*t) \n                                    - 2*np.sin(27*t) + 3/5*np.sin(28*t) - 1/5*np.sin(29*t) + 1/5*np.sin(30*t) + (2337*np.cos(t))/8 \n                                    - 43/5*np.cos(2*t) + 322/5*np.cos(3*t) - 117/5*np.cos(4*t) - 26/5*np.cos(5*t) - 23/3*np.cos(6*t) \n                                    + 143/4*np.cos(7*t) - 11/4*np.cos(8*t) - 31/3*np.cos(9*t) - 13/4*np.cos(10*t) - 9/2*np.cos(11*t) \n                                    + 41/20*np.cos(12*t) + 8*np.cos(13*t) + 2/3*np.cos(14*t) + 6*np.cos(15*t) + 17/4*np.cos(16*t) \n                                    - 3/2*np.cos(17*t) - 29/10*np.cos(18*t) + 11/6*np.cos(19*t) + 12/5*np.cos(20*t) + 3/2*np.cos(21*t) \n                                    + 11/12*np.cos(22*t) - 4/5*np.cos(23*t) + np.cos(24*t) + 17/8*np.cos(25*t) - 7/2*np.cos(26*t) \n                                    - 5/6*np.cos(27*t) - 11/10*np.cos(28*t) + 1/2*np.cos(29*t) - 1/5*np.cos(30*t),\n                                    -(637/2)*np.sin(t) - (188/5)*np.sin(2*t) - (11/7)*np.sin(3*t) - (12/5)*np.sin(4*t) + (11/3)*np.sin(5*t)\n                                    - (37/4)*np.sin(6*t) + (8/3)*np.sin(7*t) + (65/6)*np.sin(8*t) - (32/5)*np.sin(9*t) - (41/4)*np.sin(10*t)\n                                    - (38/3)*np.sin(11*t) - (47/8)*np.sin(12*t) + (5/4)*np.sin(13*t) - (41/7)*np.sin(14*t) - (7/3)*np.sin(15*t)\n                                    - (13/7)*np.sin(16*t) + (17/4)*np.sin(17*t) - (9/4)*np.sin(18*t) + (8/9)*np.sin(19*t) + (3/5)*np.sin(20*t)\n                                    - (2/5)*np.sin(21*t) + (4/3)*np.sin(22*t) + (1/3)*np.sin(23*t) + (3/5)*np.sin(24*t) - (3/5)*np.sin(25*t)\n                                    + (6/5)*np.sin(26*t) - (1/5)*np.sin(27*t) + (10/9)*np.sin(28*t) + (1/3)*np.sin(29*t) - (3/4)*np.sin(30*t)\n                                    - (125/2)*np.cos(t) - (521/9)*np.cos(2*t) - (359/3)*np.cos(3*t) + (47/3)*np.cos(4*t) - (33/2)*np.cos(5*t)\n                                    - (5/4)*np.cos(6*t) + (31/8)*np.cos(7*t) + (9/10)*np.cos(8*t) - (119/4)*np.cos(9*t) - (17/2)*np.cos(10*t)\n                                    + (22/3)*np.cos(11*t) + (15/4)*np.cos(12*t) - (5/2)*np.cos(13*t) + (19/6)*np.cos(14*t) + (7/4)*np.cos(15*t)\n                                    + (31/4)*np.cos(16*t) - np.cos(17*t) + (11/10)*np.cos(18*t) - (2/3)*np.cos(19*t) + (13/3)*np.cos(20*t)\n                                    - (5/4)*np.cos(21*t) + (2/3)*np.cos(22*t) + (1/4)*np.cos(23*t) + (5/6)*np.cos(24*t) + (3/4)*np.cos(26*t)\n                                    - (1/2)*np.cos(27*t) - (1/10)*np.cos(28*t) - (1/3)*np.cos(29*t) - (1/19)*np.cos(30*t),\n                                    np.zeros_like(t))\n    return cls(parametric_function, t_values).points*0.1\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.circle","title":"<code>circle(radius=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a circle in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the circle of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef circle(cls, radius=1, t_values=None, num_points=100):\n    \"\"\"Create a circle in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the circle of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * np.cos(t_values),\n        radius * np.sin(t_values),\n        np.zeros_like(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.ellipse","title":"<code>ellipse(a=1, b=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create an ellipse in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>b</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the ellipse of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef ellipse(cls, a=1, b=1, t_values=None,num_points=100):\n    \"\"\"Create an ellipse in 3D space.\n\n    Args:\n        a (int, optional): _description_. Defaults to 1.\n        b (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the ellipse of shape (num_points, 3) \n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    x_values = a * np.cos(t_values)\n    y_values = b * np.sin(t_values)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.heart","title":"<code>heart(a=1, b=1, c=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a heart shape in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>b</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>c</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the heart shape of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef heart(cls, a=1, b=1, c=1,t_values=None,num_points=100):\n    \"\"\"Create a heart shape in 3D space.\n\n    Args:\n        a (int, optional): _description_. Defaults to 1.\n        b (int, optional): _description_. Defaults to 1.\n        c (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the heart shape of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(-np.pi, np.pi, num=num_points)\n    x_values = a * np.sin(t_values) ** 3\n    y_values = b * np.cos(t_values) - c * np.cos(2 * t_values)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.helix","title":"<code>helix(radius=1, pitch=1, height=1, num_turns=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a helix in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>pitch</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>height</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the helix of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef helix(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n    \"\"\"Create a helix in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        pitch (int, optional): _description_. Defaults to 1.\n        height (int, optional): _description_. Defaults to 1.\n        num_turns (int, optional): _description_. Defaults to 1.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the helix of shape (num_points, 3)\n    \"\"\"\n    t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * np.cos(t_values),\n        radius * np.sin(t_values),\n        height * t_values / (2 * np.pi) - pitch * num_turns * t_values / (2 * np.pi)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.lemniscate_of_bernoulli","title":"<code>lemniscate_of_bernoulli(a=1, b=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a lemniscate of Bernoulli in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>b</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the leminscate of Bernouli of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef lemniscate_of_bernoulli(cls, a=1, b=1, t_values=None,num_points=100):\n    \"\"\"Create a lemniscate of Bernoulli in 3D space.\n\n    Args:\n        a (int, optional): _description_. Defaults to 1.\n        b (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the leminscate of Bernouli of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    x_values = a * np.sqrt(2) * np.cos(t_values) / (np.sin(t_values) ** 2 + 1)\n    y_values = b * np.sqrt(2) * np.cos(t_values) * np.sin(t_values) / (np.sin(t_values) ** 2 + 1)\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (x_values, y_values, z_values)\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.line","title":"<code>line(length=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a line in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the line of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef line(cls, length=1, num_points=100):\n    \"\"\"Create a line in 3D space.\n\n    Args:\n        length (int, optional): _description_. Defaults to 1.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the line of shape (num_points, 3)\n    \"\"\"\n    t_values = np.linspace(0, 1, num=num_points)\n    parametric_function = lambda t_values: (\n        t_values * length,\n        np.zeros_like(t_values),\n        np.zeros_like(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.mobius_strip","title":"<code>mobius_strip(radius=1, width=0.5, num_twists=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a Mobius strip in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>width</code> <code>float</code> <p>description. Defaults to 0.5.</p> <code>0.5</code> <code>num_twists</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the Mobius strip of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef mobius_strip(cls, radius=1, width=0.5, num_twists=1, t_values=None, num_points=100):\n    \"\"\"Create a Mobius strip in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        width (float, optional): _description_. Defaults to 0.5.\n        num_twists (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the Mobius strip of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n    u_values = np.linspace(0, width, num=num_points)\n    u, t = np.meshgrid(u_values, t_values)\n    x_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.cos(t)\n    y_values = (radius + u * np.cos(t / 2) * np.cos(num_twists * t)) * np.sin(t)\n    z_values = u * np.sin(t / 2) * np.cos(num_twists * t)\n    parametric_function = lambda t_values: (\n        x_values.flatten(),\n        y_values.flatten(),\n        z_values.flatten()\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.spiral","title":"<code>spiral(radius=1, pitch=1, height=1, num_turns=1, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a spiral in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>pitch</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>height</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the spiral of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef spiral(cls, radius=1, pitch=1, height=1, num_turns=1, num_points=100):\n    \"\"\"Create a spiral in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        pitch (int, optional): _description_. Defaults to 1.\n        height (int, optional): _description_. Defaults to 1.\n        num_turns (int, optional): _description_. Defaults to 1.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the spiral of shape (num_points, 3)\n    \"\"\"\n    t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    parametric_function = lambda t_values: (\n        radius * t_values * np.cos(t_values),\n        radius * t_values * np.sin(t_values),\n        height * t_values / (2 * np.pi) * pitch\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.square","title":"<code>square(side=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a square in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the square of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef square(cls, side=1, t_values=None,num_points=100):\n    \"\"\"Create a square in 3D space.\n\n    Args:\n        side (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the square of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 4, num=num_points)\n    # Calculate x and y coordinates based on t_values\n    x_values = np.zeros_like(t_values)\n    y_values = np.zeros_like(t_values)\n    for i, t in enumerate(t_values):\n        if 0 &lt;= t &lt; 1:\n            x_values[i] = t * side\n            y_values[i] = 0\n        elif 1 &lt;= t &lt; 2:\n            x_values[i] = side\n            y_values[i] = (t - 1) * side\n        elif 2 &lt;= t &lt; 3:\n            x_values[i] = (3 - t) * side\n            y_values[i] = side\n        elif 3 &lt;= t &lt;= 4:\n            x_values[i] = 0\n            y_values[i] = (4 - t) * side\n    z_values = np.zeros_like(t_values)\n    parametric_function = lambda t_values: (\n        x_values,\n        y_values,\n        z_values\n    )\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.torus_helix","title":"<code>torus_helix(R=1, r=2, num_windings=3, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a torus helix in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>R</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>r</code> <code>int</code> <p>description. Defaults to 2.</p> <code>2</code> <code>num_windings</code> <code>int</code> <p>description. Defaults to 3.</p> <code>3</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the torus helix of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef torus_helix(cls, R=1, r=2, num_windings=3, t_values=None, num_points=100):\n    \"\"\"Create a torus helix in 3D space.\n\n    Args:\n        R (int, optional): _description_. Defaults to 1.\n        r (int, optional): _description_. Defaults to 2.\n        num_windings (int, optional): _description_. Defaults to 3.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the torus helix of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, 2 * np.pi, num=num_points)\n\n    parametric_function = lambda t_values: (\n        (R + r * np.cos(num_windings*t_values)) * np.cos( t_values),\n        (R + r * np.cos(num_windings*t_values)) * np.sin( t_values),\n        r * np.sin(t_values)\n    )\n    return cls(parametric_function, t_values, num_points=num_points).points\n</code></pre>"},{"location":"shapes-reference/#pymdna.utils.Shapes.trefoil","title":"<code>trefoil(radius=1, num_turns=1, t_values=None, num_points=100)</code>  <code>classmethod</code>","text":"<p>Create a trefoil knot in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>num_turns</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>t_values</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>description. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>points on the trefoil knot of shape (num_points, 3)</p> Source code in <code>pymdna/utils.py</code> <pre><code>@classmethod\ndef trefoil(cls, radius=1, num_turns=1,t_values=None,num_points=100):\n    \"\"\"Create a trefoil knot in 3D space.\n\n    Args:\n        radius (int, optional): _description_. Defaults to 1.\n        num_turns (int, optional): _description_. Defaults to 1.\n        t_values (_type_, optional): _description_. Defaults to None.\n        num_points (int, optional): _description_. Defaults to 100.\n\n    Returns:\n        points (np.ndarray): points on the trefoil knot of shape (num_points, 3)\n    \"\"\"\n    if t_values is None:\n        t_values = np.linspace(0, num_turns * 2 * np.pi, num=num_points)\n    x_values = np.sin(t_values) + 2 * np.sin(2 * t_values)\n    y_values = np.cos(t_values) - 2 * np.cos(2 * t_values)\n    z_values = -np.sin(3 * t_values)\n    parametric_function = lambda t_values: (\n        radius * x_values,\n        radius * y_values,\n        radius * z_values\n    )\n    return cls(parametric_function, t_values).points\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"}]}